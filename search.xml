<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>05.纯函数-柯里化-组合函数</title>
    <url>/2022/08/16/js%E9%AB%98%E7%BA%A7/05.%E7%BA%AF%E5%87%BD%E6%95%B0-%E6%9F%AF%E9%87%8C%E5%8C%96-%E7%BB%84%E5%90%88%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="一、纯函数"><a href="#一、纯函数" class="headerlink" title="一、纯函数"></a>一、纯函数</h1><blockquote>
<p>函数式编程就是把函数当作一等公民的时候就是函数式编程。</p>
</blockquote>
<h2 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h2><blockquote>
<p>如果一个函数满足以下三个条件，那么我们称这个函数为纯函数<br>函数相同输入值必须产生相同的输出<br>函数的输入、输出与（其他外界的隐藏的信息、状态、由I/O设备产生的外部输出-例如console.log）无关<br>函数不能有语义上可以观察出的副作用，例如’触发事件’、使输出设备输出、更改输出值以外的内容</p>
</blockquote>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实例一：更改了外界的内容</span></span><br><span class="line"><span class="selector-tag">var</span> name = <span class="string">'asd'</span></span><br><span class="line">function foo() &#123;</span><br><span class="line">    name = <span class="string">'hjj'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例二：相同输入没有相同的输出</span></span><br><span class="line"><span class="selector-tag">var</span> name = <span class="string">'asd'</span></span><br><span class="line">function foo() &#123;</span><br><span class="line">    return name</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">foo</span><span class="params">(<span class="number">12</span>)</span></span></span><br><span class="line">name = <span class="string">'hjj'</span></span><br><span class="line"><span class="function"><span class="title">foo</span><span class="params">(<span class="number">12</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例三：产生副作用,更改全局变量，更改localstorage等</span></span><br><span class="line"><span class="selector-tag">var</span> name = <span class="string">'asd'</span></span><br><span class="line">function foo() &#123;</span><br><span class="line">    localStorage.setItem(xxx)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例四：产生副作用，更改了obj，导致输入不相同了</span></span><br><span class="line">function foo(obj) &#123;</span><br><span class="line">    obj<span class="selector-class">.name</span> = <span class="string">'hjj'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">var</span> obj = &#123;name: <span class="string">'asd'</span>&#125;</span><br><span class="line"><span class="function"><span class="title">foo</span><span class="params">(obj)</span></span></span><br><span class="line">console.log(obj) <span class="comment">// &#123;name: 'hjj'&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例五：这是一个纯函数，相同输入有相同的输出</span></span><br><span class="line">function foo(obj) &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        ..<span class="selector-class">.obj</span>,</span><br><span class="line">        name: <span class="string">'hjj'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">var</span> obj = &#123;name: <span class="string">'asd'</span>&#125;</span><br><span class="line"><span class="function"><span class="title">foo</span><span class="params">(obj)</span></span></span><br><span class="line">console.log(obj) <span class="comment">// &#123;name: 'asd'&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="纯函数-数组的slice、splice对比"><a href="#纯函数-数组的slice、splice对比" class="headerlink" title="纯函数: 数组的slice、splice对比"></a>纯函数: 数组的<code>slice、splice</code>对比</h2><figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">var arr = [<span class="string">'asd'</span>, <span class="string">'sdf'</span>, <span class="string">'dfg'</span>, <span class="string">'ert'</span>]</span><br><span class="line"></span><br><span class="line">// <span class="string">`slice`</span>确定的输入一定有确定的输出，并且没有副作用，原数组没有更改</span><br><span class="line">var arr1 = arr.slice(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line">console.log(arr, arr1) // [<span class="string">'asd'</span>, <span class="string">'sdf'</span>, <span class="string">'dfg'</span>, <span class="string">'ert'</span>] (<span class="number">3</span>) [<span class="string">'asd'</span>, <span class="string">'sdf'</span>, <span class="string">'dfg'</span>]</span><br><span class="line"></span><br><span class="line">// 确定的输入有确定的输出，但是有副作用，更改了原来的数组</span><br><span class="line">var arr2 = arr.splice(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">console.log(arr, arr2) // [<span class="string">'dfg'</span>, <span class="string">'ert'</span>] (<span class="number">2</span>) [<span class="string">'asd'</span>, <span class="string">'sdf'</span>]</span><br></pre></td></tr></table></figure>
<h2 id="纯函数的优势"><a href="#纯函数的优势" class="headerlink" title="纯函数的优势"></a>纯函数的优势</h2><blockquote>
<p>安心的编写组件<br>保证确定的输入有确定的输出，不用关心传入的参数的来源，以及依赖的外部参数是否有变化，所以外界变化都不用关心</p>
</blockquote>
<h1 id="二、柯里化"><a href="#二、柯里化" class="headerlink" title="二、柯里化"></a>二、柯里化</h1><h2 id="概念：把一个接受多个参数的函数，变为接受单一参数的函数，并且返回接受剩余参数，并且返回结果的-新函数的技术叫做柯里化"><a href="#概念：把一个接受多个参数的函数，变为接受单一参数的函数，并且返回接受剩余参数，并且返回结果的-新函数的技术叫做柯里化" class="headerlink" title="概念：把一个接受多个参数的函数，变为接受单一参数的函数，并且返回接受剩余参数，并且返回结果的 新函数的技术叫做柯里化"></a>概念：把一个接受多个参数的函数，变为接受单一参数的函数，并且返回接受剩余参数，并且返回结果的 新函数的技术叫做柯里化</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">x,y,z</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y + z</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="comment">// 柯里化一</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">z</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x+y+z</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">sum(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)</span><br><span class="line"><span class="comment">// 柯里化二</span></span><br><span class="line"><span class="keyword">const</span> sum1 = <span class="function"><span class="params">x</span> =&gt;</span> <span class="function"><span class="params">y</span> =&gt;</span> <span class="function"><span class="params">z</span> =&gt;</span> x + y + z</span><br><span class="line">sum1(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<h2 id="为什么需要柯里化"><a href="#为什么需要柯里化" class="headerlink" title="为什么需要柯里化?"></a>为什么需要柯里化?</h2><blockquote>
<p>一个函数处理的问题尽可能的单一。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> log = <span class="function"><span class="params">date</span> =&gt;</span> <span class="function"><span class="params">type</span> =&gt;</span> <span class="function"><span class="params">message</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`[<span class="subst">$&#123;date.getHours()&#125;</span>:<span class="subst">$&#123;date.getMinutes()&#125;</span>],类型为:<span class="subst">$&#123;type&#125;</span>,内容为:<span class="subst">$&#123;message&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 都是当前时间，只是类型，信息不同</span></span><br><span class="line"><span class="keyword">var</span> nowLog = log(<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">nowLog(<span class="string">'string'</span>)(<span class="string">'我是字符串'</span>) <span class="comment">// [14:7],类型为:string,内容为:我是字符串</span></span><br><span class="line">nowLog(<span class="string">'number'</span>)(<span class="string">'我是数字'</span>) <span class="comment">// [14:7],类型为:number,内容为:我是数字</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间，类型相同</span></span><br><span class="line"><span class="keyword">var</span> nowStringLog = log(<span class="keyword">new</span> <span class="built_in">Date</span>())(<span class="string">'string'</span>);</span><br><span class="line">nowStringLog(<span class="string">'我是字符串111'</span>) <span class="comment">// [14:7],类型为:string,内容为:我是字符串111</span></span><br><span class="line">nowStringLog(<span class="string">'我是字符串322'</span>) <span class="comment">// [14:7],类型为:string,内容为:我是字符串322</span></span><br></pre></td></tr></table></figure>
<h2 id="柯里化实现"><a href="#柯里化实现" class="headerlink" title="柯里化实现"></a>柯里化实现</h2><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(x,y,z)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y+z</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hjjCurrying</span><span class="params">(fn)</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">curried</span><span class="params">(<span class="rest_arg">...arg</span>)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 判断当前传入的参数跟函数本身需要的参数的长度是否一直致</span></span><br><span class="line">        <span class="comment">// 1.传入的参数 &gt;= 函数需要的参数，就直接执行函数</span></span><br><span class="line">        <span class="keyword">if</span>(arg.length &gt;= fn.length)&#123;</span><br><span class="line">            <span class="comment">// 使用apply，是为了防止函数有改变this的情况，this出现问题</span></span><br><span class="line">             fn.apply(<span class="keyword">this</span>, arg)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 没有达到需要的个数时，需要返回一个新的函数，继续接收剩余参数</span></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">curried2</span><span class="params">(<span class="rest_arg">...arg2</span>)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//2.传入的参数不够需要的参数时，递归curried，直到传入的参数达到需要的参数长度。</span></span><br><span class="line">                <span class="keyword">return</span> curried.apply(<span class="keyword">this</span>, arg.concat(arg2))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> curried2</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curried</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> curryAdd = hjjCurrying(add)</span><br><span class="line"></span><br><span class="line">console.log(curryAdd(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)) <span class="comment">// 6</span></span><br><span class="line">console.log(curryAdd(<span class="number">1</span>,<span class="number">2</span>)(<span class="number">3</span>)) <span class="comment">// 6</span></span><br><span class="line">console.log(curryAdd(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)) <span class="comment">// 6</span></span><br><span class="line">console.log(curryAdd(<span class="number">1</span>)(<span class="number">2</span>,<span class="number">3</span>)) <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Js高级</category>
      </categories>
      <tags>
        <tag>Js</tag>
      </tags>
  </entry>
  <entry>
    <title>03.this指向</title>
    <url>/2021/12/30/js%E9%AB%98%E7%BA%A7/03.this%E6%8C%87%E5%90%91/</url>
    <content><![CDATA[<h1 id="一、普通函数"><a href="#一、普通函数" class="headerlink" title="一、普通函数"></a>一、普通函数</h1><h2 id="this指向相关因素"><a href="#this指向相关因素" class="headerlink" title="this指向相关因素"></a>this指向相关因素</h2><ul>
<li>this指向跟函数定义的位置没有关</li>
<li>this指向跟函数调用的位置、函数调用的方式有关</li>
</ul>
<h2 id="this指向规则"><a href="#this指向规则" class="headerlink" title="this指向规则"></a>this指向规则</h2><ul>
<li><h3 id="默认绑定-独立函数调用"><a href="#默认绑定-独立函数调用" class="headerlink" title="默认绑定 (独立函数调用)"></a>默认绑定 (独立函数调用)</h3><blockquote>
<p>指向window / undefined / {} — 非严格模式 / 严格模式 / node环境（默认全局对象是个空对象）</p>
</blockquote>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方案一</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">// window</span></span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 闭包中的this</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">// window</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123; </span><br><span class="line">    name: <span class="string">'hjj'</span>, </span><br><span class="line">    fn: fn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = obj.fn()</span><br><span class="line">bar()</span><br></pre></td></tr></table></figure>
<ul>
<li><h3 id="隐式绑定-指向某个对象"><a href="#隐式绑定-指向某个对象" class="headerlink" title="隐式绑定 (指向某个对象)"></a>隐式绑定 (指向某个对象)</h3><blockquote>
<p>隐式绑定一般是通过某个对象的方法来调用</p>
</blockquote>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方案一</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123; </span><br><span class="line">    name: <span class="string">'hjj'</span>, </span><br><span class="line">    fn: <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">// &#123;name: 'hjj', fn: ƒ&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.fn()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方案二</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">// &#123;name: 'hjj', fn: ƒ&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123; </span><br><span class="line">    name: <span class="string">'hjj'</span>, </span><br><span class="line">    fn: fn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.fn()</span><br></pre></td></tr></table></figure>
<ul>
<li><h3 id="显式绑定-指向现实绑定的对象"><a href="#显式绑定-指向现实绑定的对象" class="headerlink" title="显式绑定 (指向现实绑定的对象)"></a>显式绑定 (指向现实绑定的对象)</h3><blockquote>
<p>call、apply、bind三种方法绑定、还有一些特殊情况</p>
</blockquote>
<ul>
<li><h4 id="call方法-参数1-this的绑定对象，后序参数用逗号-隔开"><a href="#call方法-参数1-this的绑定对象，后序参数用逗号-隔开" class="headerlink" title="call方法: 参数1:this的绑定对象，后序参数用逗号 , 隔开"></a>call方法: 参数1:this的绑定对象，后序参数用逗号 , 隔开</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">function</span> <span class="string">fn(num1,</span> <span class="string">num2)&#123;</span></span><br><span class="line">  <span class="string">this.num1</span> <span class="string">=</span> <span class="string">num1</span></span><br><span class="line">  <span class="string">this.num2</span> <span class="string">=</span> <span class="string">num2</span></span><br><span class="line">  <span class="string">console.log(this)</span> <span class="string">//</span> <span class="string">&#123;name:</span> <span class="string">'hjj'</span><span class="string">,</span> <span class="attr">age:</span> <span class="number">18</span><span class="string">,</span> <span class="attr">num1:</span> <span class="number">3</span><span class="string">,</span> <span class="attr">num2:</span> <span class="number">4</span><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="string">var</span> <span class="string">obj</span> <span class="string">=</span> <span class="string">&#123;</span> <span class="attr">name:</span> <span class="string">'hjj'</span><span class="string">,</span> <span class="attr">age:</span> <span class="number">18</span> <span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="string">fn.call(obj,</span> <span class="number">3</span><span class="string">,</span> <span class="number">4</span><span class="string">)</span></span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="apply方法：参数1-this的绑定对象，后序参数使用数组传递"><a href="#apply方法：参数1-this的绑定对象，后序参数使用数组传递" class="headerlink" title="apply方法：参数1:this的绑定对象，后序参数使用数组传递"></a>apply方法：参数1:this的绑定对象，后序参数使用数组传递</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.num1 = num1</span><br><span class="line">  <span class="keyword">this</span>.num2 = num2</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">// &#123;name: 'hjj', age: 18, num1: 5, num2: 6&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">'hjj'</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;</span><br><span class="line"></span><br><span class="line">fn.apply(obj, [<span class="number">5</span>, <span class="number">6</span>])</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="bind方法，返回一个新的函数"><a href="#bind方法，返回一个新的函数" class="headerlink" title="bind方法，返回一个新的函数"></a>bind方法，返回一个新的函数</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.num1 = num1</span><br><span class="line">  <span class="keyword">this</span>.num2 = num2</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">'hjj'</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = fn.bind(obj, <span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="keyword">var</span> bar = fn</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo === fn) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(fn === bar) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// bind使用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.num1 = num1</span><br><span class="line">  <span class="keyword">this</span>.num2 = num2</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">// &#123;name: 'hjj', age: 18, num1: 1, num2: 2&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">'hjj'</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = fn.bind(obj, <span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 返回的是一个函数，可以调用</span></span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="特殊情况："><a href="#特殊情况：" class="headerlink" title="特殊情况："></a>特殊情况：</h4><ul>
<li><p>忽略显示绑定：绑定对象传递null、undefined</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.call(<span class="literal">null</span>) <span class="comment">// window</span></span><br><span class="line">foo.call(<span class="literal">undefined</span>) <span class="comment">// window</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>间接函数引用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  赋值(obj2.foo = obj1.foo)的结果是foo函数,相当于（obj1.foo）（），独立调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  name: <span class="string">"obj1"</span>,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  name: <span class="string">"obj2"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj1.foo(); <span class="comment">// obj1对象</span></span><br><span class="line">(obj2.foo = obj1.foo)(); <span class="comment">//window,</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><h3 id="new绑定-指向实例化的对象"><a href="#new绑定-指向实例化的对象" class="headerlink" title="new绑定 (指向实例化的对象)"></a>new绑定 (指向实例化的对象)</h3><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span></span>(name) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    console.log(<span class="built_in">this</span>, <span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">'hjj'</span>) <span class="comment">// Person &#123;name: 'hjj'&#125; 'hjj'</span></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">'hhh'</span>) <span class="comment">// Person &#123;name: 'hhh'&#125; 'hhh'</span></span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="内置函数绑定"><a href="#内置函数绑定" class="headerlink" title="内置函数绑定"></a>内置函数绑定</h3><ul>
<li>settimeout: 内部函数是独立调用，所以this指向window(非箭头函数)</li>
<li><p>元素onclick点击事件，或者是addEventListener指向元素本身</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> box = <span class="built_in">document</span>.getElementById(<span class="string">"id"</span>)</span><br><span class="line"></span><br><span class="line">box.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">// box对应的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>数组的方法，高阶函数foreach,map…</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'hjj'</span>, <span class="string">"hsh"</span>]</span><br><span class="line"></span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">// Window &#123;window: Window, self: Window, document: document, name: '', location: Location, …&#125;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">// String &#123;'abc'&#125;</span></span><br><span class="line">&#125;, <span class="string">"abc"</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="绑定顺序"><a href="#绑定顺序" class="headerlink" title="绑定顺序"></a>绑定顺序</h2><p>  new &gt; 显式绑定 &gt; 隐式绑定 &gt; 默认绑定</p>
<h1 id="二、箭头函数"><a href="#二、箭头函数" class="headerlink" title="二、箭头函数"></a>二、箭头函数</h1><ul>
<li>箭头函数箭头函本身没有this</li>
<li>箭头函数不使用普通函数的规则</li>
<li>箭头函数的this根绝外层作用域来决定<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 箭头函数不绑定this.找上层作用域，他的上层作用域是第4行函数的作用域，此时第四行的作用域是obj</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  data: [],</span><br><span class="line">  getData: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">// &#123;data: Array(0), getData: ƒ&#125;</span></span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.getData();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更上一个例子的区别是，getData也是一个箭头函数，也没有this,继续向上找，直到最后是window</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  data: [],</span><br><span class="line">  getData: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">// window</span></span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.getData();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="三、面试题"><a href="#三、面试题" class="headerlink" title="三、面试题"></a>三、面试题</h1><h2 id="面试题1"><a href="#面试题1" class="headerlink" title="面试题1"></a>面试题1</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"window"</span>;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">"person"</span>,</span><br><span class="line">  sayName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sss = person.sayName;</span><br><span class="line">  sss();</span><br><span class="line">  person.sayName();</span><br><span class="line">  (person.sayName)();</span><br><span class="line">  (b = person.sayName)();</span><br><span class="line">&#125;</span><br><span class="line">sayName();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 答案</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sss = person.sayName;</span><br><span class="line">  sss(); <span class="comment">// window</span></span><br><span class="line">  person.sayName(); <span class="comment">// person</span></span><br><span class="line">  (person.sayName)();  <span class="comment">// person</span></span><br><span class="line">  (b = person.sayName)();  <span class="comment">// window</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题2"><a href="#面试题2" class="headerlink" title="面试题2"></a>面试题2</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'window'</span></span><br><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  name: <span class="string">'person1'</span>,</span><br><span class="line">  foo1: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;,</span><br><span class="line">  foo2: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>.name),</span><br><span class="line">  foo3: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  foo4: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = &#123; <span class="attr">name</span>: <span class="string">'person2'</span> &#125;</span><br><span class="line"></span><br><span class="line">person1.foo1(); </span><br><span class="line">person1.foo1.call(person2); </span><br><span class="line"></span><br><span class="line">person1.foo2();</span><br><span class="line">person1.foo2.call(person2);</span><br><span class="line"></span><br><span class="line">person1.foo3()();</span><br><span class="line">person1.foo3.call(person2)();</span><br><span class="line">person1.foo3().call(person2);</span><br><span class="line"></span><br><span class="line">person1.foo4()();</span><br><span class="line">person1.foo4.call(person2)();</span><br><span class="line">person1.foo4().call(person2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 答案</span></span><br><span class="line">person1.foo1(); <span class="comment">// person1</span></span><br><span class="line">person1.foo1.call(person2); <span class="comment">// person2</span></span><br><span class="line"></span><br><span class="line">person1.foo2(); <span class="comment">// window</span></span><br><span class="line">person1.foo2.call(person2); <span class="comment">//window</span></span><br><span class="line"></span><br><span class="line">person1.foo3()(); <span class="comment">// window</span></span><br><span class="line">person1.foo3.call(person2)(); <span class="comment">// window</span></span><br><span class="line">person1.foo3().call(person2); <span class="comment">// person2</span></span><br><span class="line"></span><br><span class="line">person1.foo4()(); <span class="comment">// person1</span></span><br><span class="line">person1.foo4.call(person2)(); <span class="comment">// person2</span></span><br><span class="line">person1.foo4().call(person2); <span class="comment">// person1</span></span><br></pre></td></tr></table></figure>
<h2 id="面试题3"><a href="#面试题3" class="headerlink" title="面试题3"></a>面试题3</h2><figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">name</span> = <span class="string">'window'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> <span class="params">(<span class="keyword">name</span>)</span> <span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">  this.name = name</span></span></span><br><span class="line"><span class="function"><span class="comment">  this.foo1 = function () &#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    console.log(this.name)</span></span></span><br><span class="line"><span class="function"><span class="comment">  &#125;</span>,</span></span><br><span class="line"><span class="function">  <span class="title">this</span>.<span class="title">foo2</span> = <span class="params">()</span> =&gt; <span class="title">console</span>.<span class="title">log</span><span class="params">(this.<span class="keyword">name</span>)</span>,</span></span><br><span class="line"><span class="function">  <span class="title">this</span>.<span class="title">foo3</span> = <span class="title">function</span> <span class="params">()</span> <span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    return function () &#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">      console.log(this.name)</span></span></span><br><span class="line"><span class="function"><span class="comment">    &#125;</span></span></span><br><span class="line"><span class="function">  &#125;,</span></span><br><span class="line"><span class="function">  <span class="title">this</span>.<span class="title">foo4</span> = <span class="title">function</span> <span class="params">()</span> <span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    return () =&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">      console.log(this.name)</span></span></span><br><span class="line"><span class="function"><span class="comment">    &#125;</span></span></span><br><span class="line"><span class="function">  &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">person1</span> = <span class="title">new</span> <span class="title">Person</span><span class="params">(<span class="string">'person1'</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">person2</span> = <span class="title">new</span> <span class="title">Person</span><span class="params">(<span class="string">'person2'</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">person1</span>.<span class="title">foo1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">person1</span>.<span class="title">foo1</span>.<span class="title">call</span><span class="params">(person2)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">person1</span>.<span class="title">foo2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">person1</span>.<span class="title">foo2</span>.<span class="title">call</span><span class="params">(person2)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">person1</span>.<span class="title">foo3</span><span class="params">()</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">person1</span>.<span class="title">foo3</span>.<span class="title">call</span><span class="params">(person2)</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">person1</span>.<span class="title">foo3</span><span class="params">()</span>.<span class="title">call</span><span class="params">(person2)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">person1</span>.<span class="title">foo4</span><span class="params">()</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">person1</span>.<span class="title">foo4</span>.<span class="title">call</span><span class="params">(person2)</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">person1</span>.<span class="title">foo4</span><span class="params">()</span>.<span class="title">call</span><span class="params">(person2)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 答案</span></span></span><br><span class="line"><span class="function"><span class="title">person1</span>.<span class="title">foo1</span><span class="params">()</span> <span class="comment">// person1</span></span></span><br><span class="line"><span class="function"><span class="title">person1</span>.<span class="title">foo1</span>.<span class="title">call</span><span class="params">(person2)</span> <span class="comment">// person2</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">person1</span>.<span class="title">foo2</span><span class="params">()</span> <span class="comment">// person1</span></span></span><br><span class="line"><span class="function"><span class="title">person1</span>.<span class="title">foo2</span>.<span class="title">call</span><span class="params">(person2)</span> <span class="comment">// person1</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">person1</span>.<span class="title">foo3</span><span class="params">()</span><span class="params">()</span> <span class="comment">// window</span></span></span><br><span class="line"><span class="function"><span class="title">person1</span>.<span class="title">foo3</span>.<span class="title">call</span><span class="params">(person2)</span><span class="params">()</span> <span class="comment">// window</span></span></span><br><span class="line"><span class="function"><span class="title">person1</span>.<span class="title">foo3</span><span class="params">()</span>.<span class="title">call</span><span class="params">(person2)</span> <span class="comment">// person2</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">person1</span>.<span class="title">foo4</span><span class="params">()</span><span class="params">()</span> <span class="comment">// person1</span></span></span><br><span class="line"><span class="function"><span class="title">person1</span>.<span class="title">foo4</span>.<span class="title">call</span><span class="params">(person2)</span><span class="params">()</span> <span class="comment">// person2</span></span></span><br><span class="line"><span class="function"><span class="title">person1</span>.<span class="title">foo4</span><span class="params">()</span>.<span class="title">call</span><span class="params">(person2)</span> <span class="comment">// person1</span></span></span><br></pre></td></tr></table></figure>
<h2 id="面试题4"><a href="#面试题4" class="headerlink" title="面试题4"></a>面试题4</h2><figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">name</span> = <span class="string">'window'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> <span class="params">(<span class="keyword">name</span>)</span> <span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">  this.name = name</span></span></span><br><span class="line"><span class="function"><span class="comment">  this.obj = &#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    name: 'obj',</span></span></span><br><span class="line"><span class="function"><span class="comment">    foo1: function () &#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">      return function () &#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">        console.log(this.name)</span></span></span><br><span class="line"><span class="function"><span class="comment">      &#125;</span></span></span><br><span class="line"><span class="function">    &#125;,</span></span><br><span class="line"><span class="function">    <span class="title">foo2</span>:</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> <span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">      return () =&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">        console.log(this.name)</span></span></span><br><span class="line"><span class="function"><span class="comment">      &#125;</span></span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">  &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">person1</span> = <span class="title">new</span> <span class="title">Person</span><span class="params">(<span class="string">'person1'</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">person2</span> = <span class="title">new</span> <span class="title">Person</span><span class="params">(<span class="string">'person2'</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">person1</span>.<span class="title">obj</span>.<span class="title">foo1</span><span class="params">()</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">person1</span>.<span class="title">obj</span>.<span class="title">foo1</span>.<span class="title">call</span><span class="params">(person2)</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">person1</span>.<span class="title">obj</span>.<span class="title">foo1</span><span class="params">()</span>.<span class="title">call</span><span class="params">(person2)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">person1</span>.<span class="title">obj</span>.<span class="title">foo2</span><span class="params">()</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">person1</span>.<span class="title">obj</span>.<span class="title">foo2</span>.<span class="title">call</span><span class="params">(person2)</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">person1</span>.<span class="title">obj</span>.<span class="title">foo2</span><span class="params">()</span>.<span class="title">call</span><span class="params">(person2)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 答案</span></span></span><br><span class="line"><span class="function"><span class="title">person1</span>.<span class="title">obj</span>.<span class="title">foo1</span><span class="params">()</span><span class="params">()</span> <span class="comment">// window</span></span></span><br><span class="line"><span class="function"><span class="title">person1</span>.<span class="title">obj</span>.<span class="title">foo1</span>.<span class="title">call</span><span class="params">(person2)</span><span class="params">()</span> <span class="comment">// window</span></span></span><br><span class="line"><span class="function"><span class="title">person1</span>.<span class="title">obj</span>.<span class="title">foo1</span><span class="params">()</span>.<span class="title">call</span><span class="params">(person2)</span> <span class="comment">// person2</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">person1</span>.<span class="title">obj</span>.<span class="title">foo2</span><span class="params">()</span><span class="params">()</span> <span class="comment">// obj</span></span></span><br><span class="line"><span class="function"><span class="title">person1</span>.<span class="title">obj</span>.<span class="title">foo2</span>.<span class="title">call</span><span class="params">(person2)</span><span class="params">()</span> <span class="comment">// person2</span></span></span><br><span class="line"><span class="function"><span class="title">person1</span>.<span class="title">obj</span>.<span class="title">foo2</span><span class="params">()</span>.<span class="title">call</span><span class="params">(person2)</span> <span class="comment">// obj</span></span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Js高级</category>
      </categories>
      <tags>
        <tag>Js</tag>
      </tags>
  </entry>
  <entry>
    <title>04.手写call、apply、bind</title>
    <url>/2021/12/30/js%E9%AB%98%E7%BA%A7/04.%E6%89%8B%E5%86%99call%E3%80%81apply%E3%80%81bind/</url>
    <content><![CDATA[<blockquote>
<p>本笔记真是针对实现思路，具体实现要处理很多临界情况，目前只大致实现.</p>
</blockquote>
<h1 id="一、call实现"><a href="#一、call实现" class="headerlink" title="一、call实现"></a>一、call实现</h1><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">Function.prototype.hjjCall = <span class="function"><span class="keyword">function</span> <span class="params">(thisArg, <span class="rest_arg">...arg</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.拿到调用hjjCall的函数，此处称为主函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// this为以下三行</span></span><br><span class="line">    <span class="comment">// ƒ foo() &#123;</span></span><br><span class="line">    <span class="comment">//     console.log(this)</span></span><br><span class="line">    <span class="comment">// &#125; </span></span><br><span class="line">    <span class="keyword">var</span> fn = <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.thisArg处理为对象类型（防止传入的为非对象类型）</span></span><br><span class="line">    thisArg = thisArg ? Object(thisArg) : window <span class="comment">// 1:处理绑定的this为null/undefined的情况，this为window  2:object(xxx)处理参数为对应的包装对象（Number &#123;123, fn: ƒ&#125;），否则123不能添加属性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.调用主函数</span></span><br><span class="line">    thisArg.fn = fn <span class="comment">// 2.改变this指向为第一个参数，借用对象调用隐式改变</span></span><br><span class="line">    <span class="keyword">var</span> result = thisArg.fn(...arg)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.返回结果</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(num1, num2)</span> </span>&#123;</span><br><span class="line">    console.log(<span class="keyword">this</span>, num1, num2) <span class="comment">// Number &#123;123, fn: ƒ&#125; 1 2</span></span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data = foo.hjjCall(<span class="number">123</span>, <span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">console.log(data) <span class="comment">//3</span></span><br></pre></td></tr></table></figure>
<h1 id="二、apply"><a href="#二、apply" class="headerlink" title="二、apply"></a>二、apply</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.hjjApply = <span class="function"><span class="keyword">function</span> (<span class="params">thisArg, argArray</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> fn = <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line">    thisArg = (thisArg !== <span class="literal">null</span> &amp;&amp; thisArg !== <span class="literal">undefined</span>) ? <span class="built_in">Object</span>(thisArg) : <span class="built_in">window</span></span><br><span class="line">    thisArg.fn = fn</span><br><span class="line">    </span><br><span class="line">    argArray = argArray || [] <span class="comment">// 用来处理不传参数报错</span></span><br><span class="line">    <span class="keyword">return</span> thisArg.fn(...argArray)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>, num1, num2)</span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以下写法报错：Script snippet %237:219 Uncaught TypeError: Found non-callable @@iterator</span></span><br><span class="line"><span class="comment">// var data = foo.hjjApply(123, 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不传参数：Uncaught TypeError: argArray is not iterable (cannot read property undefined)</span></span><br><span class="line"> <span class="keyword">var</span> data = foo.hjjApply(<span class="number">123</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(data)</span><br></pre></td></tr></table></figure>
<h1 id="三、bind实现"><a href="#三、bind实现" class="headerlink" title="三、bind实现"></a>三、bind实现</h1><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">Function.prototype.hjjBind = <span class="function"><span class="keyword">function</span> <span class="params">(thisArg, <span class="rest_arg">...argArray</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> fn = <span class="keyword">this</span></span><br><span class="line">    </span><br><span class="line">    thisArg = (thisArg !== <span class="literal">null</span> &amp;&amp; thisArg !==<span class="literal">undefined</span>) ? object(thisArg) : window</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">a</span><span class="params">(<span class="rest_arg">...args</span>)</span> </span>&#123;</span><br><span class="line">        thisArg.fn = fn</span><br><span class="line">        thisArg.fn([...argArray,...args])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(num1, num2, num3, num4)</span></span>&#123;</span><br><span class="line">    console.log(<span class="keyword">this</span>, num1, num2, num3, num4)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">var</span> res = foo.bind(<span class="string">'123'</span>,<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line">res(<span class="number">40</span>,<span class="number">50</span>)</span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">var</span> res = foo.bind(<span class="string">'123'</span>,<span class="number">10</span>,<span class="number">20</span>,<span class="number">40</span>,<span class="number">50</span>)</span><br><span class="line">res()</span><br><span class="line"><span class="comment">// 写法三</span></span><br><span class="line"><span class="keyword">var</span> res = foo.bind(<span class="string">'123'</span>)</span><br><span class="line">res(<span class="number">10</span>,<span class="number">20</span>,<span class="number">40</span>,<span class="number">50</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Js高级</category>
      </categories>
      <tags>
        <tag>Js</tag>
      </tags>
  </entry>
  <entry>
    <title>01.浏览器原理-V8-js执行原理</title>
    <url>/2021/12/30/js%E9%AB%98%E7%BA%A7/01.%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86-V8%E5%BC%95%E6%93%8E-js%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="一、浏览器原理"><a href="#一、浏览器原理" class="headerlink" title="一、浏览器原理"></a>一、浏览器原理</h1><ul>
<li>浏览器内核（通常指的是排版引擎）也可以叫做排版引擎、浏览器引擎、页面渲染引擎等，html、js、css都是经过浏览器内核呈现给用户的。</li>
<li>浏览器渲染过程<ul>
<li>输入网址，服务器返回以一个index.html，html解析遇到htm、css、js都去下载，然后渲染</li>
<li>浏览器在html解析的时候遇到js会停止解析html，去解析、加载js</li>
<li>layout的作用，根据浏览器的状态不同（屏幕的宽度不同，绝对定位的位置等），页面上元素渲染要根据layout渲染</li>
</ul>
</li>
</ul>
<p><img src="/images/js高级/浏览器渲染过程.png" alt="浏览器渲染过程"></p>
<ul>
<li>我们编写的js不管是交给浏览器还是node执行，最后都是cpu执行的，但是cpu是不认识我们编写的js代码的，所以需要js引擎帮助我们把js代码翻译成cpu认识的cpu指令、机器语言（0100101）来执行。<ul>
<li>浏览器内核<ul>
<li>gecko: 早期netspace和mozilla firefox浏览器使用</li>
<li>trident：微软开发被ie4-11使用，edge浏览器使用的blink</li>
<li>webkit: 苹果公司开发的，之前safari 、goole chrome也在使用</li>
<li>blink: 是webkit的一个分支。google开发，使用于chrome，edge,oprea等</li>
</ul>
</li>
<li>常见的js引擎<ul>
<li>SpiderMonkey:第一个js引擎，js作者开发的</li>
<li>Chakra：微软开发，用于ie浏览器</li>
<li>JavaScriptCore: webkit中的引擎，apple公司开发</li>
<li>V8: goole开发的，chrome浏览器使用。v8执行速度快。node也是使用的v8来解析js代码的</li>
</ul>
</li>
<li>浏览器内核与js引擎关系 webkit为例子：<ul>
<li>webkit: 由webcore（负责html解析、布局、渲染相关工作）和jscore（js解析、执行工作）组成</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="二、V8引擎原理"><a href="#二、V8引擎原理" class="headerlink" title="二、V8引擎原理"></a>二、V8引擎原理</h1><blockquote>
<p>ast网址：<a href="https://astexplorer.net/" target="_blank" rel="noopener">https://astexplorer.net/</a></p>
</blockquote>
<ul>
<li>视频1:08之后看</li>
<li><p>js代码通过parser（v8的一个库）转换为ast</p>
<ul>
<li>js代码解析会经过词法分析、语法分析过程<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//词法分析</span></span><br><span class="line">const name = <span class="string">'hjj'</span></span><br><span class="line">tokens = [&#123;<span class="string">type:</span> <span class="string">''</span>keyword, <span class="string">value:</span> <span class="string">'const'</span>&#125;, &#123;<span class="string">type:</span> <span class="string">'identify'</span>, <span class="string">value:</span> <span class="string">'name'</span>&#125;....]</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>ast经过ignation模块转换为字节码（bytecode）,此步骤有优化（详见视频1:33分左右）</p>
</li>
<li>字节码转为汇编语言在转为机器语言就可以运行了</li>
</ul>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul>
<li>打开浏览器输入网址，服务端返回index.html</li>
<li>内核解析index.html，遇到link（css）、 script（js）标签去下载对应的文件</li>
<li>执行js的时候cpu不认识js这种高级语言，所以此时需要js引擎（V8目前流行的js引擎）来帮助转换为机器识别的指令来执行。<ul>
<li>js代码都是cpu执行的。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Js高级</category>
      </categories>
      <tags>
        <tag>Js</tag>
      </tags>
  </entry>
  <entry>
    <title>07.原型-函数原型</title>
    <url>/2022/08/16/js%E9%AB%98%E7%BA%A7/07.%E5%8E%9F%E5%9E%8B-%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="一、批量创建对象的方法"><a href="#一、批量创建对象的方法" class="headerlink" title="一、批量创建对象的方法"></a>一、批量创建对象的方法</h1><h2 id="1-工厂模式"><a href="#1-工厂模式" class="headerlink" title="1.工厂模式"></a>1.工厂模式</h2><ul>
<li>缺点：所有对象拿到的都是一个object类型，但是不能明确看出来是那个类型</li>
</ul>
<h2 id="2-构造函数"><a href="#2-构造函数" class="headerlink" title="2.构造函数"></a>2.构造函数</h2><ul>
<li><p>概念：也称为构造器（constructor），通常在创建对象的时候调用的函数叫做构造函数.当一个普通函数使用new操作符调用的话，那么他就是一个构造函数。一般构造函数首字母大写。</p>
</li>
<li><p>缺点：每次new一个新的对象的时候，构造函数中的方法都会新创建一个，消耗太大</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name,</span><br><span class="line">    <span class="keyword">this</span>.runing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;name&#125;</span>在跑步`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'章三'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">'里斯'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p1.runing === p2.runing) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="3-new操作符过程发生了什么？"><a href="#3-new操作符过程发生了什么？" class="headerlink" title="3.new操作符过程发生了什么？"></a>3.new操作符过程发生了什么？</h2><p>  1.内存中创建一个空对象<br>  2.这个对象内部的[[prototype]]属性会被赋值为构造函数的prototype属性<br>  3.将构造函数的this指向这个对象<br>  4.执行函数体代码<br>  5.如果构造函数没有返回空对象，返回这个对象。</p>
<h2 id="4-对象的原型（隐式）"><a href="#4-对象的原型（隐式）" class="headerlink" title="4.对象的原型（隐式）"></a>4.对象的原型（隐式）</h2><ul>
<li>每个对象都有一个内置属性[[prototype]]，早期浏览器为了大家能看到原型，所以提供了一个<strong>proto</strong>来查看原型的。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">name</span>: <span class="string">'hjj'</span>&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>obj展示如下图<br><img src="/images/js高级/07-对象的原型.png" alt></p>
<ul>
<li>es5之后ecma提供了一个方法来获取原型<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;name: <span class="string">'hjj'</span>&#125;</span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(obj)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>结果如下图<br><img src="/images/js高级/07-对象的原型.png" alt></p>
<blockquote>
<p>以上两种方法得到的不一样是因为第一种是浏览器提供的。以上原型称为隐式原型（对象的原型）。</p>
</blockquote>
<ul>
<li>原型有什么用？<br>当我们获取一个对象的某个属性的时候，会调用对象的[[get]]属性，如果对象本身没有该属性，就会去对象的原型链上去寻找，如果原型链上也没有返回undefined.</li>
</ul>
<h2 id="5-函数的原型（显式）"><a href="#5-函数的原型（显式）" class="headerlink" title="5.函数的原型（显式）"></a>5.函数的原型（显式）</h2><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>函数作为对象也是有隐式原型的，其实用的是new Function<br>// <code>__proto__</code>有兼容性问题，因为浏览器提供<figure class="highlight plain"><figcaption><span>// ƒ () &#123; [native code] &#125;```</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* 函数除了作为对象，还是function，所以会有一个显式原型属性：prototype</span><br><span class="line">// `prototype`无兼容问题，标准属性</span><br><span class="line">```console.log(foo.prototype) // 结果见下图</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>Js高级</category>
      </categories>
      <tags>
        <tag>Js</tag>
      </tags>
  </entry>
  <entry>
    <title>06.with-evel-严格模式-面向对象</title>
    <url>/2022/08/16/js%E9%AB%98%E7%BA%A7/06.with-evel-%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="一、with"><a href="#一、with" class="headerlink" title="一、with"></a>一、with</h1><blockquote>
<p>with可以形成作用域</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">'hello'</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">name</span>: <span class="string">'hjj'</span>, <span class="attr">message</span>: <span class="string">'我是with'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(message) <span class="comment">// hello</span></span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">with</span>(obj)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(message) <span class="comment">// 我是with</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br></pre></td></tr></table></figure>
<p>不建议使用with语句，可能产生混淆错误，以及兼容性问题</p>
<h1 id="二、eval"><a href="#二、eval" class="headerlink" title="二、eval"></a>二、eval</h1><h2 id="可以把字符串当作js语句执行"><a href="#可以把字符串当作js语句执行" class="headerlink" title="可以把字符串当作js语句执行"></a>可以把字符串当作js语句执行</h2><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">var</span> message = <span class="string">'console.log("我是evel")'</span></span><br><span class="line"><span class="function"><span class="title">eval</span><span class="params">(message)</span></span> <span class="comment">// 我是eve</span></span><br></pre></td></tr></table></figure>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>可读性差</li>
<li>安全性差，可以串改代码</li>
<li>eval需要经过js解析，但是不能被js引擎优化代码</li>
</ul>
<h1 id="三、严格模式"><a href="#三、严格模式" class="headerlink" title="三、严格模式"></a>三、严格模式</h1><p>es5中推荐出来的标准 – 严格模式</p>
<h1 id="四、面向对象"><a href="#四、面向对象" class="headerlink" title="四、面向对象"></a>四、面向对象</h1><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'key'</span>, descriptor)</span><br></pre></td></tr></table></figure>
<h2 id="数据属性操作符"><a href="#数据属性操作符" class="headerlink" title="数据属性操作符"></a>数据属性操作符</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'key'</span>, &#123;</span><br><span class="line">    value: <span class="literal">undefined</span>, <span class="comment">// 默认值undefined</span></span><br><span class="line">    configurable: <span class="literal">false</span>, <span class="comment">// 默认值false, 是否可以删除目标属性，是否可以设置其他数据属性</span></span><br><span class="line">    enumerable:<span class="literal">false</span>, <span class="comment">// 默认值false, 是否可以被枚举</span></span><br><span class="line">    writable:<span class="literal">false</span> <span class="comment">// 默认值false, 是否可以重写属性值</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">name</span>: <span class="string">'hjj'</span>&#125; <span class="comment">// 数据操作符默认值是true</span></span><br></pre></td></tr></table></figure>
<h2 id="存取属性操作符"><a href="#存取属性操作符" class="headerlink" title="存取属性操作符"></a>存取属性操作符</h2><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">Object.defineProperty(obj, <span class="string">'key'</span>, &#123;</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    configurable: <span class="literal">false</span>,</span><br><span class="line">    <span class="keyword">get</span>: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;&#125;,</span><br><span class="line">    <span class="keyword">set</span>: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">let obj = &#123;name: <span class="string">'hjj'</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="定义多个属性描述符"><a href="#定义多个属性描述符" class="headerlink" title="定义多个属性描述符"></a>定义多个属性描述符</h2><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">let obj = &#123;&#125;</span><br><span class="line">Object.defineProperties(obj, &#123;</span><br><span class="line">    name: &#123;</span><br><span class="line">        enumerable: <span class="literal">true</span>,</span><br><span class="line">        writable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span>,</span><br><span class="line">        value: <span class="string">''</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    age: &#123;</span><br><span class="line">        enumerable: <span class="literal">false</span>,</span><br><span class="line">        configurable: <span class="literal">false</span>,</span><br><span class="line">        <span class="keyword">get</span>: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;&#125;,</span><br><span class="line">        <span class="keyword">set</span>: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;&#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h2><figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">   <span class="built_in"> name</span>: <span class="string">'hjj'</span>,</span><br><span class="line">    age: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line">// 获取某个属性操作符</span><br><span class="line">Object.getOwnPropertyDescriptor(obj, <span class="string">'name'</span>) </span><br><span class="line">// &#123;value: <span class="string">'hjj'</span>, writable:<span class="built_in"> true</span>, enumerable:<span class="built_in"> true</span>, configurable:<span class="built_in"> true</span>&#125;</span><br><span class="line"></span><br><span class="line">//获取对象属性操作符</span><br><span class="line">Object.getOwnPropertyDescriptors(obj)</span><br><span class="line">// <span class="built_in">&#123;name</span>: &#123;…&#125;, age: &#123;…&#125;&#125;</span><br><span class="line">// age: &#123;value: <span class="number">18</span>, writable:<span class="built_in"> true</span>, enumerable:<span class="built_in"> true</span>, configurable:<span class="built_in"> true</span>&#125;</span><br><span class="line">//<span class="built_in"> name</span>: &#123;value: <span class="string">'hjj'</span>, writable:<span class="built_in"> true</span>, enumerable:<span class="built_in"> true</span>, configurable:<span class="built_in"> true</span>&#125;</span><br><span class="line"></span><br><span class="line">// 禁止给对象添加属性</span><br><span class="line">Object.preventExtensions(obj)</span><br><span class="line">obj.height = <span class="number">1.8</span></span><br><span class="line">console.log(obj) // <span class="built_in">&#123;name</span>: <span class="string">'hjj'</span>, age: <span class="number">18</span>&#125;</span><br><span class="line"></span><br><span class="line">// 禁止删除属性</span><br><span class="line">Object.seal(obj)</span><br><span class="line"><span class="keyword">delete</span> obj<span class="built_in">.name</span></span><br><span class="line">console.log(obj) // <span class="built_in">&#123;name</span>: <span class="string">'hjj'</span>, age: <span class="number">18</span>&#125;</span><br><span class="line"></span><br><span class="line">// 禁止修改属性,冻结属性,只冻结一级属性</span><br><span class="line">Object.freeze(obj)</span><br><span class="line">obj<span class="built_in">.name</span> = <span class="string">'hhh'</span></span><br><span class="line">console.log(obj) // <span class="built_in">&#123;name</span>: <span class="string">'hjj'</span>, age: <span class="number">18</span>&#125;</span><br><span class="line"></span><br><span class="line">Object.freeze(obj)</span><br><span class="line">obj.obj1.height = <span class="string">'hhh'</span></span><br><span class="line">console.log(obj) // <span class="built_in">&#123;name</span>: <span class="string">'hjj'</span>, age: <span class="number">18</span>, obj1: &#123;height: <span class="string">'hhh'</span>&#125;&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Js高级</category>
      </categories>
      <tags>
        <tag>Js</tag>
      </tags>
  </entry>
  <entry>
    <title>nodejs</title>
    <url>/2022/04/21/node/node%E6%A6%82%E8%A7%88/</url>
    <content><![CDATA[<h2 id="一、node-js是什么"><a href="#一、node-js是什么" class="headerlink" title="一、node.js是什么"></a>一、node.js是什么</h2><ul>
<li>是运行在服务器上的JavaScript<br>- 是一个javascript运行时环境,不是语言 不是框架 是一个环境 一个平台</li>
</ul>
<h2 id="二、nodejs的特性"><a href="#二、nodejs的特性" class="headerlink" title="二、nodejs的特性"></a>二、nodejs的特性</h2><ul>
<li>单线程</li>
<li>非阻塞IO</li>
<li>基于事件模型</li>
<li>服务端的javascript</li>
</ul>
<h2 id="三、nodejs中的javascript"><a href="#三、nodejs中的javascript" class="headerlink" title="三、nodejs中的javascript"></a>三、nodejs中的javascript</h2><h3 id="ECMAScript"><a href="#ECMAScript" class="headerlink" title="ECMAScript"></a>ECMAScript</h3><ul>
<li>也就是js的基本语法 node中同样适用</li>
<li>没有bom 和 dom 的api</li>
</ul>
<h3 id="模块系统"><a href="#模块系统" class="headerlink" title="模块系统"></a>模块系统</h3><ul>
<li>在 Node 中没有全局作用域的概念，只有模块作用域</li>
<li>在 Node 中，只能通过 require 方法来加载执行多个 JavaScript 脚本文件</li>
<li>require 加载只能是执行其中的代码，文件与文件之间由于是模块作用域，所以不会有污染的问题<ul>
<li>模块完全是封闭的</li>
<li>外部无法访问内部</li>
<li>内部也无法访问外部</li>
<li>模块作用域固然带来了一些好处，可以加载执行多个文件，可以完全避免变量命名冲突污染的问题</li>
</ul>
</li>
<li>但是某些情况下，模块与模块是需要进行通信的</li>
<li>在每个模块中，都提供了一个对象：<code>exports</code></li>
<li>该对象默认是一个空对象</li>
<li>你要做的就是把需要被外部访问使用的成员手动的挂载到 <code>exports</code> 接口对象中</li>
<li>然后谁来 <code>require</code> 这个模块，谁就可以得到模块内部的 <code>exports</code> 接口对象</li>
</ul>
<h3 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h3><p>定义：核心模块是由 Node 提供的一个个的具名的模块，它们都有自己特殊的名称标识，例如</p>
<ul>
<li>fs 文件操作模块</li>
<li>http 网络服务构建模块</li>
<li>s 操作系统信息模块</li>
<li>path 路径处理模块</li>
</ul>
<p>注意：所有核心模块在使用的时候都必须手动的先使用 <code>require</code> 方法来加载，然后才可以使用（ var fs = require(‘fs’)）</p>
<h4 id="系统核心模块-http"><a href="#系统核心模块-http" class="headerlink" title="系统核心模块 (http)"></a>系统核心模块 (http)</h4><blockquote>
<p>注意:一次响应对应一次请求</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入http模块</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建server服务</span></span><br><span class="line"><span class="keyword">var</span> server = http.createServer()</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听请求</span></span><br><span class="line">server.on(<span class="string">'request'</span>,<span class="function"><span class="keyword">function</span> (<span class="params">req,res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(req.url)</span><br><span class="line">    <span class="comment">//设置响应头中的contenttype为 utf-8 防止乱码</span></span><br><span class="line">    res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/plain; charset=utf-8'</span>)</span><br><span class="line">    <span class="comment">//设置响应体 并 结束本次响应</span></span><br><span class="line">    res.end(<span class="string">'天干物燥 小心火烛'</span>)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//开启服务</span></span><br><span class="line">server.listen(<span class="string">'3000'</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'服务已经启动了~'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>创建服务器 回调函数中的一些属性和方法</p>
<ul>
<li>属性: req.url  拿到的是请求的路径</li>
<li>方法: res.setHeader(‘Content-Type’, ‘text/plain; charset=utf-8’)  设置响应头中的contenttype为 utf-8 防止乱码</li>
<li>方法: res.write()  可以用来给客户端发送响应数据</li>
<li>方法: res.end()<ul>
<li>不传参 :告诉客户端，我的话说完了，你可以呈递给用户了</li>
<li>传参(‘字符串’) : 会将响应结束 并把字符串响应给客户端</li>
</ul>
</li>
<li>属性: req.socket.remoteAddress  用于获取请求的 客户端IP地址</li>
<li>属性: req.socket.remotePort 用于获取请求的 客户端端口号</li>
<li>属性: res.statuscode 设置状态码  301 表示永久重定向 302 表示临时重定向</li>
</ul>
<h4 id="文件系统模块-fs"><a href="#文件系统模块-fs" class="headerlink" title="文件系统模块(fs)"></a>文件系统模块(fs)</h4><p>使用该模块用到的api</p>
<ul>
<li><p>读文件   fs.readFile()</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fs.readFile(<span class="string">'文件名'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//如果出错 直接return 响应体信息</span></span><br><span class="line">    <span class="comment">//res 是创建服务器时的 响应体参数</span></span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> res.end(<span class="string">'出错啦!!!'</span>)</span><br><span class="line">    res.end(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>写文件   fs.writeFile()</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fs.writeFile(<span class="string">'./data/你好.md'</span>, <span class="string">'大家好，给大家介绍一下，我是Node.js'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'写入失败'</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'写入成功了'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>读取文件目录    fs.readdir()</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fs.readdir(<span class="string">'D:/www'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, files</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (err) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'目录不存在'</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">console</span>.log(files)</span><br><span class="line">    <span class="comment">//这个返回的files 是一个数组</span></span><br><span class="line">    <span class="comment">// [ '.idea', '.vscode', '24', 'node_modules', 'package-lock.json' ]</span></span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure>
<h4 id="系统文件-os"><a href="#系统文件-os" class="headerlink" title="系统文件 os"></a>系统文件 os</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> os = <span class="built_in">require</span> (<span class="string">'os'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看当前机器的cpu信息</span></span><br><span class="line"><span class="built_in">console</span>.log(os.cpus())</span><br><span class="line"><span class="comment">// 当前机器的内存</span></span><br><span class="line"><span class="built_in">console</span>.log(os.totalmem())</span><br></pre></td></tr></table></figure>
<p>效果1：<br><img src="/images/node/node1.png" alt="图一"><br>效果2;<br><img src="/images/node/node2.png" alt="图一"></p>
<h2 id="四、Commonjs模块规范"><a href="#四、Commonjs模块规范" class="headerlink" title="四、Commonjs模块规范"></a>四、Commonjs模块规范</h2><blockquote>
<p>在node 中的javascript还有一个很重要的盖南：模块系统</p>
</blockquote>
<h3 id="模块作用域"><a href="#模块作用域" class="headerlink" title="模块作用域"></a>模块作用域</h3><h3 id="使用-require-方法加载模块"><a href="#使用-require-方法加载模块" class="headerlink" title="使用 require 方法加载模块"></a>使用 require 方法加载模块</h3><blockquote>
<p>更多细节：《深入浅出node.js》中模块机制</p>
</blockquote>
<ul>
<li>优先缓存加载<ul>
<li>nodejs模块加载和js script标签加载一样，都是优先从缓存加载，而且如果一个模块被多次引用，只加载一次.</li>
</ul>
</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">main.js</span><br><span class="line"><span class="function"><span class="title">require</span><span class="params">(<span class="string">'a.js'</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">require</span><span class="params">(<span class="string">'b.js'</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span>.js</span><br><span class="line">console.log(<span class="string">'a模块加载'</span>)</span><br><span class="line"><span class="function"><span class="title">require</span><span class="params">(<span class="string">'b.js'</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">b</span>.js</span><br><span class="line">console.log(<span class="string">'b模块加载'</span>)</span><br><span class="line">此时运行结果是</span><br><span class="line"></span><br><span class="line">a模块加载</span><br><span class="line">b模块加载</span><br></pre></td></tr></table></figure>
<ul>
<li>核心模块 – 模块名<ul>
<li>核心模块本质也是文件</li>
<li>require(‘fs’)</li>
</ul>
</li>
<li>自定义模块 – 路径<ul>
<li>./ 当前目录，不可省略</li>
<li>../上一级目录，不可省略</li>
<li>/xx  /表示当前文件所属磁盘根目录，绝对路径一般不用</li>
<li>.js  后缀名可省略 </li>
</ul>
</li>
<li>第三方模块 –模块名<ul>
<li>必须通过 npm 下载</li>
<li>必须通过 require(‘xx’)加载后，才可以使用</li>
<li>不可能有三方包的名字跟核心模块一样</li>
<li>既不是核心模块，也不是路径形式的模块 </li>
<li>加载路径node_modules/xxx/package.json中main属性，根据main的值判断入口文件时谁</li>
<li>如果package.json或者main指定文件不存在 默认使用index.js文件</li>
<li>如果上述条件不成立，则会向上以及找，直到当前磁盘根目录，如果还没有就会报错 can not find module xxx</li>
</ul>
</li>
</ul>
<h3 id="使用-exports-接口对象用来导出模块中的成员"><a href="#使用-exports-接口对象用来导出模块中的成员" class="headerlink" title="使用 exports 接口对象用来导出模块中的成员"></a>使用 exports 接口对象用来导出模块中的成员</h3><ul>
<li>第一种 exports导出方式</li>
</ul>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">exports.a =<span class="number">123</span></span><br><span class="line">exports.b =<span class="string">'hello'</span></span><br><span class="line">exports.c =<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'world'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>第二种导出方式 <br></p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">module.exports = <span class="string">'hello'</span>;</span><br><span class="line"><span class="comment">// 写在后面的会覆盖前者</span></span><br><span class="line">module.exports = <span class="function"><span class="keyword">function</span><span class="params">(x,y)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x+y</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 导出多个对象</span></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  a:<span class="string">'hello'</span>,</span><br><span class="line">  b:<span class="number">123</span>,</span><br><span class="line">  add:<span class="function"><span class="keyword">function</span><span class="params">(<span class="rest_arg">...args</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> args.reduce(<span class="function"><span class="keyword">function</span><span class="params">(pre,val)</span></span>&#123;<span class="keyword">return</span> per+val &#125;,<span class="number">0</span>);  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>其实这两者只是写法不同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">exports</span> = <span class="keyword">module</span>.<span class="keyword">exports</span> = &#123;&#125;</span><br><span class="line"><span class="keyword">exports</span> 是 <span class="keyword">module</span>.eports 的引用，效果一样</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="包说明文件"><a href="#包说明文件" class="headerlink" title="包说明文件"></a>包说明文件</h3><ul>
<li>npm 包管理工具<ul>
<li>npm 是一个命令行工具</li>
<li>也有版本概念</li>
</ul>
</li>
</ul>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span> 升级<span class="built_in">npm</span>自己</span><br><span class="line">  <span class="built_in">npm</span> install --<span class="built_in">global</span> <span class="built_in">npm</span></span><br></pre></td></tr></table></figure>
<ul>
<li>常用命令<ul>
<li>npm init </li>
<li>npm init -y<ul>
<li>跳过引导，快速生成</li>
</ul>
</li>
<li>npm install<ul>
<li>一次行吧dependencies 选项中的以拦全部安装</li>
</ul>
</li>
<li>npm install 包名<ul>
<li>只下载</li>
</ul>
</li>
<li>npm install –save 包名<ul>
<li>下载并保存依赖项（package.json 中的 dependencies）</li>
<li>npm i -S 包名</li>
</ul>
</li>
<li>npm uninstall 包名<ul>
<li>只删除包，不删除依赖</li>
<li>npm un 包名</li>
</ul>
</li>
<li>npm uninstall –save 包名<ul>
<li>删除包的同时删除依赖</li>
<li>npm un -S 包名</li>
</ul>
</li>
<li>npm help<ul>
<li>查看使用帮助</li>
</ul>
</li>
<li>npm 命令 –help<ul>
<li>查看具体命令使用</li>
</ul>
</li>
</ul>
</li>
<li>解决 npm 被墙问题<ul>
<li>npm 存储包文件的服务器时在国外。有时候会被墙，速度很慢</li>
<li><a href="http://npm.taobao.org/" target="_blank" rel="noopener">http://npm.taobao.org/</a> 淘宝团队在国内做了一个备份</li>
<li>安装淘宝的 cnpm</li>
</ul>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在任意目录执行都可以</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --global 表示安装到全局，而非当前目录，兵器不可省略，省略不管用</span></span><br><span class="line">npm install --global cnpm</span><br></pre></td></tr></table></figure>
<ul>
<li>不想安装cnpm，又想使用淘宝的服务来下载</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install jquery --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
<ul>
<li><p>每次都写麻烦 ，可以把这个选项加入配置文件 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org</span><br><span class="line"><span class="meta">#</span><span class="bash"> 验证配置成功</span></span><br><span class="line">npm config list</span><br></pre></td></tr></table></figure>
</li>
<li><p>package.json</p>
<ul>
<li>描述文件，像说明书一样</li>
<li>使用 npm init 可以初始化出来</li>
<li>npm i xx –save  添加依赖在 package.json中</li>
</ul>
</li>
</ul>
<h2 id="五、Express"><a href="#五、Express" class="headerlink" title="五、Express"></a>五、Express</h2><blockquote>
<p>官网地址：<a href="http://expressjs.com/" target="_blank" rel="noopener">http://expressjs.com/</a></p>
</blockquote>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install --save express</span><br></pre></td></tr></table></figure>
<h3 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 创建应用程序，也就是原来的http</span></span><br><span class="line"><span class="keyword">var</span> app = express()</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    res.send(<span class="string">'hello express'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于server.listen</span></span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'app is runing'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="基本路由"><a href="#基本路由" class="headerlink" title="基本路由"></a>基本路由</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// get:</span></span><br><span class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    res.send(<span class="string">'hello express'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// post:</span></span><br><span class="line">app.post(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    res.send(<span class="string">'hello express'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="静态服务"><a href="#静态服务" class="headerlink" title="静态服务"></a>静态服务</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 静态服务 访问 public 下的login.html</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问地址：localhost:3000/login.html</span></span><br><span class="line">app.use(express.static(<span class="string">'public'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问地址：localhost:3000/public/login.html</span></span><br><span class="line">app.use(<span class="string">'/public'</span>, express.static(<span class="string">'public'</span>))</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">'/public'</span>, express.static(path.join(__dirname, <span class="string">'public'</span>)))</span><br></pre></td></tr></table></figure>
<h3 id="nodemon自动重启"><a href="#nodemon自动重启" class="headerlink" title="nodemon自动重启"></a>nodemon自动重启</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  <span class="string">`nodemon`</span>是一个第三方工具，解决频繁重启服务器问题</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 安装</span></span><br><span class="line">  npm install -g nodemon</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 验证是否成功</span></span><br><span class="line">  nodemon --version</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 启动服务命令</span></span><br><span class="line">  nodemon app.js</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 安装的时候出现报错</span></span><br><span class="line">  npm WARN checkPermissions Missing write access to /usr/local/lib/node_modules</span><br><span class="line">  npm ERR! code EACCES</span><br><span class="line">  npm ERR! syscall access</span><br><span class="line">  npm ERR! path /usr/local/lib/node_modules</span><br><span class="line">  npm ERR! errno <span class="number">-13</span></span><br><span class="line">  npm ERR! <span class="built_in">Error</span>: EACCES: permission denied, access <span class="string">'/usr/local/lib/node_modules'</span></span><br><span class="line">  npm ERR!  [<span class="built_in">Error</span>: EACCES: permission denied, access <span class="string">'/usr/local/lib/node_modules'</span>] &#123;</span><br><span class="line">  npm ERR!   stack: <span class="string">"Error: EACCES: permission denied, access '/usr/local/lib/node_modules'"</span>,</span><br><span class="line">  npm ERR!   errno: <span class="number">-13</span>,</span><br><span class="line">  npm ERR!   code: <span class="string">'EACCES'</span>,</span><br><span class="line">  npm ERR!   syscall: <span class="string">'access'</span>,</span><br><span class="line">  npm ERR!   path: <span class="string">'/usr/local/lib/node_modules'</span></span><br><span class="line">  npm ERR! &#125;</span><br><span class="line">  npm ERR! </span><br><span class="line">  npm ERR! The operation was rejected by your operating system.</span><br><span class="line">  npm ERR! It is likely you <span class="keyword">do</span> not have the permissions to access <span class="keyword">this</span> file <span class="keyword">as</span> the current user</span><br><span class="line">  npm ERR! </span><br><span class="line">  npm ERR! If you believe <span class="keyword">this</span> might be a permissions issue, please double-check the</span><br><span class="line">  npm ERR! permissions <span class="keyword">of</span> the file and its containing directories, or <span class="keyword">try</span> running</span><br><span class="line">  npm ERR! the command again <span class="keyword">as</span> root/Administrator.</span><br><span class="line"></span><br><span class="line">  npm ERR! A complete log <span class="keyword">of</span> <span class="keyword">this</span> run can be found <span class="keyword">in</span>:</span><br><span class="line">  npm ERR!     <span class="regexp">/Users/m</span>ac/.npm/_logs/<span class="number">2020</span><span class="number">-05</span><span class="number">-06</span>T07_37_44_847Z-debug.log</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 上面现实没有权限修改node_modules，mac的话在命令行开头加上sudo就可以了</span></span><br><span class="line">  sudo npm install -g nodemon</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在页面ctrl+s就会自动重启</span></span><br></pre></td></tr></table></figure>
<h3 id="在express中使用art-template"><a href="#在express中使用art-template" class="headerlink" title="在express中使用art-template"></a>在express中使用art-template</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 安装</span></span><br><span class="line">npm install --save art-template express-art-template</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 配置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用模板引擎, 参数1：渲染.art结尾的文件的时候使用art-tmplate模板引擎，express-art-template是用来把art-template整合到express中的</span></span><br><span class="line"><span class="comment">// express为response响应提供一个render方法，默认不可以使用，但是配置了模板引擎就可以使用了</span></span><br><span class="line"></span><br><span class="line">app.engine(<span class="string">'art'</span>, <span class="built_in">require</span>(<span class="string">'express-art-template'</span>))  </span><br><span class="line"><span class="comment">// or</span></span><br><span class="line">app.engine(<span class="string">'html'</span>, <span class="built_in">require</span>(<span class="string">'express-art-template'</span>))</span><br></pre></td></tr></table></figure>
<p>文件结构：<img src="/images/node/node3.png" alt="image.png"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="comment">// render方法的参数1，文件路径，默认是views中找文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.默认使用views</span></span><br><span class="line">app.get(<span class="string">'/template'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.render(<span class="string">'404.html'</span>, &#123;</span><br><span class="line">    user: <span class="string">'art'</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 渲染views下的admin下的index  路径默认是views为跟目录</span></span><br><span class="line">app.get(<span class="string">'/admin'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.render(<span class="string">'admin/index.html'</span>, &#123;</span><br><span class="line">    title: <span class="string">'管理系统'</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.更改默认路径为src</span></span><br><span class="line">app.set(<span class="string">'views'</span>, <span class="string">'./src'</span>) <span class="comment">// 更改默认路径views为src</span></span><br><span class="line">app.get(<span class="string">'/update'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.render(<span class="string">'update.html'</span>, &#123;</span><br><span class="line">    src: <span class="string">'src'</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="效果图1：-默认路径-http-localhost-3000-template"><a href="#效果图1：-默认路径-http-localhost-3000-template" class="headerlink" title="效果图1：  默认路径 http://localhost:3000/template"></a>效果图1：  默认路径 <a href="http://localhost:3000/template" target="_blank" rel="noopener">http://localhost:3000/template</a></h4><p><img src="/images/node/node4.png" alt="image.png"></p>
<h4 id="效果图2：-默认路径-http-localhost-3000-admin"><a href="#效果图2：-默认路径-http-localhost-3000-admin" class="headerlink" title="效果图2：  默认路径 http://localhost:3000/admin"></a>效果图2：  默认路径 <a href="http://localhost:3000/admin" target="_blank" rel="noopener">http://localhost:3000/admin</a></h4><p><img src="/images/node/node5.png" alt="image.png"></p>
<h4 id="效果图3：-修改默认路径为src路径-http-localhost-3000-update"><a href="#效果图3：-修改默认路径为src路径-http-localhost-3000-update" class="headerlink" title="效果图3：  修改默认路径为src路径 http://localhost:3000/update"></a>效果图3：  修改默认路径为src路径 <a href="http://localhost:3000/update" target="_blank" rel="noopener">http://localhost:3000/update</a></h4><p><img src="/images/node/node6.png" alt="image.png"></p>
<h3 id="express中get、post请求"><a href="#express中get、post请求" class="headerlink" title="express中get、post请求"></a>express中get、post请求</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// get获取参数 : req.query</span></span><br><span class="line">app.get(<span class="string">'/post'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(req.query) </span><br><span class="line">  res.render(<span class="string">'post.html'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// post获取参数 : req.body</span></span><br><span class="line"><span class="comment">// 需要使用三方插件body-parser</span></span><br><span class="line"><span class="comment">// 安装 npm install body-parser</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用</span></span><br><span class="line"><span class="keyword">var</span> bodyParser = <span class="built_in">require</span>(<span class="string">'body-parser'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置</span></span><br><span class="line"><span class="comment">// parse application/x-www-form-urlencoded</span></span><br><span class="line">app.use(bodyParser.urlencoded(&#123; <span class="attr">extended</span>: <span class="literal">false</span> &#125;))</span><br><span class="line"></span><br><span class="line"><span class="comment">// parse application/json</span></span><br><span class="line">app.use(bodyParser.json())</span><br><span class="line"></span><br><span class="line">app.post(<span class="string">'/post'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(req.body)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>珠峰 this指向</title>
    <url>/2021/02/24/%E7%8F%A0%E5%B3%B0/this%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="珠峰笔记"><a href="#珠峰笔记" class="headerlink" title="珠峰笔记"></a>珠峰笔记</h1><h2 id="一、this情况"><a href="#一、this情况" class="headerlink" title="一、this情况"></a>一、this情况</h2><h3 id="1-1-全局上下文中"><a href="#1-1-全局上下文中" class="headerlink" title="1.1 全局上下文中"></a>1.1 全局上下文中</h3><p>全局上下文中 this 指的是 window</p>
<h3 id="1-2-块级作用域"><a href="#1-2-块级作用域" class="headerlink" title="1.2 块级作用域"></a>1.2 块级作用域</h3><p>块级作用域中是没有this的，他的this是继承来的.<br><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> </span>()&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">let</span> a = <span class="string">"hjj"</span></span><br><span class="line">            console.log(this) <span class="comment">// &#123; fn: [Function: fn] &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj<span class="function">.<span class="keyword">fn</span></span>()</span><br></pre></td></tr></table></figure></p>
<h3 id="1-3-函数中的this"><a href="#1-3-函数中的this" class="headerlink" title="1.3 函数中的this"></a>1.3 函数中的this</h3><p>小明在天街吃早饭。  事情本体是吃早餐，小明是这件事情的主体【this】，在天街这个环境中，天街是这件事情发生的上下文【执行上下文(EC)】</p>
<h4 id="1-3-1-事件绑定-–-this"><a href="#1-3-1-事件绑定-–-this" class="headerlink" title="1.3.1 事件绑定 – this"></a>1.3.1 事件绑定 – this</h4><blockquote>
<p>事件绑定中的this指向，事件绑定元素，事件触发，方法执行，此时的this指向当前元素，但是在IE6-8中的dom2事件attachEvent中this指向window</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">//index.html</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        *&#123;</span><br><span class="line">            margin: 0;</span><br><span class="line">        &#125;</span><br><span class="line">        body&#123;</span><br><span class="line">            width: 500px;</span><br><span class="line">            height: 500px;</span><br><span class="line">            background-color: aquamarine;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"demo.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// demo.js</span><br><span class="line">let body = document.body</span><br><span class="line">body.onclick = function () &#123;</span><br><span class="line">    console.log(this) // 见下图</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">body.addEventListener("click", function()&#123;</span><br><span class="line">    console.log(this) // 见下图</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">body.attachEvent('onclick', function() &#123;</span><br><span class="line">    console.log(this) // window</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/478608/1599133339712-3bb4e7b5-60ef-4bb2-a08a-c0d22a27a201.png#align=left&amp;display=inline&amp;height=67&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=134&amp;originWidth=568&amp;size=11642&amp;status=done&amp;style=none&amp;width=284" alt="image.png"></p>
<h4 id="1-3-2-普通事件-–-this"><a href="#1-3-2-普通事件-–-this" class="headerlink" title="1.3.2 普通事件 – this"></a>1.3.2 普通事件 – this</h4><p><code>this</code> 的普通方法执行（包含自执行函数的执行，普通函数执行，对象成员访问方法调用执行等）<br>只需要看函数执行的时候前边有没有“点”，有点，点前边是谁， <code>this</code> 就是谁，没有点就是 <code>window</code> 【非严格模式】或者 <code>undefined</code> 【严格模式】</p>
<ul>
<li><p>函数自调用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非严格模式</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">// window</span></span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用严格模式</span></span><br><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">// undefined</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
</li>
<li><p>普通函数执行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">// window</span></span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>
</li>
<li><p>对象成员访问</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span>: function <span class="title">fn</span><span class="params">()</span></span>&#123;</span><br><span class="line">        console.log(<span class="keyword">this</span>) <span class="comment">// obj</span></span><br><span class="line">        console.log(<span class="keyword">this</span> == obj) <span class="comment">// true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    fun1: (function fn()&#123;</span><br><span class="line">        console.log(<span class="keyword">this</span>) <span class="comment">// window</span></span><br><span class="line">    &#125;)()</span><br><span class="line">&#125;</span><br><span class="line">obj<span class="function">.<span class="title">fun</span><span class="params">()</span></span></span><br><span class="line">obj.fun1</span><br></pre></td></tr></table></figure>
</li>
<li><p>例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[].slice() <span class="comment">// 基于原型链机制，先找的是[]原型上的slice方法，然后在执行。此时的this指的是当前的空数组（点前边是谁就是谁）</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.slice() <span class="comment">// this指的是Array.prototype</span></span><br><span class="line">[].__proto__.slice() <span class="comment">// this指的是[].__proto__</span></span><br><span class="line"><span class="built_in">console</span>.log([].__proto__ == <span class="built_in">Array</span>.prototype) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">// window</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.body.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">// body</span></span><br><span class="line">    foo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="1-3-3-构造函数-–-this"><a href="#1-3-3-构造函数-–-this" class="headerlink" title="1.3.3 构造函数 – this"></a>1.3.3 构造函数 – this</h4><blockquote>
<p>构造函数体中的 <code>this</code>  指的是当前类的实例，构造函数原型上的 <code>this</code> 不一定是当前实例，要看前边是否有“点”，点前边是什么 <code>this</code> 就指的是什么</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fun</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"hjj"</span> <span class="comment">// 这是给当前实例设置私有属性</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">// 当前实例，f</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Fun.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> Fun;</span><br><span class="line"></span><br><span class="line">f.getName(); <span class="comment">// this -&gt;  f</span></span><br><span class="line">Fun.prototype.getName() <span class="comment">//  this -&gt; Fun.prototype</span></span><br><span class="line">f.__proto__.getName() <span class="comment">//  this -&gt; f.__proto__</span></span><br></pre></td></tr></table></figure>
<h4 id="1-3-4-箭头函数-–-this"><a href="#1-3-4-箭头函数-–-this" class="headerlink" title="1.3.4 箭头函数 – this"></a>1.3.4 箭头函数 – this</h4><blockquote>
<p>箭头函数没有自己的 <code>this</code> ，他的 <code>this</code> 是继承所在上下文的 <code>this</code> </p>
</blockquote>
<ol>
<li>普通函数执行：</li>
</ol>
<p>形成私有上下文跟AO – 初始化作用域链 – 初始化this – 初始化 <code>arguments</code>  – 形参赋值 – 变量提升 – 代码执行</p>
<ol start="2">
<li>箭头函数执行:</li>
</ol>
<p>形成私有上下文跟AO – 初始化作用域链 – 形参赋值 – 变量提升 – 代码执行<br>执行过程中遇 <code>this</code> ，就直接照上级上下文中的 <code>this</code> </p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span> let obj = &#123;</span><br><span class="line"><span class="regexp">//</span>     f1()&#123;</span><br><span class="line"><span class="regexp">//</span>         console.log(this)</span><br><span class="line"><span class="regexp">//</span>     &#125;,</span><br><span class="line"><span class="regexp">//</span>     f2:() =&gt; &#123;</span><br><span class="line"><span class="regexp">//</span>         console.log(this)</span><br><span class="line"><span class="regexp">//</span>     &#125;</span><br><span class="line"><span class="regexp">//</span> &#125;</span><br><span class="line"><span class="regexp">//</span> obj.f1(); <span class="regexp">//</span> obj</span><br><span class="line"><span class="regexp">//</span> obj.f2(); <span class="regexp">//</span> window</span><br><span class="line"><span class="regexp">//</span> obj.f2.call(obj) <span class="regexp">//</span> window,箭头函数是没有this的，强制更改也没有用</span><br></pre></td></tr></table></figure>
<p>实例<br><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="string">//</span> let obj = &#123;</span><br><span class="line"><span class="string">//</span>     i: 0,</span><br><span class="line"><span class="string">//</span>     fun<span class="params">()</span>&#123;</span><br><span class="line"><span class="string">//</span>         console.log<span class="params">(this)</span> <span class="string">//</span> obj</span><br><span class="line"><span class="string">//</span>         <span class="keyword">set</span>Timeout<span class="params">(function()</span>&#123; <span class="string">//</span> 回调函数中的this一般都是window，特殊情况除外<span class="params">(强制改变)</span></span><br><span class="line"><span class="string">//</span>             this.i ++;</span><br><span class="line"><span class="string">//</span>             console.log<span class="params">(obj.i)</span> <span class="string">//</span> 0</span><br><span class="line"><span class="string">//</span>             console.log<span class="params">(this)</span> <span class="string">//</span> window</span><br><span class="line"><span class="string">//</span>         &#125;, 1000)</span><br><span class="line"><span class="string">//</span>     &#125; </span><br><span class="line"><span class="string">//</span> &#125;</span><br><span class="line"><span class="string">//</span> obj.fun<span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="string">//</span> let obj = &#123;</span><br><span class="line"><span class="string">//</span>     i: 0,</span><br><span class="line"><span class="string">//</span>     fun<span class="params">()</span>&#123;</span><br><span class="line"><span class="string">//</span>         let _this = this</span><br><span class="line"><span class="string">//</span>         <span class="keyword">set</span>Timeout<span class="params">(function()</span>&#123;</span><br><span class="line"><span class="string">//</span>             _this.i ++;</span><br><span class="line"><span class="string">//</span>             console.log<span class="params">(obj.i)</span> <span class="string">//</span> 1</span><br><span class="line"><span class="string">//</span>             console.log<span class="params">(this)</span> <span class="string">//</span> window</span><br><span class="line"><span class="string">//</span>         &#125;, 1000)</span><br><span class="line"><span class="string">//</span>     &#125; </span><br><span class="line"><span class="string">//</span> &#125;</span><br><span class="line"><span class="string">//</span> obj.fun<span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="string">//</span> let obj = &#123;</span><br><span class="line"><span class="string">//</span>     i: 0,</span><br><span class="line"><span class="string">//</span>     fun<span class="params">()</span>&#123;</span><br><span class="line"><span class="string">//</span>         <span class="keyword">set</span>Timeout<span class="params">(function()</span>&#123;</span><br><span class="line"><span class="string">//</span>             this.i ++;</span><br><span class="line"><span class="string">//</span>             console.log<span class="params">(obj.i)</span> <span class="string">//</span> 1</span><br><span class="line"><span class="string">//</span>             console.log<span class="params">(this)</span> <span class="string">//</span> obj</span><br><span class="line"><span class="string">//</span>         &#125;<span class="string">.bind</span><span class="params">(this)</span>, 1000)</span><br><span class="line"><span class="string">//</span>     &#125; </span><br><span class="line"><span class="string">//</span> &#125;</span><br><span class="line"><span class="string">//</span> obj.fun<span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="string">//</span> let obj = &#123;</span><br><span class="line"><span class="string">//</span>     i: 0,</span><br><span class="line"><span class="string">//</span>     fun<span class="params">()</span>&#123;</span><br><span class="line"><span class="string">//</span>         <span class="keyword">set</span>Timeout<span class="params">(()</span> =&gt; &#123;</span><br><span class="line"><span class="string">//</span>             <span class="string">//</span> 箭头函数中没有this，他的this是上下文中的this，即obj</span><br><span class="line"><span class="string">//</span>             this.i ++;</span><br><span class="line"><span class="string">//</span>             console.log<span class="params">(obj.i)</span> <span class="string">//</span> 1</span><br><span class="line"><span class="string">//</span>             console.log<span class="params">(this)</span> <span class="string">//</span> obj</span><br><span class="line"><span class="string">//</span>         &#125;, 1000)</span><br><span class="line"><span class="string">//</span>     &#125; </span><br><span class="line"><span class="string">//</span> &#125;</span><br><span class="line"><span class="string">//</span> obj.fun<span class="params">()</span></span><br></pre></td></tr></table></figure></p>
<h4 id="1-3-5-call、apply、bind-–-强制手动更改this"><a href="#1-3-5-call、apply、bind-–-强制手动更改this" class="headerlink" title="1.3.5 call、apply、bind – 强制手动更改this"></a>1.3.5 call、apply、bind – 强制手动更改this</h4><blockquote>
<p>基于call、apply、bind三种方法，可以强制手动更改this指向</p>
</blockquote>
<ul>
<li>call</li>
</ul>
<p><code>[function].call( [context] , params1 , params2 , ...)</code> , <code>[function]</code>作为<code>[Function]</code>的内置类的实例，可以基于 <code>__proto__</code> 找到 <code>Function.prototype</code>的 <code>call</code> 方法，并把 <code>call</code> 方法执行，在执行 <code>call</code> 方法的同时把<code>[function]</code>执行，并把函数中的 <code>this</code> 指向 <code>[context]</code> ,并且把 <code>params1</code> 这些参数值传递给函数<br>call 的第一个参数不传或者传的是null 、undefined的时候，在非严格模式下this指的是window，在严格模式下，传的是什么就是什么，没有传就是undefined<br></p>
<ul>
<li>apply</li>
</ul>
<p><code>[function].call( [context] , [params1 , params2 , ...])</code> 和 <code>call</code> 的作用一样，唯一不同的是参数传递方式不一样， <code>apply</code> 这个参数的形式是数组形式的<br></p>
<ul>
<li>bind  <code>[function].call( [context] , params1 , params2 , ...)</code></li>
</ul>
<p><code>call、apply</code>是立即执行，摒弃改变函数的this的指向，而bind 是预处理的思想，把函数的this预处理成[context],把参数预先存储起来，但此时函数并没有执行。</p>
<h4 id="1-3-6-总结"><a href="#1-3-6-总结" class="headerlink" title="1.3.6 总结"></a>1.3.6 总结</h4><ul>
<li>一般按照事件绑定、普通事件、构造函数判断就可以了， 但是一旦前三种遇到 <code>call、apply、bind</code> 这三种都按照 <code>call、apply、bind</code>的 <code>this</code> 执行，箭头函数除外，箭头函数强制更改不起作用。</li>
<li>习题  // 22 23  65 30</li>
</ul>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> <span class="built_in">num</span> = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">let</span> obj = &#123;</span><br><span class="line">    <span class="built_in">num</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line">obj.fn = (function(<span class="built_in">num</span>)&#123;</span><br><span class="line">    this.<span class="built_in">num</span> = <span class="built_in">num</span> * <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">num</span> ++;</span><br><span class="line">    <span class="built_in">return</span> function(n) &#123;</span><br><span class="line">        this.<span class="built_in">num</span> += n;</span><br><span class="line">        <span class="built_in">num</span> ++;</span><br><span class="line">        console.<span class="built_in">log</span>(<span class="built_in">num</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(obj.<span class="built_in">num</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">var</span> fn = obj.fn;</span><br><span class="line">fn(<span class="number">5</span>)</span><br><span class="line">obj.fn(<span class="number">10</span>)</span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">num</span>, onj.<span class="built_in">num</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>珠峰</category>
      </categories>
      <tags>
        <tag>珠峰</tag>
      </tags>
  </entry>
  <entry>
    <title>珠峰 vue-源码</title>
    <url>/2021/02/24/%E7%8F%A0%E5%B3%B0/vue-%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<h1 id="vue-（源码）"><a href="#vue-（源码）" class="headerlink" title="vue-（源码）"></a>vue-（源码）</h1><h1 id="一、响应式原理"><a href="#一、响应式原理" class="headerlink" title="一、响应式原理"></a>一、响应式原理</h1><p>响应式数据：数据变化让视图更新<br>原理：</p>
<ul>
<li>对象类型使用 <code>object.defineproperty</code> 将属性进行劫持（只劫持已存在的属性），多层对象递归来实现，<code>object.defineproperty</code>是对每个属性都进行添加 <code>get、set</code> 属性。</li>
<li>数组对象则是通过重写数组方法实现</li>
<li>内部收集是怎样的？每个属性都有自己的 <code>dep</code> ,收集自己对于的 <code>watcher</code> ，当属性变化后，会通知对应的 <code>watcher</code> 去更新</li>
<li><code>object.definepropert</code> 性能差、不需要响应的数据不要放在 <code>data</code> 中、 <code>object.freeze()</code> 可以冻结数据，冻结后的数据不能使用<code>object.defineproperty</code>进行重写。<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 定义数据</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> state = &#123;<span class="attr">count</span>: <span class="number">0</span>&#125;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> active;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 把数据obj变成响应式</span></span></span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span> <span class="title">defineReative</span><span class="params">(obj)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> obj)&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">let</span> value = obj[key] <span class="comment">// 原来的值</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">let</span> dep = [] <span class="comment">// 用来收集当前属性的watcher,方便后续通知</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">get</span>()&#123;</span></span><br><span class="line">                        if (active) &#123;</span><br><span class="line"><span class="actionscript">                            dep.push(active) <span class="comment">// 记录每一次watcher，收集依赖</span></span></span><br><span class="line">                        &#125;</span><br><span class="line"><span class="actionscript">                        <span class="keyword">return</span> value</span></span><br><span class="line">                    &#125;,</span><br><span class="line"><span class="javascript">                    <span class="keyword">set</span>(newValue) &#123; <span class="comment">// 触发更新</span></span></span><br><span class="line"><span class="actionscript">                        value = newValue <span class="comment">// 属性改变的时候，设置新值</span></span></span><br><span class="line"><span class="javascript">                        dep.forEach(<span class="function"><span class="params">watcher</span> =&gt;</span> watcher()) <span class="comment">// 属性改变，通知对应的watcher</span></span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        defineReative(state)</span><br><span class="line"><span class="actionscript">        <span class="comment">// 监听方法封装</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> watcher = <span class="function">(<span class="params">fn</span>) =&gt;</span> &#123;</span></span><br><span class="line">            active = fn</span><br><span class="line">            fn()</span><br><span class="line"><span class="actionscript">            active = <span class="literal">null</span> <span class="comment">// 后续不在watcher中取值，不出发收集依赖</span></span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        <span class="comment">// 数据变化更新视图</span></span></span><br><span class="line"><span class="javascript">        watcher(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="actionscript">            app.innerHTML = state.count <span class="comment">// 取值</span></span></span><br><span class="line">        &#125;)</span><br><span class="line"><span class="javascript">        watcher(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(state.count)</span></span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="二、监测数组更新"><a href="#二、监测数组更新" class="headerlink" title="二、监测数组更新"></a>二、监测数组更新</h1><ul>
<li>对数组的方法进行重写（push, unshift, pop, shift, splice, sort, reserve），使用<code>object.defineproperty</code>的话，数组项太多的话，遍历不好</li>
<li>在vue中修改数组的长度，索引是无法watcher到的，需要使用以上七种方法才能watcher到变化进行响应的更新。数组中如果是对象的话，也会进行递归劫持的。</li>
<li>如果在vue中，修改索引要更新数据，使用Vue.$set()来更新，核心是spilce方法<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> state = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> originArray = <span class="built_in">Array</span>.prototype <span class="comment">// 数组的原始方法</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> arrayMethods = <span class="built_in">Object</span>.create(originArray) <span class="comment">// 拷贝一份新的方法</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="comment">// 数据响应化</span></span></span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span> <span class="title">defineReative</span><span class="params">(obj)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 函数劫持</span></span></span><br><span class="line"><span class="actionscript">            arrayMethods.push = <span class="function"><span class="keyword">function</span><span class="params">(<span class="rest_arg">...args</span>)</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">                originArray.push.call(<span class="keyword">this</span>, ...args)</span></span><br><span class="line">                render()</span><br><span class="line">            &#125;</span><br><span class="line">            obj.__proto__ = arrayMethods</span><br><span class="line">        &#125;</span><br><span class="line">        defineReative(state)</span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span> <span class="title">render</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line">            app.innerHTML = state</span><br><span class="line">        &#125;</span><br><span class="line">        render()</span><br><span class="line">        </span><br><span class="line"><span class="javascript">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span></span><br><span class="line">            state.push(4)</span><br><span class="line">        &#125;,2000)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="三、模板编译原理"><a href="#三、模板编译原理" class="headerlink" title="三、模板编译原理"></a>三、模板编译原理</h1><blockquote>
<p>模板编译原理就是问template怎么编译成render函数的</p>
</blockquote>
<ul>
<li>模板就是经常用的template，模板比那一成render函数时会有新能损耗，同时引用带有complier的包的vue体积会变大</li>
<li>默认.vue文件中的template是通过vue-loader来处理的，并不是通过运行时的编译</li>
<li>vue执行：模板 -》render函数 -》 产生虚拟节点 - 》真实dom</li>
<li>模板引擎实现原理：new Function + with 来实现的</li>
<li>使用正则把模板变成AST语法树<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用vue-loader的核心包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"node_modules/vue-template-compiler/browser.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// template -- ast -- codegen</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> &#123;ast, render&#125; = VueTemplateCompiler.compile(<span class="string">"&lt;div&gt;hjj&lt;/div&gt;"</span>)</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 真正的render函数</span></span></span><br><span class="line"><span class="actionscript">        <span class="comment">// with + new Function</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Function</span>(render).toString())</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="1-ast语法树结构"><a href="#1-ast语法树结构" class="headerlink" title="1. ast语法树结构"></a>1. ast语法树结构</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/478608/1609396775463-34fa00a1-a36e-4a94-ae09-6bb80a43d301.png#align=left&amp;display=inline&amp;height=345&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=690&amp;originWidth=1290&amp;size=98853&amp;status=done&amp;style=none&amp;width=645" alt="image.png"></p>
<h2 id="2-render函数"><a href="#2-render函数" class="headerlink" title="2. render函数"></a>2. render函数</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/478608/1609396866502-9dfcaedc-ac28-4a3c-88d7-812395e5c27e.png#align=left&amp;display=inline&amp;height=78&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=156&amp;originWidth=1334&amp;size=19302&amp;status=done&amp;style=none&amp;width=667" alt="image.png"></p>
<h2 id="3-new-Function-render-toString"><a href="#3-new-Function-render-toString" class="headerlink" title="3. new Function(render).toString()"></a>3. new Function(render).toString()</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/478608/1609397156110-6bccba53-6059-43ab-9cdd-37e12ae5d675.png#align=left&amp;display=inline&amp;height=120&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=240&amp;originWidth=1334&amp;size=26418&amp;status=done&amp;style=none&amp;width=667" alt="image.png"></p>
<h1 id="四、生命周期钩子是如何让实现的"><a href="#四、生命周期钩子是如何让实现的" class="headerlink" title="四、生命周期钩子是如何让实现的"></a>四、生命周期钩子是如何让实现的</h1><ul>
<li>生命周期就是一个回调函数</li>
<li>生命周期在内部会转换成数组， 在需要的时候遍历数组，依次执行<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>生命周期钩子<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 合并钩子方法  parent第一次是undefined  child是function</span></span></span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span> <span class="title">mergeHooks</span><span class="params">(parent, child)</span> </span>&#123;</span></span><br><span class="line">            if (child) &#123;</span><br><span class="line">                if (parent) &#123;</span><br><span class="line"><span class="actionscript">                    <span class="keyword">return</span> parent.concat(child) <span class="comment">// 父亲儿子都有值，合并</span></span></span><br><span class="line"><span class="actionscript">                &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="actionscript">                    <span class="keyword">return</span> [child] <span class="comment">// 将钩子处理成数组</span></span></span><br><span class="line">                &#125;</span><br><span class="line"><span class="actionscript">            &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">return</span> parent <span class="comment">// 儿子没值，以父亲为准</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"><span class="actionscript">        <span class="comment">// 合并钩子</span></span></span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span> <span class="title">mergeOptions</span><span class="params">(parent, child)</span></span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> opts = &#123;&#125;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> child)&#123;</span></span><br><span class="line">                opts[key] = mergeHooks(parent[key], child[key])</span><br><span class="line">            &#125;</span><br><span class="line"><span class="actionscript">            <span class="keyword">return</span> opts</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        <span class="comment">// 执行 vm当前实例，hookName钩子名称</span></span></span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span> <span class="title">callHook</span><span class="params">(vm, hookName)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// vm.options[hookName]是个数组，万一父亲儿子都没有遍历会出错，所以使用&amp;&amp;</span></span></span><br><span class="line"><span class="javascript">            vm.options[hookName] &amp;&amp; vm.options[hookName].forEach(<span class="function"><span class="params">h</span> =&gt;</span> h());</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        <span class="comment">// 当前实例的options </span></span></span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span> <span class="title">Vue</span><span class="params">(options)</span> </span>&#123; </span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 主要做了一件事 - 合并钩子并且转换为数组</span></span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.options = mergeOptions(<span class="keyword">this</span>.constructor.options, options) <span class="comment">// this.constructor.options默认的   options：传入的</span></span></span><br><span class="line">            </span><br><span class="line"><span class="actionscript">            <span class="comment">// 在某个和时刻调用,以beforeCreate、created为例</span></span></span><br><span class="line"><span class="actionscript">            callHook(<span class="keyword">this</span>, <span class="string">"beforeCreate"</span>)</span></span><br><span class="line"><span class="actionscript">            callHook(<span class="keyword">this</span>, <span class="string">"created"</span>)</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        <span class="comment">// 全局组件  全局过滤器</span></span></span><br><span class="line"><span class="actionscript">        Vue.options = &#123;&#125; <span class="comment">// 默认的</span></span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 当前vue实例</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line">            beforeCreate()&#123;</span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"beforeCreate ok"</span>)</span></span><br><span class="line">            &#125;,</span><br><span class="line">            created()&#123;</span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"created"</span>)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="五、mixin"><a href="#五、mixin" class="headerlink" title="五、mixin"></a>五、mixin</h1><blockquote>
<p>主要是抽离公共业务逻辑，初始化组件的时候会使用mergeOptions方法合并，两者冲突时，采用就近原则，以组件的为准</p>
</blockquote>
<p>mixin的数据不共享</p>
<h1 id="六、nextTick"><a href="#六、nextTick" class="headerlink" title="六、nextTick"></a>六、nextTick</h1><p>把多次跟新视图合并成一次，主要是延迟实现的，在nextTickz中可以获取最新的代码</p>
<h1 id="七、生命周期"><a href="#七、生命周期" class="headerlink" title="七、生命周期"></a>七、生命周期</h1><ul>
<li>beforeCreate<ul>
<li>在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。</li>
</ul>
</li>
<li>created<ul>
<li>在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，property 和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，<code>$el</code> property 目前尚不可用。</li>
</ul>
</li>
<li>beforeMount<ul>
<li>在挂载开始之前被调用：相关的 <code>render</code> 函数首次被调用。<br></li>
</ul>
</li>
<li>mounted<ul>
<li>实例被挂载后调用，这时 <code>el</code> 被新创建的 <code>vm.$el</code> 替换了。如果根实例挂载到了一个文档内的元素上，当 <code>mounted</code> 被调用时 <code>vm.$el</code> 也在文档内。</li>
<li>注意 <code>mounted</code> <strong>不会</strong>保证所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以在 <code>mounted</code> 内部使用 <a href="https://cn.vuejs.org/v2/api/#vm-nextTick" target="_blank" rel="noopener">vm.$nextTick</a>：</li>
</ul>
</li>
<li>beforeUpdate<ul>
<li>数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。</li>
</ul>
</li>
<li>updated<ul>
<li>由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。</li>
<li>当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用<a href="https://cn.vuejs.org/v2/api/#computed" target="_blank" rel="noopener">计算属性</a>或 <a href="https://cn.vuejs.org/v2/api/#watch" target="_blank" rel="noopener">watcher</a> 取而代之。</li>
<li>注意 <code>updated</code> <strong>不会</strong>保证所有的子组件也都一起被重绘。如果你希望等到整个视图都重绘完毕，可以在 <code>updated</code> 里使用 <a href="https://cn.vuejs.org/v2/api/#vm-nextTick" target="_blank" rel="noopener">vm.$nextTick</a>：</li>
</ul>
</li>
<li>activated<ul>
<li>被 keep-alive 缓存的组件激活时调用。</li>
</ul>
</li>
<li>deactivated<ul>
<li>被 keep-alive 缓存的组件停用时调用。</li>
</ul>
</li>
<li>beforeDestroy<ul>
<li>实例销毁之前调用。在这一步，实例仍然完全可用。</li>
</ul>
</li>
<li>destroyed<ul>
<li>实例销毁后调用。该钩子被调用后，对应 Vue 实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁。</li>
</ul>
</li>
</ul>
<h1 id="八、父子组件传值的方法"><a href="#八、父子组件传值的方法" class="headerlink" title="八、父子组件传值的方法"></a>八、父子组件传值的方法</h1><ul>
<li>props 、 $emit</li>
<li>$parent   $children</li>
<li>$attrs、$listener : 批量传递数据</li>
<li>provide、inject : 跨级传递数据</li>
<li>$refs</li>
<li>vuex</li>
<li>v-model</li>
<li>eventbtns</li>
<li><a href="https://www.cnblogs.com/barryzhang/p/10566515.html" target="_blank" rel="noopener">https://www.cnblogs.com/barryzhang/p/10566515.html</a></li>
</ul>
<h1 id="九、插槽"><a href="#九、插槽" class="headerlink" title="九、插槽"></a>九、插槽</h1><ul>
<li><p>插槽分为两种</p>
<ul>
<li><p>普通插槽：不给名字的默认插槽 、给名字的具名插槽</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">// 父组件</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    我是父组件</span><br><span class="line">    <span class="tag">&lt;<span class="name">test</span>&gt;</span>默认插槽<span class="tag">&lt;/<span class="name">test</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">test</span> <span class="attr">slot</span>=<span class="string">"big"</span>&gt;</span>具名插槽<span class="tag">&lt;/<span class="name">test</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 子组件test</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    我是子组件</span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"big"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>效果图：</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/478608/1610332498792-9378fe3b-3351-492b-b23e-bad1370af5de.png#align=left&amp;display=inline&amp;height=81&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=81&amp;originWidth=252&amp;size=9079&amp;status=done&amp;style=none&amp;width=252" alt="image.png"></p>
<ul>
<li><p>普通插槽解析流程，父组件先解析，将test作为子组件处理，生成这样的节点</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attribute">tag</span>: <span class="string">'div'</span>,</span><br><span class="line">    children: [&#123;</span><br><span class="line">        tag: <span class="string">'test'</span>,</span><br><span class="line">        children: [<span class="string">'插入slot中'</span>]</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>子组件解析，slot作为一个占位符，会被解析成一个函数</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子组件被解析成这样</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">tag</span>: <span class="string">'main'</span>,</span><br><span class="line">    <span class="attribute">children</span>: [</span><br><span class="line">        <span class="string">'我在子组件里面'</span>,</span><br><span class="line">        <span class="comment">// 不传递插槽的名称默认就是default, 如果传了就是传入的名称</span></span><br><span class="line">        _t(<span class="string">'default'</span>)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>作用域插槽</li>
</ul>
]]></content>
      <categories>
        <category>珠峰</category>
      </categories>
      <tags>
        <tag>珠峰</tag>
      </tags>
  </entry>
  <entry>
    <title>this指向问题2</title>
    <url>/2020/09/24/%E5%89%8D%E7%AB%AF/this/this1/</url>
    <content><![CDATA[<h1 id="this情况"><a href="#this情况" class="headerlink" title="this情况"></a>this情况</h1><h2 id="全局上下文中"><a href="#全局上下文中" class="headerlink" title="全局上下文中"></a>全局上下文中</h2><p>全局上下文中 this 指的是 window</p>
<h2 id="块级作用域中"><a href="#块级作用域中" class="headerlink" title="块级作用域中"></a>块级作用域中</h2><p>块级作用域中是没有this的，他的this是继承来的.<br><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> </span>()&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">let</span> a = <span class="string">"hjj"</span></span><br><span class="line">            console.log(this) <span class="comment">// &#123; fn: [Function: fn] &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj<span class="function">.<span class="keyword">fn</span></span>()</span><br></pre></td></tr></table></figure></p>
<h2 id="函数中的this"><a href="#函数中的this" class="headerlink" title="函数中的this"></a>函数中的this</h2><blockquote>
<p>小明在天街吃早饭。  事情本体是吃早餐，小明是这件事情的主体【this】，在天街这个环境中，天街是这件事情发生的上下文【执行上下文(EC)】</p>
</blockquote>
<h3 id="事件绑定-–-this"><a href="#事件绑定-–-this" class="headerlink" title="事件绑定 – this"></a>事件绑定 – this</h3><blockquote>
<p>事件绑定中的this指向，事件绑定元素，事件触发，方法执行，此时的this指向当前元素，但是在IE6-8中的dom2事件attachEvent中this指向window</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">//index.html</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        *&#123;</span><br><span class="line">            margin: 0;</span><br><span class="line">        &#125;</span><br><span class="line">        body&#123;</span><br><span class="line">            width: 500px;</span><br><span class="line">            height: 500px;</span><br><span class="line">            background-color: aquamarine;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"demo.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// demo.js</span><br><span class="line">let body = document.body</span><br><span class="line">body.onclick = function () &#123;</span><br><span class="line">    console.log(this) // 见下图</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">body.addEventListener("click", function()&#123;</span><br><span class="line">    console.log(this) // 见下图</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">body.attachEvent('onclick', function() &#123;</span><br><span class="line">    console.log(this) // window</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><img src="/images/js/this-image1.png" alt="this-image1"></p>
<h3 id="普通事件-–-this"><a href="#普通事件-–-this" class="headerlink" title="普通事件 – this"></a>普通事件 – this</h3><blockquote>
<p>this 的普通方法执行（包含自执行函数的执行，普通函数执行，对象成员访问方法调用执行等）<br>只需要看函数执行的时候前边有没有“点”，有点，点前边是谁， this 就是谁，没有点就是 window 【非严格模式】或者 undefined 【严格模式】</p>
</blockquote>
<ul>
<li>函数自调用</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非严格模式</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">// window</span></span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用严格模式</span></span><br><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">// undefined</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<ul>
<li>普通函数执行</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非严格模式</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">// window</span></span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用严格模式</span></span><br><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">// undefined</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<ul>
<li>对象成员访问</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span>: function <span class="title">fn</span><span class="params">()</span></span>&#123;</span><br><span class="line">        console.log(<span class="keyword">this</span>) <span class="comment">// obj</span></span><br><span class="line">        console.log(<span class="keyword">this</span> == obj) <span class="comment">// true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    fun1: (function fn()&#123;</span><br><span class="line">        console.log(<span class="keyword">this</span>) <span class="comment">// window</span></span><br><span class="line">    &#125;)()</span><br><span class="line">&#125;</span><br><span class="line">obj<span class="function">.<span class="title">fun</span><span class="params">()</span></span></span><br><span class="line">obj.fun1</span><br></pre></td></tr></table></figure>
<ul>
<li>例子</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[].slice() <span class="comment">// 基于原型链机制，先找的是[]原型上的slice方法，然后在执行。此时的this指的是当前的空数组（点前边是谁就是谁）</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.slice() <span class="comment">// this指的是Array.prototype</span></span><br><span class="line">[].__proto__.slice() <span class="comment">// this指的是[].__proto__</span></span><br><span class="line"><span class="built_in">console</span>.log([].__proto__ == <span class="built_in">Array</span>.prototype) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">// window</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.body.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">// body</span></span><br><span class="line">    foo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="构造函数-–-this"><a href="#构造函数-–-this" class="headerlink" title="构造函数 – this"></a>构造函数 – this</h3><blockquote>
<p>构造函数体中的 this  指的是当前类的实例，构造函数原型上的 this 不一定是当前实例，要看前边是否有“点”，点前边是什么 this 就指的是什么</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fun</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"hjj"</span> <span class="comment">// 这是给当前实例设置私有属性</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">// 当前实例，f</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Fun.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> Fun;</span><br><span class="line"></span><br><span class="line">f.getName(); <span class="comment">// this -&gt;  f</span></span><br><span class="line">Fun.prototype.getName() <span class="comment">//  this -&gt; Fun.prototype</span></span><br><span class="line">f.__proto__.getName() <span class="comment">//  this -&gt; f.__proto__</span></span><br></pre></td></tr></table></figure>
<h3 id="箭头函数-–-this"><a href="#箭头函数-–-this" class="headerlink" title="箭头函数 – this"></a>箭头函数 – this</h3><blockquote>
<p>箭头函数没有自己的 this ，他的 this 是继承所在上下文的 this</p>
</blockquote>
<h4 id="普通函数执行："><a href="#普通函数执行：" class="headerlink" title="普通函数执行："></a>普通函数执行：</h4><p>形成私有上下文跟AO – 初始化作用域链 – 初始化this – 初始化 arguments  – 形参赋值 – 变量提升 – 代码执行</p>
<h4 id="箭头函数执行"><a href="#箭头函数执行" class="headerlink" title="箭头函数执行:"></a>箭头函数执行:</h4><p>形成私有上下文跟AO – 初始化作用域链 – 形参赋值 – 变量提升 – 代码执行<br>执行过程中遇 this ，就直接照上级上下文中的 this</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span> let obj = &#123;</span><br><span class="line"><span class="regexp">//</span>     f1()&#123;</span><br><span class="line"><span class="regexp">//</span>         console.log(this)</span><br><span class="line"><span class="regexp">//</span>     &#125;,</span><br><span class="line"><span class="regexp">//</span>     f2:() =&gt; &#123;</span><br><span class="line"><span class="regexp">//</span>         console.log(this)</span><br><span class="line"><span class="regexp">//</span>     &#125;</span><br><span class="line"><span class="regexp">//</span> &#125;</span><br><span class="line"><span class="regexp">//</span> obj.f1(); <span class="regexp">//</span> obj</span><br><span class="line"><span class="regexp">//</span> obj.f2(); <span class="regexp">//</span> window</span><br><span class="line"><span class="regexp">//</span> obj.f2.call(obj) <span class="regexp">//</span> window,箭头函数是没有this的，强制更改也没有用</span><br></pre></td></tr></table></figure>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="string">//</span> let obj = &#123;</span><br><span class="line"><span class="string">//</span>     i: 0,</span><br><span class="line"><span class="string">//</span>     fun<span class="params">()</span>&#123;</span><br><span class="line"><span class="string">//</span>         console.log<span class="params">(this)</span> <span class="string">//</span> obj</span><br><span class="line"><span class="string">//</span>         <span class="keyword">set</span>Timeout<span class="params">(function()</span>&#123; <span class="string">//</span> 回调函数中的this一般都是window，特殊情况除外<span class="params">(强制改变)</span></span><br><span class="line"><span class="string">//</span>             this.i ++;</span><br><span class="line"><span class="string">//</span>             console.log<span class="params">(obj.i)</span> <span class="string">//</span> 0</span><br><span class="line"><span class="string">//</span>             console.log<span class="params">(this)</span> <span class="string">//</span> window</span><br><span class="line"><span class="string">//</span>         &#125;, 1000)</span><br><span class="line"><span class="string">//</span>     &#125; </span><br><span class="line"><span class="string">//</span> &#125;</span><br><span class="line"><span class="string">//</span> obj.fun<span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="string">//</span> let obj = &#123;</span><br><span class="line"><span class="string">//</span>     i: 0,</span><br><span class="line"><span class="string">//</span>     fun<span class="params">()</span>&#123;</span><br><span class="line"><span class="string">//</span>         let _this = this</span><br><span class="line"><span class="string">//</span>         <span class="keyword">set</span>Timeout<span class="params">(function()</span>&#123;</span><br><span class="line"><span class="string">//</span>             _this.i ++;</span><br><span class="line"><span class="string">//</span>             console.log<span class="params">(obj.i)</span> <span class="string">//</span> 1</span><br><span class="line"><span class="string">//</span>             console.log<span class="params">(this)</span> <span class="string">//</span> window</span><br><span class="line"><span class="string">//</span>         &#125;, 1000)</span><br><span class="line"><span class="string">//</span>     &#125; </span><br><span class="line"><span class="string">//</span> &#125;</span><br><span class="line"><span class="string">//</span> obj.fun<span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="string">//</span> let obj = &#123;</span><br><span class="line"><span class="string">//</span>     i: 0,</span><br><span class="line"><span class="string">//</span>     fun<span class="params">()</span>&#123;</span><br><span class="line"><span class="string">//</span>         <span class="keyword">set</span>Timeout<span class="params">(function()</span>&#123;</span><br><span class="line"><span class="string">//</span>             this.i ++;</span><br><span class="line"><span class="string">//</span>             console.log<span class="params">(obj.i)</span> <span class="string">//</span> 1</span><br><span class="line"><span class="string">//</span>             console.log<span class="params">(this)</span> <span class="string">//</span> obj</span><br><span class="line"><span class="string">//</span>         &#125;<span class="string">.bind</span><span class="params">(this)</span>, 1000)</span><br><span class="line"><span class="string">//</span>     &#125; </span><br><span class="line"><span class="string">//</span> &#125;</span><br><span class="line"><span class="string">//</span> obj.fun<span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="string">//</span> let obj = &#123;</span><br><span class="line"><span class="string">//</span>     i: 0,</span><br><span class="line"><span class="string">//</span>     fun<span class="params">()</span>&#123;</span><br><span class="line"><span class="string">//</span>         <span class="keyword">set</span>Timeout<span class="params">(()</span> =&gt; &#123;</span><br><span class="line"><span class="string">//</span>             <span class="string">//</span> 箭头函数中没有this，他的this是上下文中的this，即obj</span><br><span class="line"><span class="string">//</span>             this.i ++;</span><br><span class="line"><span class="string">//</span>             console.log<span class="params">(obj.i)</span> <span class="string">//</span> 1</span><br><span class="line"><span class="string">//</span>             console.log<span class="params">(this)</span> <span class="string">//</span> obj</span><br><span class="line"><span class="string">//</span>         &#125;, 1000)</span><br><span class="line"><span class="string">//</span>     &#125; </span><br><span class="line"><span class="string">//</span> &#125;</span><br><span class="line"><span class="string">//</span> obj.fun<span class="params">()</span></span><br></pre></td></tr></table></figure>
<h3 id="call、apply、bind-–-this"><a href="#call、apply、bind-–-this" class="headerlink" title="call、apply、bind – this"></a>call、apply、bind – this</h3><blockquote>
<p>基于call、apply、bind三种方法，可以强制手动更改this指向</p>
</blockquote>
<h4 id="call"><a href="#call" class="headerlink" title="call"></a>call</h4><p>[function].call( [context] , params1 , params2 , …) , [function]作为[Function] 的内置类的实例，可以基于 <strong>proto</strong> 找到 Function.prototype 的 call 方法，并把 call 方法执行，在执行 call 方法的同时把[function]执行，并把函数中的 this 指向 [context] ,并且把 params1 这些参数值传递给函数<br>call 的第一个参数不传或者传的是null 、undefined的时候，在非严格模式下this指的是window，在严格模式下，传的是什么就是什么，没有传就是undefined</p>
<h4 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h4><p>[function].call( [context] , [params1 , params2 , …]) 和 call 的作用一样，唯一不同的是参数传递方式不一样， apply 这个参数的形式是数组形式的</p>
<h4 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h4><p>[function].call( [context] , params1 , params2 , …)<br>call、apply是立即执行，摒弃改变函数的this的指向，而bind 是预处理的思想，把函数的this预处理成[context],把参数预先存储起来，但此时函数并没有执行。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>一般按照事件绑定、普通事件、构造函数判断就可以了， 但是一旦前三种遇到 call、apply、bind 这三种都按照 call、apply、bind的 this 执行，箭头函数除外，箭头函数强制更改不起作用。</p>
</blockquote>
<blockquote>
<p>习题 // 22  23  65  30</p>
</blockquote>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> <span class="built_in">num</span> = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">let</span> obj = &#123;</span><br><span class="line">    <span class="built_in">num</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line">obj.fn = (function(<span class="built_in">num</span>)&#123;</span><br><span class="line">    this.<span class="built_in">num</span> = <span class="built_in">num</span> * <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">num</span> ++;</span><br><span class="line">    <span class="built_in">return</span> function(n) &#123;</span><br><span class="line">        this.<span class="built_in">num</span> += n;</span><br><span class="line">        <span class="built_in">num</span> ++;</span><br><span class="line">        console.<span class="built_in">log</span>(<span class="built_in">num</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(obj.<span class="built_in">num</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">var</span> fn = obj.fn;</span><br><span class="line">fn(<span class="number">5</span>)</span><br><span class="line">obj.fn(<span class="number">10</span>)</span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">num</span>, onj.<span class="built_in">num</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>Js</tag>
      </tags>
  </entry>
  <entry>
    <title>原型、原型链、call/apply</title>
    <url>/2020/09/21/%E5%89%8D%E7%AB%AF/%E5%8E%9F%E5%9E%8B%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BE%E3%80%81call/apply/</url>
    <content><![CDATA[<h1 id="原型以及原型链"><a href="#原型以及原型链" class="headerlink" title="原型以及原型链"></a>原型以及原型链</h1><blockquote>
<p>如何理解原型？如何理解原型链？</p>
</blockquote>
<p>当我们创建一个对象时 <code>let obj = { age: 25 }</code>，我们可以发现能使用很多种函数，但是我们明明没有定义过它们，对于这种情况你是否有过疑惑？</p>
<p><img src="/images/杂记/da5658107d83b4b540a52640ce1443c.png" alt="图片alt"></p>
<p>当我们在浏览器中打印 <code>obj</code> 时你会发现，在 <code>obj</code> 上居然还有一个 <code>__proto__</code> 属性，那么看来之前的疑问就和这个属性有关系了。</p>
<p>其实每个 JS 对象都有 <code>__proto__</code> 属性，这个属性指向了原型。这个属性在现在来说已经不推荐直接去使用它了，这只是浏览器在早期为了让我们访问到内部属性 <code>[[prototype]]</code> 来实现的一个东西。</p>
<p>讲到这里好像还是没有弄明白什么是原型，接下来让我们再看看 <code>__proto__</code> 里面有什么吧。</p>
<p><img src="/images/杂记/89c104ce6dcf13ac064958b126347e7.png" alt="图片alt"></p>
<p>看到这里你应该明白了，原型也是一个对象，并且这个对象中包含了很多函数，所以我们可以得出一个结论：对于 <code>obj</code> 来说，可以通过 <code>__proto__</code> 找到一个原型对象，在该对象中定义了很多函数让我们来使用。</p>
<p>在上面的图中我们还可以发现一个 <code>constructor</code> 属性，也就是构造函数</p>
<p><img src="/images/杂记/8b6ee1e2b20bbeac68544dd1bfe54a1.png" alt="图片alt"></p>
<p>打开 <code>constructor</code> 属性我们又可以发现其中还有一个 <code>prototype</code> 属性，并且这个属性对应的值和先前我们在 <code>__proto__</code> 中看到的一模一样。所以我们又可以得出一个结论：原型的 <code>constructor</code> 属性指向构造函数，构造函数又通过 <code>prototype</code> 属性指回原型，但是并不是所有函数都具有这个属性，<code>Function.prototype.bind()</code> 就没有这个属性。</p>
<p>其实原型就是那么简单，接下来我们再来看一张图，相信这张图能让你彻底明白原型和原型链</p>
<p><img src="/images/杂记/1671d387e4189ec8.webp" alt="图片alt"></p>
<p>看完这张图，我再来解释下什么是原型链吧。其实原型链就是多个对象通过 <code>__proto__</code>的方式连接了起来。为什么<code>obj</code> 可以访问到 <code>valueOf</code> 函数，就是因为 <code>obj</code> 通过原型链找到了 <code>valueOf</code> 函数。</p>
<p>对于这一小节的知识点，总结起来就是以下几点：</p>
<ul>
<li>Object 是所有对象的爸爸，所有对象都可以通过 <code>__proto__</code> 找到它</li>
<li>Function 是所有函数的爸爸，所有函数都可以通过 <code>__proto__</code> 找到它</li>
<li>函数的 <code>prototype</code> 是一个对象</li>
<li>对象的 <code>__proto__</code> 属性指向原型， <code>__proto__</code> 将对象和原型连接起来组成了原型链</li>
</ul>
<h1 id="手写-call、apply-及-bind-函数"><a href="#手写-call、apply-及-bind-函数" class="headerlink" title="手写 call、apply 及 bind 函数"></a>手写 call、apply 及 bind 函数</h1><blockquote>
<p>手写 call、apply 及 bind 函数内部实现是怎么样的？</p>
</blockquote>
<p>首先从以下几点来考虑如何实现这几个函数</p>
<ul>
<li>不传入第一个参数，那么上下文默认为 <code>window</code></li>
<li>改变了 <code>this</code> 指向，让新的对象可以执行该函数，并能接受参数</li>
</ul>
<p>那么我们先来实现 <code>call</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Error'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  context = context || <span class="built_in">window</span></span><br><span class="line">  context.fn = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">const</span> args = [...arguments].slice(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">const</span> result = context.fn(...args)</span><br><span class="line">  <span class="keyword">delete</span> context.fn</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"md-section-divider"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>
<p>以下是对实现的分析：</p>
<ul>
<li>首先 <code>context</code> 为可选参数，如果不传的话默认上下文为 <code>window</code></li>
<li>接下来给 <code>context</code> 创建一个 fn 属性，并将值设置为需要调用的函数</li>
<li>因为 <code>call</code> 可以传入多个参数作为调用函数的参数，所以需要将参数剥离出来</li>
<li>然后调用函数并将对象上的函数删除<br>以上就是实现 <code>call</code> 的思路，<code>apply</code> 的实现也类似，区别在于对参数的处理，所以就不一一分析思路了</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Error'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  context = context || <span class="built_in">window</span></span><br><span class="line">  context.fn = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">let</span> result</span><br><span class="line">  <span class="comment">// 处理参数和 call 有区别</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">arguments</span>[<span class="number">1</span>]) &#123;</span><br><span class="line">    result = context.fn(...arguments[<span class="number">1</span>])</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = context.fn()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> context.fn</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"md-section-divider"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>bind</code> 的实现对比其他两个函数略微地复杂了一点，因为 <code>bind</code> 需要返回一个函数，需要判断一些边界问题，以下是 <code>bind</code> 的实现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Error'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> _this = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">const</span> args = [...arguments].slice(<span class="number">1</span>)</span><br><span class="line">  <span class="comment">// 返回一个函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 因为返回了一个函数，我们可以 new F()，所以需要判断</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> F) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> _this(...args, ...arguments)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _this.apply(context, args.concat(...arguments))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"md-section-divider"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>
<p>以下是对实现的分析：</p>
<ul>
<li>前几步和之前的实现差不多，就不赘述了</li>
<li><code>bind</code> 返回了一个函数，对于函数来说有两种方式调用，一种是直接调用，一种是通过 <code>new</code> 的方式，我们先来说直接调用的方式</li>
<li>对于直接调用来说，这里选择了 <code>apply</code> 的方式实现，但是对于参数需要注意以下情况：因为 <code>bind</code> 可以实现类似这样的代码 <code>f.bind(obj, 1)(2)</code>，所以我们需要将两边的参数拼接起来，于是就有了这样的实现 <code>args.concat(...arguments)</code></li>
<li>最后来说通过 <code>new</code> 的方式，在之前的章节中我们学习过如何判断 <code>this</code>，对于 <code>new</code> 的情况来说，不会被任何方式改变 <code>this</code>，所以对于这种情况我们需要忽略传入的 <code>this</code></li>
</ul>
<h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><blockquote>
<p><code>new</code> 的原理是什么？通过 <code>new</code> 的方式创建对象和通过字面量创建有什么区别？</p>
</blockquote>
<p>在调用 new 的过程中会发生以上四件事情：</p>
<p>1.新生成了一个对象<br>2.链接到原型<br>3.绑定 <code>this</code><br>4.返回新对象<br>根据以上几个过程，我们也可以试着来自己实现一个 <code>new</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">  <span class="keyword">let</span> Con = [].shift.call(<span class="built_in">arguments</span>)</span><br><span class="line">  obj.__proto__ = Con.prototype</span><br><span class="line">  <span class="keyword">let</span> result = Con.apply(obj, <span class="built_in">arguments</span>)</span><br><span class="line">  <span class="keyword">return</span> result <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? result : obj</span><br><span class="line">&#125;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"md-section-divider"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>
<p>以下是对实现的分析：</p>
<ul>
<li>创建一个空对象</li>
<li>获取构造函数</li>
<li>设置空对象的原型</li>
<li>绑定 <code>this</code> 并执行构造函数</li>
<li>确保返回值为对象</li>
<li>对于对象来说，其实都是通过 <code>new</code> 产生的，无论是 <code>function Foo()</code> 还是 <code>let a = { b : 1 }</code> 。</li>
</ul>
<p>对于创建一个对象来说，更推荐使用字面量的方式创建对象（无论性能上还是可读性）。因为你使用 <code>new Object()</code> 的方式创建对象需要通过作用域链一层层找到 <code>Object</code>，但是你使用字面量的方式就没这个问题。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// function 就是个语法糖</span></span><br><span class="line"><span class="comment">// 内部等同于 new Function()</span></span><br><span class="line"><span class="keyword">let</span> a = &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="comment">// 这个字面量内部也是使用了 new Object()</span></span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"md-section-divider"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>Js</tag>
      </tags>
  </entry>
  <entry>
    <title>promise使用</title>
    <url>/2021/02/24/%E5%89%8D%E7%AB%AF/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/promise%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h1><h2 id="promise执行"><a href="#promise执行" class="headerlink" title="promise执行"></a>promise执行</h2><p>promise会在当前轮的最后当作微任务执行<br><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'a'</span>), <span class="number">0</span>)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'b'</span>), <span class="number">1000</span>)</span><br><span class="line">Promise.resolve()</span><br><span class="line">    .<span class="keyword">then</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'c'</span>), <span class="number">0</span>)</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'d'</span>), <span class="number">1000</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'e'</span>);</span><br><span class="line">        Promise.resolve()</span><br><span class="line">            .<span class="keyword">then</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'f'</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="keyword">then</span>(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'g'</span>))</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'h'</span>), <span class="number">0</span>)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'i'</span>), <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> efg ahc bid</span><br></pre></td></tr></table></figure></p>
<h2 id="promise-all"><a href="#promise-all" class="headerlink" title="promise.all"></a>promise.all</h2><blockquote>
<p>其中一个失败导致整个的结果都是失败的处理方法</p>
</blockquote>
<ul>
<li><p>2018之前的解决方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> axios = <span class="built_in">require</span>(<span class="string">'axios'</span>)</span><br><span class="line"><span class="comment">//xxx 地址不存在肯定会失败</span></span><br><span class="line"><span class="keyword">let</span> arr = [</span><br><span class="line">	<span class="string">"https://www.baidu.com"</span>,</span><br><span class="line">  <span class="string">"httpss://github.com/"</span>,</span><br><span class="line">  <span class="string">"http://xxx"</span> </span><br><span class="line">]</span><br><span class="line"><span class="comment">// promise数组</span></span><br><span class="line"><span class="keyword">const</span> promises = arr.map(<span class="function"><span class="params">item</span> =&gt;</span> axios(item))</span><br><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.all(promises)</span><br><span class="line">p.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'res'</span>, res) <span class="comment">// 此处的res是每一个请求返回的结果</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上情况 如果其中一个任务失败，必定导致整个任务的结果都是失败的，</span></span><br><span class="line"><span class="comment">// 所以需要对数组中每个promise都去处理下catch,才会成功</span></span><br><span class="line"><span class="comment">// 解决办法  第九行代码，每一个都catch那么结果都是成功的，失败的都会返回hhh，后续也可根据hhh判断失败的</span></span><br><span class="line"><span class="keyword">const</span> promises = arr.map(<span class="function"><span class="params">item</span> =&gt;</span> axios(item).catch(e) =&gt; <span class="string">'hhh'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>2020的解决方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [</span><br><span class="line">    <span class="string">"https://github.com/"</span>,</span><br><span class="line">    <span class="string">"https://www.baidu.com/"</span>,</span><br><span class="line">    <span class="string">"https://xxx"</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise = <span class="built_in">Promise</span>.allSettled(arr.map(<span class="function"><span class="params">item</span> =&gt;</span> axios(item)))</span><br><span class="line">promise.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    status: <span class="string">"fulflled"</span>,</span><br><span class="line">    value:&#123;</span><br><span class="line">      code: <span class="number">200</span>,</span><br><span class="line">      statustext: <span class="string">"ok"</span>,</span><br><span class="line">      ....</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,<span class="comment">// 成功的</span></span><br><span class="line">  ...</span><br><span class="line">  &#123;</span><br><span class="line">    status: <span class="string">"rejected"</span>,</span><br><span class="line">    reason:&#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="comment">// 失败的</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>一个没有函数体的空函数<br></p>
]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>Js</tag>
      </tags>
  </entry>
  <entry>
    <title>npm命令</title>
    <url>/2021/02/24/%E5%89%8D%E7%AB%AF/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/npm%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h1><ul>
<li><code>&quot;dependencies&quot;</code>：您的应用程序在生产中需要这些包。</li>
<li><p><code>&quot;devDependencies&quot;</code>：这些包仅用于开发和测试。</p>
</li>
<li><p>添加到dependencies：</p>
<ul>
<li>npm install gulp –save  ||   npm install gulp -S<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="string">"gulp"</span>: <span class="string">"^3.9.1"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>添加到devDependencies：</p>
<ul>
<li>npm install gulp –save-dev   ||   npm install gulp -D<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="string">"gulp"</span>: <span class="string">"^3.9.1"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>安装指定版本，不指定默认安装最新版本</p>
<ul>
<li>npm install <a href="mailto:glup@3.9.1" target="_blank" rel="noopener">glup@3.9.1</a><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="string">"gulp"</span>: <span class="string">"^3.9.1"</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>安装包信息将加入到optionalDependencies（可选阶段的依赖）</p>
<ul>
<li>npm install jquery –save-optional   ||    npm install jquery -O<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"optionalDependencies"</span>: &#123;</span><br><span class="line">   <span class="string">"jquery"</span>: <span class="string">"^3.5.1"</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>精确安装指定模块版本</p>
<ul>
<li>npm install jquery –save-exact    ||   npm install jquery -E</li>
<li>注意：版本前边的^没有啦<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="string">"jquery"</span>: <span class="string">"2.6.12"</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>查看安装所有模块</p>
<ul>
<li>npm ls</li>
</ul>
</li>
<li>文件夹下创建package.json文件，方便包的管理<ul>
<li>npm init</li>
</ul>
</li>
<li>要从node_modules目录中删除包<ul>
<li>npm uninstall <package></package></li>
</ul>
</li>
<li>要从依赖项dependencies中删除，您需要使用save标志：<ul>
<li>npm uninstall –save <package></package></li>
</ul>
</li>
<li>要从devDependency删除<ul>
<li>npm uninstall –save-dev <package></package></li>
</ul>
</li>
<li>临时配置淘宝镜像<ul>
<li>npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>Js</tag>
      </tags>
  </entry>
  <entry>
    <title>web性能</title>
    <url>/2022/04/21/%E5%89%8D%E7%AB%AF/%E6%80%A7%E8%83%BD/web%E6%80%A7%E8%83%BD/</url>
    <content><![CDATA[<p>原文链接：<a href="https://ui.toast.com/fe-guide/en_PERFORMANCE/#minimizing-the-size-of-resources" target="_blank" rel="noopener">https://ui.toast.com/fe-guide/en_PERFORMANCE/#minimizing-the-size-of-resources</a></p>
<blockquote>
<p>本文档介绍了改善web应用性能的原因并提供了几种较实用的优化方案。<br>优化部分分为网页加载优化与网页渲染优化两大部分。其中：<br>【网页加载优化】提供了阻塞资源优化、最小化资源请求数、捆绑CSS和JavaScript、使用內联样式、以HTML和CSS代替小图像等优化方案。<br>【网页渲染优化】提供了布局优化、HTML和CSS优化、动画优化等优化方案。</p>
</blockquote>
<p>无论是在web层面抑或是在应用层面上，应用的性能优化都是非常重要的。现在的web应用程序已经变得十分庞大且密集，具有Ajax通信和复杂UI等功能。繁重的web应用最终会导致长时间的加载以及糟糕的用户体验感。举个例子，Pinterest，之前它过长的加载时间导致用户非常有可能离开当前页面，而它通过性能优化，不仅减少了跳出率也使得收入增加了40%。由于性能与盈利直接挂钩，因此优化Web应用程序的性能显得至关重要。本指南指在为读者提供性能优化的基本背景知识，并通过分别讨论网页加载与网页渲染来介绍各种优化方法。</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><h4 id="性能优化必备的理论和衡量工具"><a href="#性能优化必备的理论和衡量工具" class="headerlink" title="性能优化必备的理论和衡量工具"></a>性能优化必备的理论和衡量工具</h4><p>为了能有效地优化性能，我们需要对性能的概念和术语有个清晰的了解。本章将重点介绍浏览器加载页面的过程，并对用于各个阶段的性能衡量的技术术语及指标进行解释。于此同时，本章将介绍如何使用Chrome DevTools来衡量性能。</p>
<h5 id="浏览器是如何加载的？"><a href="#浏览器是如何加载的？" class="headerlink" title="浏览器是如何加载的？"></a>浏览器是如何加载的？</h5><p>浏览器通过多个后台操作（如下载必要的资源，转移上述资源等），将内容呈现在屏幕上。这些操作包括下载、解析、样式、布局、绘制以及合成，我们将这些统称为“加载阶段”。接下来，让我们一起来看看每个阶段分别做了些啥。</p>
<ol>
<li><strong>解析</strong></li>
</ol>
<p>首先，当浏览器加载页面时，它会下载HTML文件。解析是浏览器转换下载的HTML结构以构建<strong>DOM</strong>树的阶段。如果浏览器在解析阶段捕捉到<code>&lt;script/&gt;</code>, <code>&lt;link/&gt;</code>, 或者<code>&lt;div/&gt;</code>等元素时，它会请求适当的资源并下载下来。如果CSS也在HTML或者在资源中，浏览器同时也会构建CSSOM树。<strong>DOM</strong>树和<strong>CSSOM</strong>树的结构将会在下面进行详述。</p>
<p><strong>DOM树结构</strong><br>为了更好地解释DOM树结构，让我们先来看下以下HTML文件。<br>当解析发生时，浏览器将分析HTML文件以创建DOM，并通过树形数据结构连接每个DOM对象以建立父子关系。诸如<code>&lt;body&gt;</code>，<code>&lt;p&gt;</code>和<code>&lt;div&gt;</code>之类的标签则被创建为DOM树中的节点并引用子节点。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"style.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Critical Path<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello <span class="tag">&lt;<span class="name">span</span>&gt;</span>web performance<span class="tag">&lt;/<span class="name">span</span>&gt;</span> students!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"awesome-photo.jpg"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>CSSOM Tree Construction</strong></p>
<p>如上个例子所示，如果文件包含了外部样式文件或者像<code>style.css</code>一样的內联样式，浏览器会转换CSS并构造CSS对象模型（CSSOM）树。诸如body、p、span等选择器则会被用作节点，每个节点引用不同的样式。<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* style.css */</span></span><br><span class="line">  <span class="selector-tag">body</span> &#123; <span class="attribute">font-size</span>: <span class="number">16px</span> &#125;</span><br><span class="line">  <span class="selector-tag">p</span> &#123; <span class="attribute">font-weight</span>: bold &#125;</span><br><span class="line">  <span class="selector-tag">span</span> &#123; <span class="attribute">color</span>: red &#125;</span><br><span class="line">  <span class="selector-tag">p</span> <span class="selector-tag">span</span> &#123; <span class="attribute">display</span>: none &#125;</span><br><span class="line">  <span class="selector-tag">img</span> &#123; <span class="attribute">float</span>: right &#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/images/性能/1.png" alt="image.png"></p>
<ol start="2">
<li><strong>样式计算</strong></li>
</ol>
<p>在样式计算阶段，浏览器通过使用在解析阶段构建的DOM和CSSOM树来构建另一种树，这种树用于使得每个元素都能与之相应的样式匹配。下图描述了如何通过组合在解析阶段构建的两棵树来制作渲染树：<br><img src="/images/性能/2.png" alt="image.png"></p>
<ol start="3">
<li><strong>布局</strong></li>
</ol>
<p>在布局阶段，浏览器会以数学方式去计算节点的确切位置和大小。为此，浏览器从根节点开始，并通过遍历整个树来计算每个节点，并将布局结果应用于渲染树的确切像素位置。下图展示了布局的前后。如果在CSS中使用百分比来表示尺寸，那么在布局之后，%表示法将被转换成像素单位(px)。<br><img src="/images/性能/3.png" alt="image.png"></p>
<p><img src="/images/性能/4.png" alt="image.png"></p>
<ol start="4">
<li><strong>绘制</strong></li>
</ol>
<p>在先前的布局阶段中，渲染树的每个节点通过计算出的属性被转化成实际像素。现在，浏览器将应用那些与元素位置无关的CSS属性，如颜色和透明度等。然后，像素化的结果会像在Photoshop一样被绘制成图层，并按照图层进行管理。然而，并不是所有元素都会被转换成图层。Transfrom属性会将这些元素构建成图层，这个过程被称为绘制。</p>
<ol start="5">
<li><strong>合成与渲染</strong></li>
</ol>
<p>浏览器使用绘制阶段所创建的一系列图层组合来更新屏幕。经过合成和渲染阶段，最后可以在屏幕上看到页面。<br>下图描述了浏览器的加载阶段。为了全面理解如何改进web应用程序，开发人员必须要具备浏览器加载阶段的实用知识，这一点很重要。<br><img src="/images/性能/5.png" alt="image.png"></p>
<h5 id="布局与重绘"><a href="#布局与重绘" class="headerlink" title="布局与重绘"></a>布局与重绘</h5><p>样式计算（样式计算 -&gt; 布局 -&gt; 绘制 -&gt; 合成）之后的浏览器加载阶段被统称为“渲染”。根据实际情况，这种渲染过程可能会发生多次。在样式计算阶段构造的渲染树，在每次因Js导致DOM树或CSSOM树变更时，都必须进行重构。例如，如果插入或删除了DOM，又或者更改了对设计有几何影响（比如高度、宽度、位置等）的CSS元素，则必须重建渲染树。因此，必须从布局阶段开始重复此过程，而这个过程也被称为<strong>布局</strong>。（在FireFox中这也被称为<strong>重排</strong>）</p>
<p><img src="/images/性能/6.png" alt="image.png"><br>如上所述，当影响几何布局的CSS元素有变化时，就会发生布局，但相反，如果所做的更改并不影响结构的几何形状，浏览器引擎就会跳过布局阶段。这个过程从绘制阶段开始继续，而此过程也被称为<strong>重绘</strong>。</p>
<p><img src="/images/性能/7.png" alt="image.png"><br>如果发生布局，引擎必须再次将整个页面呈现重新计算成像素，这会给引擎带来压力。然而，重绘只需要浏览器使用早就计算好的像素值去绘制页面，所以这在浏览器上会相对容易。下面给出的示例代码演示了布局与重绘所花费的时间之间的差异。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"sample"</span> <span class="attr">style</span>=<span class="string">"background:red;width:150px;height:50px;"</span>&gt;</span></span><br><span class="line">  Sample</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>在有几何效果的情况下更改元素属性的值：</strong></p>
<ul>
<li><p>css属性：height, width, left, top, font-size, line-height等</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> example = <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>);</span><br><span class="line"></span><br><span class="line">example.style.width = <span class="string">'400px'</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>发生布局：</p>
</li>
</ul>
<p><img src="/images/性能/8.png" alt="image.png"></p>
<p><strong>在没有几何效果的情况下更改元素属性的值：</strong></p>
<ul>
<li>css属性：background-color, color, visibility, text-decoration 等</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sample = <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>);</span><br><span class="line"></span><br><span class="line">example.style.backgroundColor = <span class="string">'blue'</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>发生重绘：</li>
</ul>
<p><img src="/images/性能/9.png" alt="image.png"><br>正如上述表示，如果出现了布局，渲染时间会随着执行时间的增加而增加。因此，非常有必要确保那些没有必要的布局发生。</p>
<h5 id="阻塞资源和关键渲染路径"><a href="#阻塞资源和关键渲染路径" class="headerlink" title="阻塞资源和关键渲染路径"></a>阻塞资源和关键渲染路径</h5><p>在浏览器加载的初期，也就是解析发生的时候，如果浏览器运行CSS或JS，则可以暂停解析。这种情况通常被描述为“HTML解析阻塞”，造成阻塞的资源被称为“阻塞资源”。阻塞资源会延迟加载的绘制阶段，因此开发者必须格外注意防止阻塞资源去阻塞HTML资源。Google解释道，加载速度可以通过优化关键渲染路径（CRP）来得到提升，这将会在下一章节进行详细讨论。</p>
<h5 id="性能改善指标"><a href="#性能改善指标" class="headerlink" title="性能改善指标"></a>性能改善指标</h5><p>到此为止，这篇文章已经分析了那些可能对加载进程产生不利影响的元素。现在，我们将讨论如何去加快进程加载。为了明白需要提升什么东西，我们必须弄清楚什么样的情况下加载速度会变慢。性能指标的衡量标准主要分为两类：从浏览器角度以及从用户角度。接下来的篇章将深入阐述这两类有何不同，同时也会介绍用于衡量性能的指标。</p>
<p><strong>从浏览器角度衡量性能</strong></p>
<p>衡量性能的传统方法是将浏览器中发生的事件作为里程碑。当页面加载时，DOMContentLoaded以及加载事件发生，并根据各个事件的发生时间来衡量性能。下图是一个导航时序处理模型的示意图，这个模型表明，DOMContentLoaded事件（蓝色下划线部分）以及加载事件（红色下划线部分）出现得越快，两者之间的延迟会越短，性能也就越好。</p>
<p><img src="/images/性能/10.png" alt="image.png"></p>
<p>DOMContentLoaded事件和加载事件的特定发生点如下。</p>
<p><strong>【DOMContentLoaded事件】</strong></p>
<ul>
<li>当HTML和CSS解析完成时</li>
<li>当引擎准备构建渲染树时（DOM和CSSOM已经被构建好）</li>
</ul>
<p><strong>【加载事件】</strong></p>
<ul>
<li>当HTML的所有资源都已经加载完成时</li>
</ul>
<p>可以使用<em>Chrome DevTools（谷歌开发者工具）</em>或使用<em>导航计时API</em>来监视这两个事件的发生点。</p>
<p><strong>【使用导航计时API】</strong></p>
<p>浏览器提供了导航计时API供开发者们衡量页面的性能。使用导航计时API中 <code>PerformanceNavigationTiming</code>的<code>domContentLoadedEventStart</code>属性以及通过使用<code>loadEventStart</code>，开发者们可以分别获取到<code>DOMcontentLoaded</code>和<code>load</code>发生的时间点。</p>
<p><strong>【使用Chrome DevTools】</strong></p>
<p>Chrome DevTools提供了多种用户界面以及方法来检测事件发生的时间点以及衡量性能。在DevTools的下半部分，DOMContentLoaded和load事件发生的时间点被分别标记为蓝色和红色。相比于使用导航计时API，开发者们通过Chrome DevTools能够更容易捕捉到事件发生的时间点。</p>
<p><img src="/images/性能/11.png" alt="image.png"></p>
<p>然而，随着发展范式的不断变化，仅仅凭借DomContentLoaded和load事件发生的时间点来判断应用的性能变得越来越难。最近流行的单页应用程序（SPA）的DOMContentLoaded和加载事件发生的时间点很早，但是由于其他脚本继续运行，这个程序加载仍然很慢。因此，开发者们必须想出一种通过用户角度来衡量性能的方法。</p>
<p><strong>从用户角度衡量性能</strong><br>从用户的角度衡量性能基于显示给用户的内容的多个时间戳。有意义的内容越快地被呈现给用户，应用的性能就越好，开发者们应当尝试优化代码让内容呈现发生得更快。下图是两个渲染脚本的对照，两个脚本均有并发DOMCotentLoaded和load事件发生，不同的是，一个代码已被优化，而另一个代码没有被优化。在被优化的代码中，经过0.3秒，页面的部分内容已经能够看到了，页面逐渐呈现出来。而没有被优化的代码中，经过1.5秒的空白期，第一个页面才得以呈现。而大部分用户将会觉得被优化的代码更“快”。<br><img src="/images/性能/12.png" alt="image.png"></p>
<p>Google定义了多个让用户感到该页面是否已快速加载的时刻，这些时刻被用于衡量性能，我们将在下面对它们进行描述。</p>
<p><strong>【 First Paint（FC）- 首次绘制 】</strong><br>有东西出现在空白页面时。</p>
<p><strong>【 First Contentful Paint（FCP） - 首次内容绘制 】</strong><br>文字或者图片开始被绘制时。</p>
<p><strong>【 First Meaningful Paint（FMP） - 首次有效绘制 】</strong><br>对用户有意义的内容开始被绘制时。呈现内容所需的CSS和JavaScript开始加载，且已经应用样式，以便内容得以被理解。</p>
<p><strong>【Time to Interactive（TTI）- 可交互时间 】</strong><br>JavaScript完成执行，用户可以进行操作时。</p>
<p><img src="/images/性能/13.png" alt="image.png"><br>在上述时刻中，FMP是最为重要的，并且在加载完成前向用户呈现出有用的信息是必不可少的，因为这可以给用户留下一个“这应用还挺快”的印象。从用户的角度来看，好的性能意味着快速实现首次有效绘制，这可以通过优化上述关键渲染路径得以实现。</p>
<h5 id="性能衡量工具"><a href="#性能衡量工具" class="headerlink" title="性能衡量工具"></a>性能衡量工具</h5><p>前面所述的Devtools由谷歌浏览器提供，它可以用于验证到目前为止已讨论的所有内容。DevTools提供了三个与性能相关的面板，分别是Network（网络），Performance（性能）和Audits（审计）。这一章我们将阐述各个面板所扮演的角色以及用途，下一章将阐述如何将它们实际应用到项目中去。</p>
<p><strong>性能面板</strong><br>性能面板能够让用户通过图表监控此前提到的每个加载阶段。当页面加载时，每个加载阶段都会被记录下来，并且还可以监控某个确切时间发生的时间。这个面板主要用于指出在加载过程中哪个领域必须被优化。</p>
<p><strong>【面板信息】</strong></p>
<ul>
<li>（1）Controls：包括开始和清空记录的按钮。<ul>
<li>第一个按钮用于手动控制记录。</li>
<li>第二个按钮用于当页面刷新时，自动开启记录，而当页面加载完成时，自动停止记录。</li>
</ul>
</li>
<li>（2）Capture<ul>
<li>Screenshots：根据时间呈现不同的渲染状态。</li>
<li>Memory：显示堆内存状态</li>
<li>Garbage Collection：手动启用垃圾收集</li>
</ul>
</li>
<li>（3）Overview：显示装载机的概述</li>
<li>（4）Main：详细显示在“Overview”部分中选择的区域。</li>
<li>（5）Details：显示有关在“main”部分中选择的区域的详细信息。</li>
</ul>
<p><img src="/images/性能/14.png" alt="image.png"><br><strong>【 检查网页加载过程 】</strong><br>可以使用控制项（Controls）去记录整个过程来检查整个加载过程，然后在Main区域中对其进行监视。<br>（此处本应有图，然图挂了）</p>
<p><strong>网络面板</strong><br>网络面板可以用于监控在加载过程中被请求的资源的状态，也被用于比较和优化资源状态。与性能面板一样，在记录完成后，资源请求信息可以在Overview和Request表中被找到。资源列表按照时间排序，通过单击图表可以访问相应的服务器请求响应时间。同时，DOMContentLoaded和load出现的时间点会在打印在底部。</p>
<p><strong>【 面板信息 】</strong></p>
<ul>
<li>（1）Controls（控制项）：控制面案的显示和运行。</li>
<li>（2）Filters（筛选）：筛选出需要显示的资源。</li>
<li>（3）Overview（概述）：显示请求和下载流程的概述。</li>
<li>（4）Request Table（请求表）：显示检测各个资源请求和下载的状态。</li>
<li>（5）Summary（总结）：显示请求资源的总数，传输数据的大小和事件加载时间。</li>
</ul>
<p>（此处本应有图，然图挂了）</p>
<p><strong>【监视服务器请求响应时间】</strong></p>
<ul>
<li>（1）Queuing：排队时间<ul>
<li>JavaScript和CSS具有更高的优先级。</li>
<li>TCP Socket Queue（TCP 套接字队列）</li>
<li>TCP Connection Timeout Queue（TCP 连接超时队列）</li>
<li>Disk Cache Formation Queue（磁盘缓存形成队列）</li>
</ul>
</li>
<li>（2）Stalled：请求发送之前的停滞时间<ul>
<li>在排队(Queuing)中花费的时间。</li>
<li>代理协商所需要的时间。</li>
</ul>
</li>
<li>（3）DNS Lookup：花费在DNS查找上的时间。</li>
<li>（4）Initial Connection：TCP握手/重试和建立连接（包括SSL）上花费的时间。</li>
<li>（5）Waiting（TTFB）：等待第一个字节的时间。</li>
<li>（6）Content Download：花费在实际下载资源的时间。</li>
</ul>
<p><img src="/images/性能/15.png" alt="image.png"></p>
<p><strong>审核面板</strong><br>审核面板可以用于监控来自用户角度的性能衡量指标。面板屏幕主要被划分成两部分——前与后。在面板屏幕的前部分，开发者可以指定在哪个环境中衡量性能。如果需要模拟低网速，则可以配置节流区域，当选择“审核运行”按钮时，性能测量就开始了。下面将展示运行结果：</p>
<p><strong>【审核前】</strong><br><img src="/images/性能/16.png" alt="image.png"></p>
<p><strong>【审核后】</strong></p>
<ul>
<li>（1）Metrics：显示性能测量指标中指定的时刻。<ul>
<li>显示FCP，FMP和TTI时间戳。</li>
<li>显示在屏幕快照中的页面加载阶段。</li>
</ul>
</li>
<li>（2）Opportunities：显示可优化的可能资源列表。</li>
<li>（3）Diagostaics：显示其他可能的改进功能以及相应的解决方案。<ul>
<li>请参阅“Critical Request Chains（关键请求链）”以优化关键渲染路径</li>
</ul>
</li>
<li>（4）Passed audits：显示通过的审核和评估的标准</li>
</ul>
<p><img src="/images/性能/17.png" alt="image.png"></p>
<h4 id="网页加载优化"><a href="#网页加载优化" class="headerlink" title="网页加载优化"></a>网页加载优化</h4><p>根据前几章讨论的内容，在接下来的章节我们将会实际讨论如何有效地优化加载流程。网页加载优化将基于关键渲染路径优化。</p>
<h5 id="阻塞资源（CSS，JavaScript）优化"><a href="#阻塞资源（CSS，JavaScript）优化" class="headerlink" title="阻塞资源（CSS，JavaScript）优化"></a>阻塞资源（CSS，JavaScript）优化</h5><p>之前提到过，在浏览器加载阶段，阻塞资源可能会出现，而CSS和JavaScript就是这样的阻塞资源。优化这样的阻塞元素是优化流程的第一步。</p>
<p><strong>CSS优化</strong><br>为了构建渲染树，浏览器需要DOM树和CSSOM树。虽然在解析阶段，DOM树可以在浏览器运行到每个标记时被构建，但是CSSOM树只能在CSS被完全转换时才能构建。因此，如果CSSOM树没有完成构建，渲染树就不能被构建，它就阻塞了渲染。正因如此，CSS被认为是渲染阻塞资源，而为了避免渲染阻塞，CSS通常应当被放在<code>&lt;head&gt;</code>标签中。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"style.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>除此之外，如果一片CSS资源只在特殊情况下被请求，使用media queries（媒体查询）可以阻止阻塞发生。举个例子，如果有一片CSS资源只在打印页面（print.css）时被使用到或者显示器处于纵向模式（portrait.css），在<script>标签中指定media属性可以让它只在特定环境下加载。</p>
<p><strong>优化前（**</strong>没有使用<strong>**media queries）</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"style.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"print.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"portrait.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p> <strong>优化后（使用了media queries）</strong><br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"style.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"print.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">media</span>=<span class="string">"print"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"portrait.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">media</span>=<span class="string">"orientation:portrait"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>同时，从外部导入样式时，避免使用<code>@import</code>。因为浏览器不能并行地加载不同的样式，<code>@import</code>会增加不必要的加载时间。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* foo.css */</span></span><br><span class="line"><span class="keyword">@import</span> url(<span class="string">"bar.css"</span>)</span><br></pre></td></tr></table></figure>
<p>此外，考虑在适当的情况下使用內联样式。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.wrapper</span> &#123;</span></span><br><span class="line">      background-color: red;   </span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>JavaScript优化</strong><br>JavaScript被归类为停止HTML解析的阻塞资源是因为它能够动态操纵DOM树和CSSOM树。当浏览器引擎运行到<script>标签时，它必须执行脚本，而该脚本只能访问到目前为止已构建的DOM。同时，当脚本完成执行时，DOM树的构建会被停止。如果屏幕必须从外部资源下载，构建就必须等待，直到引擎完成下载所有外部资源并执行它们。这就是JavaScript被归为阻塞资源，且通常应当被放在文档底部（在<code>&lt;/body&gt;</code>标签之前）的原因。<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"app.js"</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>有一种方法可以阻止JavaScript和CSS脚本中断HTML解析进程，即使它们被包含在<head>标签中。我们可以通过为<script>标记分配<code>defer</code>或<code>async</code>属性来完成。<code>defer</code>和<code>async</code>属性声明它们将不会尝试更改DOM和CSSOM，因此浏览器不必停止解析进程。然而，请务必注意，这些属性在浏览器兼容性方面会受到限制。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">"https://google.com/analatics.js"</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>使用Chrome DevTools比较阻塞资源优化前后</strong></p>
<p>让我们比较一下Chrome DevTools中使用性能面板来优化阻塞资源使用的前后效果。检查尚未优化的页面加载进程，我们会发现，阻塞资源在解析阶段被执行，当资源脚本完成执行时，HTML再继续解析代码。在下图中，“解析HTML”因解析被终止而发生了两次，但是在优化的页面中，“解析HTML”阶段没有被CSS或JavaScript打断。</p>
<p><strong>【优化前】</strong></p>
<ul>
<li>CSS文件没有在<head/>中加载</li>
<li>JavaScript文件在<head/>中加载</li>
</ul>
<p><img src="/images/性能/18.png" alt="image.png"></p>
<p><strong>【优化后】</strong></p>
<ul>
<li>CSS文件在<head/>中加载</li>
<li>JavaScript紧接着</body>标签前加载</li>
<li>使用了內联样式</li>
</ul>
<p><img src="/images/性能/19.png" alt="image.png"></p>
<h5 id="最小化资源请求数"><a href="#最小化资源请求数" class="headerlink" title="最小化资源请求数"></a>最小化资源请求数</h5><p>页面中包含的资源，比如CSS、Javascript和图片等，只能在将它们请求到服务器并下载后才能被使用。下图显示了使用DevTools的“网络”面板请求一个文件所需的时间。这个文件实际的下载时间为1.03ms，而其他的等待时间（花费的总时间 - 实际下载时间）则是127.45ms。显然仅仅是下载一个文件就要花费很多时间，因此将那些绝对必要的请求的数量降至最低非常重要。这一节将更深入地探讨减少对不同类型资源的请求数量。<br><img src="/images/性能/20.png" alt="image.png"></p>
<p><strong>图片脚本</strong><br>在下面的例子中，如果每个icon使用不同的图片文件，那么对于这个例子，总共要有七个资源请求。图片脚本是一种可以将七个请求减少到一个请求的方法。<br><img src="/images/性能/21.png" alt="image.png"><br>图片脚本将多个图片组合成一个，并使用CSS的<code>background-position</code>属性去只展示整个图片的一部分。在下方CSS中使用的<code>icons-sprite.png</code>是一个精灵图片。使用脚本方法能够让页面加载得更快。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn"</span>&gt;</span>Confirm<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.btn</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(../images/icon-sprite.png);</span><br><span class="line">  <span class="attribute">background-position</span>: <span class="number">10px</span> <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来的截屏比较了使用多个图片和使用一个图片脚本的性能。使用了图片脚本的版本因为减少了资源请求的数量，它的性能明显提高。</p>
<p><strong>优化前（使用多个图片）</strong><br><img src="/images/性能/22.png" alt="image.png"></p>
<p><strong>优化后（使用一个图片脚本）</strong></p>
<p><img src="/images/性能/23.png" alt="image.png"></p>
<h5 id="捆绑CSS和JavaScript"><a href="#捆绑CSS和JavaScript" class="headerlink" title="捆绑CSS和JavaScript"></a>捆绑CSS和JavaScript</h5><p>在将开发人员介绍给模块化开发之前，开发人员必须导入多个外部资源文件。在下方没有被优化的例子中，一共有5个资源请求出现（2个CSS文件请求和3个JavaScript文件请求）。在这个例子中，像webpack这样的捆绑器可以用来减少CSS和JavaScript请求的数量。捆绑器将多个文件组合成一个，这样的文件被称为捆绑文件。（有关模块和捆绑的更多信息，请参见[<a href="">FE指南</a>]捆绑器）</p>
<p><strong>优化前（使用分散资源）</strong><br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"foo.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"bar_baz.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"foo"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">"foo.js"</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">"bar.js"</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">"baz.js"</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>优化后（使用捆绑资源）</strong><br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"bundle.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"foo"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">"bundle.js"</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h5 id="使用內联样式"><a href="#使用內联样式" class="headerlink" title="使用內联样式"></a>使用內联样式</h5><p>我们可以使用<style>标签代替使用<link>标签导入的外部样式表。使用<style>标签去定义样式被称为使用<em>內联样式，</em>它可以减少对外部样式的请求数。然而，內联样式无权访问资源缓存，因此建议仅在CSS始终包含在HTML中时才使用它。</p>
<p><strong>优化前（使用外部样式）</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"bundle.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"foo"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>优化后（使用内部样式）</strong><br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.foo</span> &#123;</span></span><br><span class="line">        background-color: red;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"foo"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h5 id="使用HTML和CSS代替小图像"><a href="#使用HTML和CSS代替小图像" class="headerlink" title="使用HTML和CSS代替小图像"></a>使用HTML和CSS代替小图像</h5><p>如果网页中使用的icon图像数量相对较少，那么也可以将图像包含在HTML和CSS中，而不是使用下载的图像。这可以通过使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/data_URIs">Data URL</a>来完成，它用于将使用外部路径导入的图像转换为Base64 URI。有了Base64 URI，浏览器就不必为了下载特定图像而去发送请求。然而，这种方法与內联样式有着同样的问题，因此，只能在绝对必要的时候使用。</p>
<p><strong>优化前（使用外部图片）</strong><br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.btn</span>&#123;<span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">'../img/arrow_top.png'</span>) no-repeat <span class="number">0</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;img src="../img/arrow_top.png" /&gt;</span><br></pre></td></tr></table></figure>
<p><strong>优化后（图片已被转化成Base64)</strong><br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.btn</span>&#123;<span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAOCAYAAAAbvf3sAAAAAXNSR0IArs4c6QAAAHBJREFUKBVjYBimICwsLAaEsXmPGV0QqnAeUNxfW1v7/tWrVy8hq0HRgKQ4CahoIxDPQ9cE14CseNWqVUtAJoMUo2tiBFkXGRmp9/fv3zNAZhJIMUgMBmAGMTMzmyxfvhzhPJAmmCJ0Gp8cutqhwAcASWgwk+79LiQAAAAASUVORK5CYII='</span>) no-repeat <span class="number">0</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAOCAYAAAAbvf3sAAAAAXNSR0IArs4c6QAAAHBJREFUKBVjYBimICwsLAaEsXmPGV0QqnAeUNxfW1v7/tWrVy8hq0HRgKQ4CahoIxDPQ9cE14CseNWqVUtAJoMUo2tiBFkXGRmp9/fv3zNAZhJIMUgMBmAGMTMzmyxfvhzhPJAmmCJ0Gp8cutqhwAcASWgwk+79LiQAAAAASUVORK5CYII=" /&gt;</span><br></pre></td></tr></table></figure>
<h5 id="缩减资源的大小"><a href="#缩减资源的大小" class="headerlink" title="缩减资源的大小"></a>缩减资源的大小</h5><p>大量资源也会导致网站加载缓慢。建议使用每个文档的压缩版本，以最小化文件大小并优化性能。</p>
<p><strong>消除冗余代码</strong><br>我们以常用的<code>util.js</code>文件为例。冗余代码会让文件变得更大，从而减缓整个加载进程。</p>
<p><strong>优化前（包含了冗余代码）</strong><br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// foo.js</span><br><span class="line">function filter() &#123; ... &#125;</span><br><span class="line">function map() &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">filter</span>();</span><br><span class="line"><span class="selector-tag">map</span>();</span><br></pre></td></tr></table></figure></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// bar.js</span><br><span class="line">function filter() &#123; ... &#125;</span><br><span class="line">function find() &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">filter</span>();</span><br><span class="line"><span class="selector-tag">find</span>();</span><br></pre></td></tr></table></figure>
<p><strong>优化后（消除冗余代码）</strong><br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">// utils.js</span><br><span class="line">export function find() &#123; ... &#125;</span><br><span class="line">export function filter() &#123; ... &#125;</span><br><span class="line">export function map() &#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// foo.js</span><br><span class="line">import &#123;filter, map&#125; from 'utils.js'</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">filter</span>();</span><br><span class="line"><span class="selector-tag">map</span>();</span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// bar.js</span><br><span class="line">import &#123;filter, find&#125; from 'utils.js'</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">filter</span>();</span><br><span class="line"><span class="selector-tag">find</span>();</span><br></pre></td></tr></table></figure>
<p><strong>警惕多合一实用程序库</strong><br>使用Lodash等多合一实用程序库时要格外小心。随意导入整个库会急剧增加JS文件的大小。考虑导入选择的库，只包括绝对必要的部分，避免使用包含大量不必要代码的库。</p>
<p><strong>优化前（引入整个lodash库）</strong><br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">import _ from 'lodash';</span><br><span class="line"></span><br><span class="line">_<span class="selector-class">.array</span>(...);</span><br><span class="line">_<span class="selector-class">.object</span>(...);</span><br></pre></td></tr></table></figure></p>
<p><strong>优化后（选取库的部分引入）</strong><br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">import array from 'lodash/array';</span><br><span class="line">import object from 'lodash/fp/object';</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">array</span>(...);</span><br><span class="line"><span class="selector-tag">object</span>(...);</span><br></pre></td></tr></table></figure></p>
<h5 id="HTML标记优化"><a href="#HTML标记优化" class="headerlink" title="HTML标记优化"></a>HTML标记优化</h5><p>HTML应该使用最少的嵌套标签简单地编写。也建议通过去除空格和注释来丑化代码。推荐的DOM树节点数，最大深度和最大带子节点的父节点数分别小于1,500、32深度和60以下。重要的是要防止DOM树因不必要的标记而变得太大，从而防止HTML文件的总文件大小变得太大。</p>
<p><strong>优化前（不必要的标签，空格，注释）</strong><br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!-- blar blar blar --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">p</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>优化后（简洁的标记）</strong><br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h5 id="使用简洁的CSS选择器"><a href="#使用简洁的CSS选择器" class="headerlink" title="使用简洁的CSS选择器"></a>使用简洁的CSS选择器</h5><p>我们可以通过使用简洁的CSS选择器来优化CSS文件。使用Class代替id，可以帮助开发者们共同解决冗余样式问题。</p>
<p><strong>优化前（不必要的选择器）</strong><br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="css">      <span class="selector-id">#wrapper</span> &#123;</span></span><br><span class="line">        border: 1px solid blue; </span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line"><span class="css">      <span class="selector-id">#wrapper</span> <span class="selector-id">#foo</span> &#123;</span></span><br><span class="line">        color: red;</span><br><span class="line">        font-size: 15px;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line"><span class="css">      <span class="selector-id">#wrapper</span> <span class="selector-id">#bar</span> &#123;</span></span><br><span class="line">        color: red;</span><br><span class="line">        font-size: 15px;</span><br><span class="line">        font-weight: bold;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line"><span class="css">      <span class="selector-id">#wrapper</span> <span class="selector-id">#bar</span> &gt; <span class="selector-tag">span</span> &#123;</span></span><br><span class="line">         color: blue;</span><br><span class="line">         font-weight: normal;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"foo"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"bar"</span>&gt;</span></span><br><span class="line">        javascript <span class="tag">&lt;<span class="name">span</span>&gt;</span>world<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>优化后（简洁的选择器）</strong><br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.wrapper</span> &#123;</span></span><br><span class="line">        border: 1px solid blue; </span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line"><span class="css">      <span class="selector-class">.text</span> &#123;</span></span><br><span class="line">        color: red;</span><br><span class="line">        font-size: 15px;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line"><span class="css">      <span class="selector-class">.strong</span> &#123;</span></span><br><span class="line">        font-weight: bold;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line"><span class="css">      <span class="selector-class">.wrapper</span> <span class="selector-class">.text</span> &#123;</span></span><br><span class="line">        color: blue;</span><br><span class="line">        font-weight: normal;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"text"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"text strong"</span>&gt;</span></span><br><span class="line">        javascript <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"text"</span>&gt;</span>world<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>削减</strong><br>所有的HTML，JavaScript以及CSS可以在作业阶段被压缩，而不必要的空格和注释应当去除或减少。这可以通过webpack插件之类的工具完成。</p>
<h4 id="网页渲染优化"><a href="#网页渲染优化" class="headerlink" title="网页渲染优化"></a>网页渲染优化</h4><p>为了渲染网页，DOM和CSS是必需的。然而，由于JavaScript常被用于生成各种各样的效果和功能，因此认识到JavaScript如何影响渲染性能至关重要。并且，因为JavaScript在浏览器中被用作单线程，渲染性能直接与JavaScript性能相关。渲染时间包括了执行Js的所有时间以及重绘由JavaScript导致的DOM和CSS更改的结果所需的时间。渲染性能优化需要优化花费在这些活动的时间，并且持续向用户提供可视化内容。这一节我们将讨论网页渲染进程的哪些部分会影响到性能，特别是哪块Js代码会影响到渲染性能。</p>
<p><strong>布局优化</strong><br>渲染进程的布局阶段是DOM元素被计算出它们在屏幕上的位置和大小的阶段。如果Js代码改变了DOM或者样式，引擎就必须应用这些样式变更，再次去进行计算并最终得以渲染页面。因为这一过程必须计算每个元素，包括相对于其他元素的每种字体大小），因此需要花费挺长时间。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/139408/1588036499236-15aa8351-f59b-4a95-91ad-0d0b8fb2715c.png#align=left&amp;display=inline&amp;height=60&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=119&amp;originWidth=609&amp;size=53997&amp;status=done&amp;style=none&amp;width=304.5" alt="image.png"><br>布局优化的目的是为了减少请求执行布局的时间，同时确保布局阶段发生得尽可能少。让我们一起来看看如何通过优化Js、HTML、CSS来达到这个目的吧～</p>
<p><strong>JS优化</strong><br>如果js运行需要花费一段时间，渲染性能可能会遭到损害，因为每一帧都要更长的时间来处理。如果JS有非常多的任务需要去完成，花费一点时间也是合情合理，但是当代码简单的却触发不必要的布局时，就会导致出现问题，由此会造成性能下降。因此，减少由DOM和样式产生的变更以避免不必要的布局产生是非常重要的。</p>
<p><strong>强制同步布局优化</strong><br>当一个DOM属性发生改变时，为了更新屏幕可能会发生布局。本来，布局可以异步发生，但是在特殊情况（比如读取一个特定元素的属性值）下可以被强制同步发生。为了检索最新值，浏览器将会强制布局，这被称为强制同步布局。强制同步布局会增加JS的运行时间，因此，一般建议避免使用这种方法。下面列出了可能导致强制同步布局的可能情形，并给出了相应的优化方案。</p>
<p><strong>避免强制同步布局</strong><br>在遍更样式后，尝试使用类似于offsetHeight或者offsetTop这样方法去检索计算值时，强制同步布局就会出现。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">const</span> tabBtn = <span class="built_in">document</span>.getElementById(<span class="string">'tab_btn'</span>);</span><br><span class="line"></span><br><span class="line">  tabBtn.style.fontSize = <span class="string">'24px'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(testBlock.offsetTop); <span class="comment">// Synchronous layout is forced internally immediately before calling the offsetTop</span></span><br><span class="line">  tabBtn.style.margin = <span class="string">'10px'</span>;</span><br><span class="line"><span class="comment">// Layout</span></span><br></pre></td></tr></table></figure></p>
<p>如果在返回值之前，样式变更还没有被应用，函数会检索过时的值并强制执行同步。即使是在最先进的浏览器，强制同步布局也会发生，所以说，不使用任何会产生强制同步布局的代码是非常必要的。</p>
<p><strong>避免布局颠簸</strong><br>如果强制同步布局在一帧內反复发生，性能会显著下降。以下代码遍历了段落[i]，并配置box元素的区域以匹配段落[i]的区域。如果<code>style.width</code>已经配置，又在同一循环內执行<code>box.offsetWidth</code>，那么循环每执行一次，布局就会出现一次。这种现象被称为颠簸。而在循环外检索<code>box</code>元素的高度则可以避免布局颠簸。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resizeAllParagraphs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> box = <span class="built_in">document</span>.getElementById(<span class="string">'box'</span>);</span><br><span class="line">  <span class="keyword">const</span> paragraphs = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.paragraph'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; paragraphs.length; i += <span class="number">1</span>) &#123;</span><br><span class="line">    paragraphs[i].style.width = box.offsetWidth + <span class="string">'px'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Code improved to prevent layout thrashing</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resizeAllParagraphs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> box = <span class="built_in">document</span>.getElementById(<span class="string">'box'</span>);</span><br><span class="line">  <span class="keyword">const</span> paragraphs = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.paragraph'</span>);</span><br><span class="line">  <span class="keyword">const</span> width = box.offsetWidth;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; paragraphs.length; i += <span class="number">1</span>) &#123;</span><br><span class="line">    paragraphs[i].style.width = width + <span class="string">'px'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>操作最低的DOM节点<br>当一个DOM发生变化时，样式计算、布局以及绘制阶段必须全部重新开始。如果这个元素嵌套其他节点的深处，那么引擎就会花更久的时间去找这个节点，导致更新每帧的时间增加。</p>
<p><strong>检查点</strong></p>
<ul>
<li>当DOM树中的一个父节点发生样式变更，也会影响到它的子节点。</li>
<li>而最小化操作范围可以减小布局的范围。</li>
</ul>
<p><strong>限制受影响的元素</strong><br>在某些情况，DOM或者样式的某个变更会影响到旁边的元素，造成邻近元素额外的布局。</p>
<p><strong>检查点</strong></p>
<ul>
<li>父子关系：如果在父节点的高度可变时改变了子节点的高度，布局就会从父节点元素一路向下。这种情况下，如果父节点的高度是固定的，在父节点下面的元素就不会被影响。比如说，如果有多个不同高度的选项卡内容，固定父节点（选项卡高度）高度就可以将作用域减到最小。</li>
<li>具有相同位置的元素：如果多个元素都是内敛放置，如果改变第一个元素的width将会造成其余元素的位置改变。</li>
</ul>
<p><strong>编辑被隐藏的元素</strong><br>如果元素的样式被设置为<code>display:none</code>，即使DOM和样式发生了改变，布局和重绘也不会发生。如果有必要一次性改变多个元素，可以先把它们隐藏，在让它们可见以减少布局的发生。<code>visibility: hidden</code>不会导致重绘，因为它是不可见的；但是由于它确实占了个位子，所以它还是会引发布局的。</p>
<p><strong>检查点</strong></p>
<ul>
<li><code>display:none</code>对性能是有好处的，因为它不会造成任何布局或重绘。</li>
</ul>
<h5 id="HTML和CSS优化"><a href="#HTML和CSS优化" class="headerlink" title="HTML和CSS优化"></a>HTML和CSS优化</h5><p>HTML和CSS对于渲染而言是必不可少的，在渲染阶段，它们分别负责构造DOM树和CSSOM树。DOM树和CSSOM树的变更会引发渲染，并且树越大，计算就越复杂。因此，优化HTML和CSS代码对于渲染性能也是有好处的。</p>
<p><strong>减少CSS规则的数量</strong><br>当元素的class产生变化时，会导致渲染发生；如果CSS很复杂或者其中涉及到很多规则，就会使得计算和布局消耗更多的时间。</p>
<p><strong>检查点</strong></p>
<ul>
<li>规则越少，计算越快，渲染越快。</li>
<li>尽量避免使用复杂的选择器，它们会增加样式计算时间。</li>
</ul>
<p><strong>减小DOM的深度</strong><br>DOM树越深或者DOM树每个节点都有很多子节点，会导致树变得很大。树越大，每次更新所需的计算量就越大。</p>
<p><strong>检查点</strong></p>
<ul>
<li>DOM树越小，计算速度越快。</li>
<li>移除不必要的包装器元素。</li>
</ul>
<h5 id="动画优化"><a href="#动画优化" class="headerlink" title="动画优化"></a>动画优化</h5><p>为了能够更自然地渲染，单帧必须在16ms(60fps)內被处理。也就意味着，JS大约可以处理10ms时间，包括执行布局、绘制等，最多不超过16ms。尽管动画既可以通过JS也可以通过CSS处理，我们还是建议使用CSS而不是原生JS。</p>
<p><strong>使用 requestAnimationFrame()</strong></p>
<p><code>requestAnimationFrame</code> API允许开发者们匹配浏览器的帧率（通常是60fps）去运行动画。特别地，不同于<code>setInterval</code>或<code>setTimeout</code>，这个API在动画开始时被调用，所以，它可以一致且定期地被执行。此外，如果还没有显示页面的当前部分，也不会调用回调函数，因而可以省去执行不必要任务的时间。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Run Animation</span></span><br><span class="line">  requestAnimationFrame(animate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">requestAnimationFrame(animate);</span><br></pre></td></tr></table></figure>
<p><strong>使用CSS动画</strong><br>用JS处理动画很可能导致低性能。相反的是，CSS动画（不要求JS被执行），最适合在浏览器中执行，这是因为基于CSS的动画不会被主进程影响，从而使得动画可以更流畅。如果使用CSS3动画，同时遵守以下规则，可以在浏览器中呈现流畅的动画。</p>
<p><strong>position: absolute</strong><br>动画必须不影响附近的元素。如果<code>position</code>设置成<code>absolute</code>或<code>fixed</code>, 动画旁边的元素就不会被影响。</p>
<p><strong>transform</strong><br>当样式变更引起几何变化时（如高度、宽度、方位等），就会发生布局。受CSS的transform属性影响的元素分为几层，从而限制了元素受到布局和绘画的影响。此外，由于transform只能影响合成阶段，因此可以用于提高使用动画时的渲染速度。如果硬件支持使用GPU，则可以极大地提高性能。例如，在每个帧中都使用诸如left和top之类强制组合的属性，因此最好使用<code>transform: translate()</code>。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: lime;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.animation-item</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute; <span class="comment">/* good */</span></span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">animation</span>: move <span class="number">3s</span> ease infinite;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* bad */</span></span><br><span class="line"><span class="keyword">@keyframes</span> move &#123;</span><br><span class="line">  50% &#123;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">100px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* good */</span></span><br><span class="line"><span class="keyword">@keyframes</span> move &#123;</span><br><span class="line">  50% &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">100px</span>, <span class="number">100px</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>到此为止，本文档介绍了几种优化web应用性能的方案。优化web应用的最佳方案是弄明白浏览器加载和渲染进程，消除期间不必要的步骤。作者希望读者能够对着这篇指南，在各位的项目中应用到这些优化方案，为用户提供更好的服务性能。</p>
</script></p>]]></content>
      <categories>
        <category>性能</category>
      </categories>
      <tags>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title>数据类型</title>
    <url>/2021/02/24/%E5%89%8D%E7%AB%AF/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/js-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="js的数据类型"><a href="#js的数据类型" class="headerlink" title="js的数据类型"></a>js的数据类型</h1><h2 id="一、数据类型："><a href="#一、数据类型：" class="headerlink" title="一、数据类型："></a>一、数据类型：</h2><p>基本数据类型：undefined、Null、Boolean、String、Number、Symbol、Bigint、<br>引用数据类型：Object（Array | RegExp | Data  | Math | Function ）<br>基本类型：存储在栈内存中，被引用或拷贝时，会创建一个完全相等的变量<br>引用类型：存储在堆内存中，存储的时地址，多个引用指向同一个地址</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name:<span class="string">"a"</span>,</span><br><span class="line">    age:<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 参数o传递是的obj的引用地址</span></span><br><span class="line">    o.age = <span class="number">2</span></span><br><span class="line">    o = &#123;</span><br><span class="line">        name:<span class="string">"b"</span>,</span><br><span class="line">        age:<span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o <span class="comment">// return 是给一个新的内存地址</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = change(obj)</span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// &#123; name: 'b', age: 3 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">// &#123; name: 'a', age: 2 &#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="二、数据类型检测"><a href="#二、数据类型检测" class="headerlink" title="二、数据类型检测"></a>二、数据类型检测</h2><h3 id="1-typeof"><a href="#1-typeof" class="headerlink" title="1.typeof"></a>1.typeof</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">1</span>) <span class="comment">// number  NaN也是number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">"1"</span>) <span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>) <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">true</span>) <span class="comment">// boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">undefined</span>) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Symbol</span>()) <span class="comment">// symbol</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> &#123;&#125;) <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> []) <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;) <span class="comment">// function</span></span><br></pre></td></tr></table></figure>
<h3 id="2-instanceof"><a href="#2-instanceof" class="headerlink" title="2. instanceof"></a>2. instanceof</h3><h3 id="3-Object-prototype-toString-call-xxx"><a href="#3-Object-prototype-toString-call-xxx" class="headerlink" title="3. Object.prototype.toString.call(xxx)"></a>3. Object.prototype.toString.call(xxx)</h3>]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>Js</tag>
      </tags>
  </entry>
  <entry>
    <title>this指向问题</title>
    <url>/2020/09/21/%E5%89%8D%E7%AB%AF/this/this/</url>
    <content><![CDATA[<p>我们先来看几个函数调用的场景 </p>
<ol>
<li><p>作为函数调用</p>
</li>
<li><p>作为对象方法调用 </p>
</li>
<li><p>作为构造函数调用 </p>
</li>
<li><p>使用 <code>apply</code> 或 <code>call</code> 调用</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">foo()</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span>.foo()</span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> foo()</span><br></pre></td></tr></table></figure>
<ul>
<li><p>对于直接调用 <code>foo</code> 来说，不管 <code>foo</code> 函数被放在了什么地方，<code>this</code> 一定是 <code>window</code></p>
</li>
<li><p>对于 <code>obj.foo()</code> 来说，我们只需要记住，谁调用了函数，谁就是 <code>this</code>，所以在这个场景下 <code>foo</code> 函数中的 <code>this</code> 就是 <code>obj</code> 对象</p>
</li>
<li><p>对于 <code>new</code> 的方式来说，<code>this</code> 被永远绑定在了 <code>c</code> 上面，不会被任何方式改变 <code>this</code> </p>
</li>
</ul>
<p>说完了以上几种情况，其实很多代码中的 <code>this</code> 应该就没什么问题了，下面让我们看看箭头函数中的 <code>this</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a()()())</span><br></pre></td></tr></table></figure>
<p>首先箭头函数其实是没有 <code>this</code> 的，箭头函数中的 <code>this</code> 只取决包裹箭头函数的第一个普通函数的 <code>this</code>。在这个例子中，因为包裹箭头函数的第一个普通函数是 <code>a</code>，所以此时的 <code>this</code> 是 <code>window</code>。另外对箭头函数使用 <code>bind</code> 这类函数是无效的。</p>
<p>最后种情况也就是 <code>bind</code> 这些改变上下文的 <code>API</code> 了，对于这些函数来说，<code>this</code> 取决于第一个参数，如果第一个参数为空，那么就是 <code>window</code>。对于一个函数多次使用 <code>bind</code>,<code>this</code> 永远由第一次 <code>bind</code> 决定.</p>
<p>多个<code>this</code>指向出现的时候，按优先级来:</p>
<p>首先，<code>new</code> 的方式优先级最高，接下来是 <code>bind</code> 这些函数，然后是 <code>obj.foo()</code> 这种调用方式，最后是 <code>foo</code> 这种调用方式，同时，箭头函数的 <code>this</code> 一旦被绑定，就不会再被任何方式所改变。</p>
<ul>
<li>在函数执行过程中，this一旦被确定，就不可更改了    </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// console.log(this)//此处的this指向window</span></span><br><span class="line">  <span class="keyword">this</span> = obj;<span class="comment">//报错</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn();</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>Js</tag>
      </tags>
  </entry>
  <entry>
    <title>pwa</title>
    <url>/2021/02/24/%E5%89%8D%E7%AB%AF/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/pwa/</url>
    <content><![CDATA[<h1 id="pwa"><a href="#pwa" class="headerlink" title="pwa"></a>pwa</h1><blockquote>
<p>pwa官网文档地址:<a href="https://lavas.baidu.com/pwa/offline-and-cache-loading/service-worker/service-worker-introduction" target="_blank" rel="noopener">https://lavas.baidu.com/pwa/offline-and-cache-loading/service-worker/service-worker-introduction</a></p>
</blockquote>
<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><blockquote>
<p>pwa:不单单是一项技术、 脚手架里边都集成了pwa，核心内容如下</p>
</blockquote>
<h3 id="Web-App-Manifest-将app添加到桌面，具体就是一个json文件改配置就好了，（隐藏地址栏，更行原生app相对于移动端来说）"><a href="#Web-App-Manifest-将app添加到桌面，具体就是一个json文件改配置就好了，（隐藏地址栏，更行原生app相对于移动端来说）" class="headerlink" title="Web App Manifest 将app添加到桌面，具体就是一个json文件改配置就好了，（隐藏地址栏，更行原生app相对于移动端来说）"></a>Web App Manifest 将app添加到桌面，具体就是一个json文件改配置就好了，（隐藏地址栏，更行原生app相对于移动端来说）</h3><pre><code>* 项目根目录像新建一个文件 manifest.json
* 在index.html中引入 manifest.json  
* 在manifest.json 提供配置
* 在https协议下或者http://localhost下访问
</code></pre><h3 id="service-worker-离线跟网速慢的情况下-依旧可访问"><a href="#service-worker-离线跟网速慢的情况下-依旧可访问" class="headerlink" title="service worker 离线跟网速慢的情况下,依旧可访问"></a>service worker 离线跟网速慢的情况下,依旧可访问</h3><pre><code>* service worker特点
    * 一旦被安装，永远存在，除非手动清除
    * 用的时候自动唤醒，不用自动睡眠
    * 可以拦截请求跟返回进行缓存文件，缓存文件可以被网页读取(离线网页也可以读取)
    * 离线内容可以控制（可以选择哪些哪些缓存，哪些不进行缓存）
    * 异步实现、内部大部分都是通过promise实现
    * 必须在https环境下才嗯那个工作

* service worker使用步骤
    * 在window.onload中注册，防止与其他资源竞争
    * navigator对象中内置serviceWorker属性
    * 老版本浏览器中不支持，需要进行兼容处理
    * 注册后返回一个promise对象
</code></pre><h3 id="注册步骤："><a href="#注册步骤：" class="headerlink" title="注册步骤："></a>注册步骤：</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">     <span class="comment">// 1.需要在网页加载完成是注册</span></span></span><br><span class="line"><span class="javascript">     <span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>, () =&gt; &#123;</span></span><br><span class="line"><span class="actionscript">         <span class="comment">// 判断浏览器是否支持</span></span></span><br><span class="line"><span class="actionscript">         <span class="keyword">if</span> (<span class="string">'serviceWorker'</span> <span class="keyword">in</span> navigator) &#123;</span></span><br><span class="line"><span class="actionscript">             <span class="keyword">try</span> &#123;</span></span><br><span class="line">                 navigator.serviceWorker</span><br><span class="line"><span class="actionscript">                     .register(<span class="string">'./sw.js'</span>)</span></span><br><span class="line"><span class="javascript">                     .then(<span class="function"><span class="params">register</span> =&gt;</span> &#123; <span class="comment">// 注册成功</span></span></span><br><span class="line"><span class="javascript">                         <span class="built_in">console</span>.log(register)</span></span><br><span class="line">                     &#125;)</span><br><span class="line"><span class="javascript">                     .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                         <span class="built_in">console</span>.log(err)</span></span><br><span class="line">                     &#125;)</span><br><span class="line"><span class="actionscript">             &#125; <span class="keyword">catch</span> (e) &#123;</span></span><br><span class="line"><span class="javascript">                 <span class="built_in">console</span>.log(<span class="string">'注册失败'</span>)</span></span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;)</span><br><span class="line"> <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注册成功效果图：<br><img src="/images/qd/rcjl/1.png" alt="注册成功效果图"></p>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册成功触发  缓存静态资源</span></span><br><span class="line"><span class="keyword">this</span>.addEventListener(<span class="string">'install'</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'install'</span>, event)</span><br><span class="line">    <span class="comment">// 会让service worker跳过等待、直接进入activate状态</span></span><br><span class="line">    <span class="comment">// this.skipWaiting() </span></span><br><span class="line">    <span class="comment">// 等this.skipWaiting()异步结束才进入activate状态</span></span><br><span class="line">    <span class="comment">// event.waitingUntil()</span></span><br><span class="line">    event.waitingUntil(<span class="keyword">this</span>.skipWaiting())</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 激活触发 删除旧的缓存资源</span></span><br><span class="line"><span class="keyword">this</span>.addEventListener(<span class="string">'activate'</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'activate'</span>, event)</span><br><span class="line">    <span class="comment">// 立即执行、不需要等到下次刷新页面</span></span><br><span class="line">    <span class="comment">// this.clients.claim()</span></span><br><span class="line">    event.waitingUntil(<span class="keyword">this</span>.clients.claim())</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 发送请求时触发 操作缓存，读取网络资源</span></span><br><span class="line"><span class="keyword">this</span>.addEventListener(<span class="string">'fetch'</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fetch'</span>, event)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再次刷新页面、安装跟激活只会执行一次</span></span><br><span class="line"><span class="comment">// 只要install内容改变，再次刷新页面、install会中再次触发、但是activate不会触发</span></span><br><span class="line"><span class="comment">// activate只在install之后触发，改变install后不触发，是因为service worker已经有一个activate了，只有当前的activate停止后，新的activate才会执行</span></span><br><span class="line"><span class="comment">// this.skipWaiting()方法跳过等待activate，返回一个promise</span></span><br><span class="line"><span class="comment">// event.waitingUntil(),接受一个promise参数，改方法会在promise结束之后结束当前生命周期，防止浏览器在异步操作之前就停止了生命周期</span></span><br><span class="line"><span class="comment">// service worker激活之后，会在下一次刷新页面的时候才会生效，this.clients.claim()会立即生效</span></span><br></pre></td></tr></table></figure>
<p>第一次执行效果图：<br><img src="/images/qd/rcjl/2.png" alt="第一次执行效果图"></p>
<p>基础使用操作：<br><img src="/images/qd/rcjl/3.png" alt="基础使用操作图"></p>
<h3 id="cache-storage-缓存"><a href="#cache-storage-缓存" class="headerlink" title="cache storage 缓存"></a>cache storage 缓存</h3><h4 id="cacheStorage-是专门配合service-worker来实现资源缓存的"><a href="#cacheStorage-是专门配合service-worker来实现资源缓存的" class="headerlink" title="cacheStorage 是专门配合service worker来实现资源缓存的"></a>cacheStorage 是专门配合service worker来实现资源缓存的</h4><h4 id="caches-api"><a href="#caches-api" class="headerlink" title="caches api"></a>caches api</h4><ul>
<li>chches.open(cacheName).then(function(cache){}),用于打开缓存，并且返回对应cacheName的cache对象的</li>
<li>caches.keys() 查找所有对应的缓存的key</li>
<li>caches.delete(key) 根据key删除对应的缓存</li>
</ul>
<h4 id="cache-对象的常用操作"><a href="#cache-对象的常用操作" class="headerlink" title="cache 对象的常用操作"></a>cache 对象的常用操作</h4><ul>
<li>cache 接口为缓存的request、response对象提供存储机制</li>
<li>cache.put(req,res) 把请求当作 key，并且把对应的响应存储起来</li>
<li>cache.add(url) 根据 url 发起请求，并且把对应的响应结果存储起来</li>
<li>cache.addAll(urls) 住区一个 url 数组，并且把对应的响应结果都存储起来</li>
<li>cache.match(req) 获取 req 对应的 response</li>
</ul>
<p>注释：cache 对象更多方法：<a href="https://developer.mozilla.org/en-US/docs/Web/API/CacheStorage" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/API/CacheStorage</a></p>
<h4 id="cache-demo-实现本地静态资源离线状态下依旧可以加载"><a href="#cache-demo-实现本地静态资源离线状态下依旧可以加载" class="headerlink" title="cache demo 实现本地静态资源离线状态下依旧可以加载"></a>cache demo 实现本地静态资源离线状态下依旧可以加载</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"./index.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span> hello world <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./index.png"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 注册serviceWorker</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>, <span class="keyword">async</span> () =&gt; &#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">if</span> (<span class="string">'serviceWorker'</span> <span class="keyword">in</span> navigator) &#123; <span class="comment">// 判断浏览器是否兼容</span></span></span><br><span class="line"><span class="actionscript">                <span class="keyword">try</span> &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">const</span> register = <span class="keyword">await</span> navigator.serviceWorker.register(<span class="string">'./sw.js'</span>)</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(<span class="string">'注册成功'</span>, register)</span></span><br><span class="line"><span class="actionscript">                &#125; <span class="keyword">catch</span> (e) &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(<span class="string">'注册失败'</span>)</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="comment">// cacheStorage 是专门配合service worker来实现资源缓存的</span></span></span><br><span class="line"><span class="actionscript">        <span class="comment">// caches api </span></span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 1.chches.open(cacheName).then(function(cache)&#123;&#125;),用于打开缓存，并且返回对应cacheName的cache对象的promise.</span></span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 2.caches.keys() 查找所有对应的缓存的key</span></span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 3.caches.delete(key) 根据key删除对应的缓存</span></span></span><br><span class="line">        </span><br><span class="line"><span class="actionscript">        <span class="comment">// cache 对象的常用操作 </span></span></span><br><span class="line"><span class="actionscript">            <span class="comment">// cache 接口为缓存的request、response对象提供存储机制</span></span></span><br><span class="line"><span class="actionscript">            <span class="comment">// cache.put(req,res) 把请求当作 key，并且把对应的响应存储起来</span></span></span><br><span class="line"><span class="actionscript">            <span class="comment">// cache.add(url) 根据 url 发起请求，并且把对应的响应结果存储起来</span></span></span><br><span class="line"><span class="actionscript">            <span class="comment">// cache.addAll(urls) 住区一个 url 数组，并且把对应的响应结果都存储起来</span></span></span><br><span class="line"><span class="actionscript">            <span class="comment">// cache.match(req) 获取 req 对应的 response</span></span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该文件主要是缓存内容</span></span><br><span class="line"><span class="keyword">const</span> CACHE_NAME = <span class="string">'cache_version1'</span></span><br><span class="line"><span class="keyword">this</span>.addEventListener(<span class="string">'install'</span>, <span class="keyword">async</span> <span class="keyword">event</span> =&gt; &#123;</span><br><span class="line">    <span class="comment">// 开启一个cache，获得一个cache对象</span></span><br><span class="line">    <span class="keyword">const</span> cache = <span class="keyword">await</span> caches.open(CACHE_NAME)</span><br><span class="line">    <span class="comment">// cache对象存储资源</span></span><br><span class="line">    <span class="keyword">await</span> cache.addAll([</span><br><span class="line">        <span class="string">'/'</span>,</span><br><span class="line">        <span class="string">'index.css'</span>,</span><br><span class="line">        <span class="string">'index.json'</span>,</span><br><span class="line">        <span class="string">'index.png'</span></span><br><span class="line">    ])</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">this</span>.skipWaiting()</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 激活触发 删除旧的缓存资源</span></span><br><span class="line"><span class="keyword">this</span>.addEventListener(<span class="string">'activate'</span>, <span class="keyword">async</span> <span class="keyword">event</span> =&gt; &#123;</span><br><span class="line">    <span class="comment">// 获取所有资源</span></span><br><span class="line">    <span class="keyword">let</span> keys = <span class="keyword">await</span> caches.keys()</span><br><span class="line">    <span class="comment">// 清楚所有旧的缓存</span></span><br><span class="line">    keys.forEach(key =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (key !== CACHE_NAME) &#123;</span><br><span class="line">            caches.delete(key)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">this</span>.clients.claim()</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 发送请求时触发 操作缓存，读取网络资源</span></span><br><span class="line"><span class="keyword">this</span>.addEventListener(<span class="string">'fetch'</span>, <span class="keyword">event</span> =&gt; &#123;</span><br><span class="line">    <span class="comment">// 判断资源是否可以请求成功，如果成功那就响应成功的结果，否则响应缓存资源</span></span><br><span class="line">    <span class="keyword">const</span> req = <span class="keyword">event</span>.request</span><br><span class="line">    <span class="comment">// 浏览器响应</span></span><br><span class="line">    <span class="keyword">event</span>.respondWith(networkFirst(req))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 网络优先</span></span><br><span class="line"><span class="function"><span class="keyword">async</span> function <span class="title">networkFirst</span>(<span class="params">req</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123; <span class="comment">//有网络</span></span><br><span class="line">        <span class="keyword">const</span> fresh = <span class="keyword">await</span> fetch(req)</span><br><span class="line">        <span class="keyword">return</span> fresh</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123; <span class="comment">//读取缓存</span></span><br><span class="line">        <span class="keyword">const</span> cache = <span class="keyword">await</span> caches.open(CACHE_NAME)</span><br><span class="line">        <span class="keyword">const</span> cache_conent = <span class="keyword">await</span> cache.match(req)</span><br><span class="line">        <span class="keyword">return</span> cache_conent</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有网时：<br><img src="/images/qd/rcjl/4.png" alt="有网时图片"></p>
<p>断网时：<br><img src="/images/qd/rcjl/5.png" alt="有网时图片"></p>
<h4 id="存储缓存的时-index-html不能直接写，要写成-否则会报错，浏览器默认的index-html的地址是"><a href="#存储缓存的时-index-html不能直接写，要写成-否则会报错，浏览器默认的index-html的地址是" class="headerlink" title="存储缓存的时/index.html不能直接写，要写成/否则会报错，浏览器默认的index.html的地址是/"></a>存储缓存的时/index.html不能直接写，要写成/否则会报错，浏览器默认的index.html的地址是/</h4><p><img src="/images/qd/rcjl/6.png" alt="效果图"></p>
<h3 id="Notification-：用于通知"><a href="#Notification-：用于通知" class="headerlink" title="Notification ：用于通知"></a>Notification ：用于通知</h3><h4 id="Notification-permission-获取当前通知权限"><a href="#Notification-permission-获取当前通知权限" class="headerlink" title="Notification.permission 获取当前通知权限"></a>Notification.permission 获取当前通知权限</h4><ul>
<li>default  默认：询问</li>
<li>denied  拒绝，如果拒绝了，无法请求授权，无法弹窗提醒</li>
<li>granted  同意</li>
</ul>
<h4 id="Notification-requestPermission-请求授权"><a href="#Notification-requestPermission-请求授权" class="headerlink" title="Notification.requestPermission 请求授权"></a>Notification.requestPermission 请求授权</h4><h4 id="new-Notification-‘title’-body-’提示内容’-通知的使用方法"><a href="#new-Notification-‘title’-body-’提示内容’-通知的使用方法" class="headerlink" title="new Notification(‘title’,{body:’提示内容’}) 通知的使用方法"></a>new Notification(‘title’,{body:’提示内容’}) 通知的使用方法</h4><h2 id="二、特点"><a href="#二、特点" class="headerlink" title="二、特点"></a>二、特点</h2><blockquote>
<p>快速、黏性（客户流失少）</p>
</blockquote>
<h2 id="三、基础"><a href="#三、基础" class="headerlink" title="三、基础"></a>三、基础</h2><blockquote>
<p>pwa都是基于https环境，或者localhst</p>
</blockquote>
]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>Js</tag>
      </tags>
  </entry>
  <entry>
    <title>Date相关方法</title>
    <url>/2020/09/21/%E5%89%8D%E7%AB%AF/%E6%9D%82%E8%AE%B0/Date%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">date</span> = <span class="literal">new</span> <span class="built_in">Date</span>()<span class="comment">// Fri Aug 09 2019 09:03:56 GMT+0800 (中国标准时间)</span></span><br><span class="line"><span class="keyword">let</span> time = <span class="built_in">date</span>.getTime()<span class="comment">//时间戳  1573522967056</span></span><br><span class="line"><span class="keyword">let</span> year = <span class="built_in">date</span>.getFullYear();<span class="comment">//年</span></span><br><span class="line"><span class="keyword">let</span> month = <span class="built_in">date</span>.getMonth()+<span class="number">1</span>;<span class="comment">//月  此处注意月份是从0开始的</span></span><br><span class="line"><span class="keyword">let</span> day = <span class="built_in">date</span>.getDate();<span class="comment">//日    0--31</span></span><br><span class="line"><span class="keyword">let</span> week = <span class="built_in">date</span>.getDay();<span class="comment">//周几  0--6</span></span><br><span class="line"><span class="keyword">let</span> hours = <span class="built_in">date</span>.getHours();<span class="comment">//小时</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">min</span> = <span class="built_in">date</span>.getMinutes();<span class="comment">//分钟</span></span><br><span class="line"><span class="keyword">let</span> sec = <span class="built_in">date</span>.getSeconds();<span class="comment">//秒</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="built_in">date</span>.toString()     <span class="comment">//Fri Aug 09 2019 09:12:38 GMT+0800 (中国标准时间)   把 Date 对象转换为字符串。</span></span><br><span class="line"><span class="keyword">let</span> str1 = <span class="built_in">date</span>.toTimeString()  <span class="comment">//09:12:38 GMT+0800 (中国标准时间)   把 Date 对象的时间部分转换为字符串。</span></span><br><span class="line"><span class="keyword">let</span> str2 = <span class="built_in">date</span>.toDateString()  <span class="comment">//Fri Aug 09 2019  	把 Date 对象的日期部分转换为字符串。</span></span><br><span class="line"><span class="keyword">let</span> srt3 = <span class="built_in">date</span>.toLocaleString()  <span class="comment">//2019/8/9 上午9:13:26   根据本地时间格式，把 Date 对象转换为字符串。</span></span><br><span class="line"><span class="keyword">let</span> str4 = <span class="built_in">date</span>.toLocaleTimeString()  <span class="comment">//上午9:17:38   根据本地时间格式，把 Date 对象的时间部分转换为字符串。</span></span><br><span class="line"><span class="keyword">let</span> str5 = <span class="built_in">date</span>.toLocaleDateString()  <span class="comment">//2019/8/9   根据本地时间格式，把 Date 对象的日期部分转换为字符串。</span></span><br><span class="line"><span class="keyword">let</span> str6 = <span class="built_in">date</span>.valueOf()  <span class="comment">//1565313556945   根据世界时返回 1970 年 1 月 1 日 到指定日期的毫秒数</span></span><br><span class="line"><span class="keyword">let</span> str7 = <span class="literal">new</span> <span class="built_in">Date</span>(<span class="number">1567267200000</span>)  <span class="comment">//时间戳转为标准时间格式</span></span><br><span class="line"><span class="keyword">let</span> str8 = <span class="literal">new</span> <span class="built_in">Date</span>(<span class="string">'2019-8-2'</span>).getTime()  <span class="comment">//1564675200000  日期格式转换为时间戳  2018-8、2019-8-8、2019-4/5、2019-04-05、</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>Js</tag>
      </tags>
  </entry>
  <entry>
    <title>Less</title>
    <url>/2020/09/21/%E5%89%8D%E7%AB%AF/%E6%9D%82%E8%AE%B0/Less/</url>
    <content><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>首先电脑上需要安装了node</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span> -g <span class="keyword">less</span></span><br></pre></td></tr></table></figure>
<h1 id="常用的语法"><a href="#常用的语法" class="headerlink" title="常用的语法"></a>常用的语法</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@width:</span> <span class="number">10px</span>;</span><br><span class="line"><span class="variable">@height:</span> <span class="variable">@width</span> + <span class="number">10px</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#header</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="variable">@width</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="variable">@height</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译为：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#header</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="混合"><a href="#混合" class="headerlink" title="混合"></a>混合</h2><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">.<span class="class">bordered </span>&#123;</span><br><span class="line"><span class="symbol">  border:</span> dotted <span class="number">1</span>px black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.post <span class="class">a </span>&#123;</span><br><span class="line"><span class="symbol">  color:</span> red;</span><br><span class="line">  .bordered();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>.bordered</code>该类的属性现在将出现在<code>post a</code>上。</p>
<h2 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h2><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#header</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: black;</span><br><span class="line">  <span class="selector-class">.nav</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.logo</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译后：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#header</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: black;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#header</span> <span class="selector-class">.nav</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#header</span> <span class="selector-class">.logo</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与伪类放在一起(此处的<code>&amp;</code>符号代表当前的选择器父级，父级是指它所有的父级元素，即包括<code>clearfix</code>父级的父级)解决浮动的方法。</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  zoom: <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  &amp;<span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">" "</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">    <span class="attribute">visibility</span>: hidden;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><p>数学运算<code>+, -, *, /</code> 可在任何数字，颜色或变量中应用。可能的话，数学运算会把单位考虑进去，在加、减或者比较之前转化成数字。结果中会使用运算表达式中最左边明确规定的单位类型。如果转换不能实现或者没有意义，单位会被忽略。不能转换的例子：<code>px to cm</code> or <code>rad to %</code>.</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@conversion-1:</span> <span class="number">5cm</span> + <span class="number">1cm</span>; <span class="comment">// 6cm</span></span><br><span class="line"><span class="variable">@conversion-2:</span> <span class="number">5</span> - <span class="number">3cm</span> - <span class="number">5mm</span>;  <span class="comment">// 1.5cm，第一个5没有单位，结果使用的是最左边第一次出现的单位cm，5mm也被转换为0.5cm来参与运算</span></span><br><span class="line"><span class="variable">@base:</span> <span class="number">5%</span>;</span><br><span class="line"><span class="variable">@filler:</span> <span class="variable">@base</span> * <span class="number">2</span>;  <span class="comment">// 10%</span></span><br><span class="line"><span class="variable">@base1:</span> <span class="number">2cm</span> * <span class="number">3mm</span>;  <span class="comment">//6cm</span></span><br></pre></td></tr></table></figure>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 一个块注释</span></span><br><span class="line"><span class="comment"> * style comment! */</span></span><br><span class="line"><span class="variable">@var:</span> red;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这一行被注释掉了！</span></span><br><span class="line"><span class="variable">@var:</span> white;</span><br></pre></td></tr></table></figure>
<h2 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h2><p>“导入”的工作方式和你预期的一样。你可以导入一个 <code>.less</code> 文件，此文件中的所有变量就可以全部使用了。如果导入的文件是 <code>.less</code> 扩展名，则可以将扩展名省略掉：<br><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">"library"</span>; <span class="comment">// library.less</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">"typo.css"</span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p><code>Less</code>中的<code>Scope</code>与<code>CSS</code>的范围非常相似。变量和<code>mixin</code>首先在本地查找，如果找不到它们，它将继承自“父”范围。<br><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@var:</span> red;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#page</span> &#123;</span><br><span class="line">  <span class="variable">@var:</span> white;</span><br><span class="line">  <span class="selector-id">#header</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">@var</span>; <span class="comment">// white</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>与CSS自定义属性一样，<code>mixin</code>和变量定义不必放在引用它们的行之前。因此，以下<code>Less</code>代码与前一个示例相同：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@var:</span> red;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#page</span> &#123;</span><br><span class="line">  <span class="selector-id">#header</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">@var</span>; <span class="comment">// white</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable">@var:</span> white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#colors</span>() &#123;</span><br><span class="line">  <span class="attribute">primary</span>: blue;</span><br><span class="line">  <span class="attribute">secondary</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.button</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#c</span>olors[primary];</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#c</span>olors[secondary];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译后：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.button</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>记录篇</category>
      </categories>
      <tags>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title>自测清单</title>
    <url>/2021/02/24/%E5%89%8D%E7%AB%AF/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/%E8%87%AA%E6%B5%8B%E6%B8%85%E5%8D%95/</url>
    <content><![CDATA[<h1 id="自测清单-Object"><a href="#自测清单-Object" class="headerlink" title="自测清单(Object)"></a>自测清单(Object)</h1><h2 id="一、对象"><a href="#一、对象" class="headerlink" title="一、对象"></a>一、对象</h2><h3 id="1-1-对象的键为变量时，使用-key-取值"><a href="#1-1-对象的键为变量时，使用-key-取值" class="headerlink" title="1.1 对象的键为变量时，使用[key]取值"></a>1.1 对象的键为变量时，使用[key]取值</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> key = <span class="string">"name"</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [key] : <span class="string">"hjj"</span></span><br><span class="line">&#125;</span><br><span class="line">obj[key]; <span class="comment">// hjj</span></span><br><span class="line">obj.key; <span class="comment">//报错</span></span><br></pre></td></tr></table></figure>
<h3 id="1-2-对象的key可以是表达式"><a href="#1-2-对象的key可以是表达式" class="headerlink" title="1.2 对象的key可以是表达式"></a>1.2 对象的key可以是表达式</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> key = <span class="string">"my"</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">	[key + <span class="string">"name"</span>]: <span class="string">"hjj"</span></span><br><span class="line">&#125;</span><br><span class="line">obj[myname] <span class="comment">// hjj</span></span><br><span class="line">obj[key + <span class="string">"name"</span>] <span class="comment">// hjj</span></span><br></pre></td></tr></table></figure>
<h3 id="1-3-对象属性简写"><a href="#1-3-对象属性简写" class="headerlink" title="1.3 对象属性简写"></a>1.3 对象属性简写</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> getName = <span class="function"><span class="keyword">function</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">  	name: name</span><br><span class="line">    age:<span class="string">"18"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以简写为</span></span><br><span class="line"><span class="keyword">let</span> getName = <span class="function"><span class="keyword">function</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">  	name,</span><br><span class="line">    age: <span class="string">"18"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getName() <span class="comment">// &#123;name:undefined, age: "18"&#125;</span></span><br><span class="line">getName(<span class="number">2</span>) <span class="comment">// &#123;name:2, age: "18"&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="1-4-对象属性是否存在检测"><a href="#1-4-对象属性是否存在检测" class="headerlink" title="1.4 对象属性是否存在检测"></a>1.4 对象属性是否存在检测</h3><h4 id="1-4-1-使用-in-关键自检测，会检测自有属性跟继承属性"><a href="#1-4-1-使用-in-关键自检测，会检测自有属性跟继承属性" class="headerlink" title="1.4.1 使用 in 关键自检测，会检测自有属性跟继承属性"></a>1.4.1 使用 in 关键自检测，会检测自有属性跟继承属性</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">	name: <span class="string">"hjj"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="string">"name"</span> <span class="keyword">in</span> obj <span class="comment">// true  自有</span></span><br><span class="line"><span class="string">"age"</span> <span class="keyword">in</span> obj <span class="comment">// false</span></span><br><span class="line"><span class="string">"toString"</span> <span class="keyword">in</span> obj <span class="comment">// true 继承</span></span><br></pre></td></tr></table></figure>
<h4 id="1-4-2-使用-hasOwnProperty-方法检测，只检测自有属性，继承会返回false"><a href="#1-4-2-使用-hasOwnProperty-方法检测，只检测自有属性，继承会返回false" class="headerlink" title="1.4.2 使用 hasOwnProperty() 方法检测，只检测自有属性，继承会返回false"></a>1.4.2 使用 hasOwnProperty() 方法检测，只检测自有属性，继承会返回false</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">	name: <span class="string">"hjj"</span>,</span><br><span class="line">  age: <span class="literal">null</span>,</span><br><span class="line">  sex: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line">obj.hasOwnProperty(<span class="string">"name"</span>) <span class="comment">// true</span></span><br><span class="line">obj.hasOwnProperty(<span class="string">"age"</span>) <span class="comment">// true</span></span><br><span class="line">obj.hasOwnProperty(<span class="string">"sex"</span>) <span class="comment">// true</span></span><br><span class="line">obj.hasOwnProperty(<span class="string">"haha"</span>) <span class="comment">// false</span></span><br><span class="line">obj.hasOwnProperty(<span class="string">"toString"</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h4 id="1-4-3-使用-undefined-检测，检测自有属性跟继承属性，但是对于值为undefined的属性-返回false"><a href="#1-4-3-使用-undefined-检测，检测自有属性跟继承属性，但是对于值为undefined的属性-返回false" class="headerlink" title="1.4.3 使用 undefined 检测，检测自有属性跟继承属性，但是对于值为undefined的属性  返回false"></a>1.4.3 使用 undefined 检测，检测自有属性跟继承属性，但是对于值为undefined的属性  返回false</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">	name: <span class="string">"hjj"</span>,</span><br><span class="line">  age: <span class="literal">null</span>,</span><br><span class="line">  sex: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line">obj.name !== <span class="literal">undefined</span> <span class="comment">// true</span></span><br><span class="line">obj.age !== <span class="literal">undefined</span> <span class="comment">// true</span></span><br><span class="line">obj.sex !== <span class="literal">undefined</span> <span class="comment">// false</span></span><br><span class="line">obj.toString !== <span class="literal">undefined</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">null</span> === <span class="literal">undefined</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h4 id="1-4-4-使用条件语句判断"><a href="#1-4-4-使用条件语句判断" class="headerlink" title="1.4.4 使用条件语句判断"></a>1.4.4 使用条件语句判断</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">name</span>: <span class="string">"hjj"</span>&#125;</span><br><span class="line"><span class="keyword">if</span> (obj.name)&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"存在"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="literal">undefined</span>, <span class="literal">null</span>, <span class="string">""</span>, <span class="number">0</span>, <span class="literal">false</span>, <span class="literal">NaN</span>,都会输出存在</span><br></pre></td></tr></table></figure>
<h3 id="1-5-对象循环"><a href="#1-5-对象循环" class="headerlink" title="1.5 对象循环"></a>1.5 对象循环</h3><h4 id="1-5-1-for-…-in"><a href="#1-5-1-for-…-in" class="headerlink" title="1.5.1 for … in"></a>1.5.1 for … in</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">	name: <span class="string">"hjj"</span>,</span><br><span class="line">  age: <span class="string">"18"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>	(key <span class="keyword">in</span> obj)	&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(key, obj[key])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// name, hjj</span></span><br><span class="line"><span class="comment">// age, "18"</span></span><br></pre></td></tr></table></figure>
<h4 id="1-5-2-es7新增方法"><a href="#1-5-2-es7新增方法" class="headerlink" title="1.5.2 es7新增方法"></a>1.5.2 es7新增方法</h4><p><code>Object.values()</code>和<code>Object.entries()</code>与之前的<code>Object.keys()类似，返回数组类型。</code><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">	name:<span class="string">"123"</span>, </span><br><span class="line">  age:<span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.values(obj)  <span class="comment">// ["123", 18]</span></span><br><span class="line"><span class="built_in">Object</span>.entries(obj) <span class="comment">// [["name", "123"],["age", 18]]</span></span><br><span class="line"><span class="built_in">Object</span>.keys(obj)    <span class="comment">// ["name", "age"]</span></span><br></pre></td></tr></table></figure></p>
<h4 id="1-5-3-Object-getOwnPropertyNames-Obj"><a href="#1-5-3-Object-getOwnPropertyNames-Obj" class="headerlink" title="1.5.3 Object.getOwnPropertyNames(Obj)"></a>1.5.3 Object.getOwnPropertyNames(Obj)</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123; <span class="attr">name</span>: <span class="string">"leo"</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(user); <span class="comment">// ["name", "age"]</span></span><br></pre></td></tr></table></figure>
<h2 id="二、对象拷贝"><a href="#二、对象拷贝" class="headerlink" title="二、对象拷贝"></a>二、对象拷贝</h2><h3 id="1-赋值操作"><a href="#1-赋值操作" class="headerlink" title="1. 赋值操作"></a>1. 赋值操作</h3><ul>
<li>基本类型：基本的值存储在栈内存中，固定大小。<ul>
<li>常见包括：undefined、null、Boolean、String、Number、Symbol</li>
</ul>
</li>
<li>引用类型：引用类型的值存储在堆内存中。而栈内存中存储的是对象的变量标识符以及对象的引用地址，当解释器寻找引用值时，会先检索栈中的指针，然后在从堆中获取实体。<ul>
<li>常见实体：Object、Array、Date、Function、RegExp等</li>
</ul>
</li>
</ul>
<h3 id="2-对象比较"><a href="#2-对象比较" class="headerlink" title="2. 对象比较"></a>2. 对象比较</h3><ul>
<li><p>当两个变量引用的是同一个对象时，他们无论是 <code>==</code> 还是 <code>===</code> 都会返回 <code>true</code> </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">name</span>:<span class="string">"hjj"</span>&#125;</span><br><span class="line"><span class="keyword">let</span> obj1 = obj</span><br><span class="line">obj == obj1 <span class="comment">//true</span></span><br><span class="line">obj === obj1 <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>但如果两个变量是空对象 <code>{}</code> ，则不相等</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = obj</span><br><span class="line">obj == obj1 <span class="comment">// false</span></span><br><span class="line">obj == obj2 <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-浅拷贝"><a href="#3-浅拷贝" class="headerlink" title="3.浅拷贝"></a>3.浅拷贝</h3><h4 id="3-1Object-assign-浅拷贝"><a href="#3-1Object-assign-浅拷贝" class="headerlink" title="3.1Object.assign() 浅拷贝"></a>3.1<code>Object.assign()</code> 浅拷贝</h4><ul>
<li>只拷贝源对象的自身属性（不拷贝继承属性）</li>
<li>不拷贝对象不可枚举的属性</li>
<li>属性名为 <code>Symbol</code> 值得属性，可以被拷贝</li>
<li><code>undefined</code> 和 <code>null</code> 无法转成对象，他们不能作为 <code>Object.assign</code> 参数，但是可以作为源对象被拷贝。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  name: <span class="string">"hh"</span>, </span><br><span class="line">  age: <span class="number">19</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">"字符串"</span></span><br><span class="line"><span class="built_in">Object</span>.assign(obj) <span class="comment">// &#123;name: "hh", age: 19&#125;</span></span><br><span class="line"><span class="built_in">Object</span>.assign(str) <span class="comment">// String &#123;"字符串"&#125;</span></span><br><span class="line"><span class="built_in">Object</span>.assign(<span class="literal">null</span>) <span class="comment">// Uncaught TypeError: Cannot convert undefined or null to object</span></span><br><span class="line"><span class="built_in">Object</span>.assign(<span class="literal">null</span>) <span class="comment">// Uncaught TypeError: Cannot convert undefined or null to object</span></span><br><span class="line"><span class="built_in">Object</span>.assign([],<span class="literal">undefined</span>) <span class="comment">// []</span></span><br><span class="line"><span class="built_in">Object</span>.assign([],<span class="literal">null</span>) <span class="comment">// []</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-2-Array-prototype-slice"><a href="#3-2-Array-prototype-slice" class="headerlink" title="3.2  Array.prototype.slice()"></a>3.2  Array.prototype.slice()</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = [<span class="string">"obj"</span>, &#123;<span class="attr">name</span>: <span class="string">"obj_name"</span>&#125;];</span><br><span class="line"><span class="keyword">let</span> newobj  = <span class="built_in">Array</span>.prototype.slice.call(obj);</span><br><span class="line">newobj[<span class="number">0</span>] = <span class="string">"new_obj"</span>;</span><br><span class="line">newobj[<span class="number">1</span>][<span class="string">"name"</span>] = <span class="string">"new_obj_name"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(newobj[<span class="number">0</span>]);          <span class="comment">// "new_obj"  ⚠️ 差异！</span></span><br><span class="line"><span class="built_in">console</span>.log(obj[<span class="number">0</span>]);         <span class="comment">// "obj"        ⚠️ 差异！</span></span><br><span class="line"><span class="built_in">console</span>.log(newobj[<span class="number">1</span>][<span class="string">"name"</span>]);  <span class="comment">// "new_obj_name"</span></span><br><span class="line"><span class="built_in">console</span>.log(obj[<span class="number">1</span>][<span class="string">"name"</span>]); <span class="comment">// "new_obj_name"</span></span><br></pre></td></tr></table></figure>
<h4 id="3-3-Array-prototype-concat"><a href="#3-3-Array-prototype-concat" class="headerlink" title="3.3  Array.prototype.concat()"></a>3.3  Array.prototype.concat()</h4><h4 id="3-4-扩展运算符-…"><a href="#3-4-扩展运算符-…" class="headerlink" title="3.4 扩展运算符 …"></a>3.4 扩展运算符 …</h4><p>浅拷贝对于值为对象的属性无法拷贝成两个独立的对象，但是基本类型的值是可以的</p>
<h4 id="3-5-浅拷贝实现原理"><a href="#3-5-浅拷贝实现原理" class="headerlink" title="3.5 浅拷贝实现原理"></a>3.5 浅拷贝实现原理</h4><p>原理：新的对象复制也有对象的属性的值，基本类型直接复制值，引用类型复制引用。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span> (<span class="params">source</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">let</span> target = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> source)&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(source, key)) &#123;</span><br><span class="line">       target[key] = source[key]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="4-深拷贝"><a href="#4-深拷贝" class="headerlink" title="4. 深拷贝"></a>4. 深拷贝</h3><p>理解：深拷贝其实就是复制变量值，对于引用类型的则递归至基本类型，之后再复制。最终的结果就是新对象跟源对象是两个独立的对象，修改不会互相影响。</p>
<h4 id="4-1-JSON-parse-JSON-stringify"><a href="#4-1-JSON-parse-JSON-stringify" class="headerlink" title="4.1 JSON.parse(JSON.stringify())"></a>4.1 JSON.parse(JSON.stringify())</h4><p>实现原理：就是把一个对象序列化转换成一个json字符串，将对象以字符串的形式保存在磁盘上，然后再使用 <code>JSON.parse()</code> 反序列化转换成一个新的对象。<br>缺点：</p>
<ul>
<li>拷贝的对象的值中如果有函数， <code>undefined</code> ， <code>symbol</code> 则经过 <code>JSON.stringify()</code> `序列化后的JSON字符串中这个键值对会消失；</li>
<li>无法拷贝不可枚举的属性，无法拷贝对象的原型链；</li>
<li>拷贝 <code>Date</code> 引用类型会变成字符串；</li>
<li>拷贝 <code>RegExp</code> 引用类型会变成空对象；</li>
<li>对象中含有 <code>NaN</code> 、 <code>Infinity</code> 和 <code>-Infinity</code> ，则序列化的结果会变成 <code>null</code> ；</li>
<li>无法拷贝对象的循环应用(即 <code>obj[key] = obj</code> )。</li>
</ul>
<h4 id="4-2-三方库"><a href="#4-2-三方库" class="headerlink" title="4.2 三方库"></a>4.2 三方库</h4><h4 id="4-3-深拷贝"><a href="#4-3-深拷贝" class="headerlink" title="4.3 深拷贝"></a>4.3 深拷贝</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isObject = <span class="function"><span class="params">obj</span> =&gt;</span> <span class="keyword">typeof</span> obj === <span class="string">"object"</span> &amp;&amp; obj != <span class="literal">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneDeep</span> (<span class="params">source</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (!isObject(source)) <span class="keyword">return</span> source;</span><br><span class="line">   <span class="keyword">const</span> target = <span class="built_in">Array</span>.isArray(source) ? [] : &#123;&#125;</span><br><span class="line"> 	 <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">   	  <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(source, key)) &#123;</span><br><span class="line">      	 <span class="keyword">if</span>(isObject(source[key]))&#123;</span><br><span class="line">         		target[key] = cloneDeep(source[key])</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         		target[key] = source[key]</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三、可选链"><a href="#三、可选链" class="headerlink" title="三、可选链 ?."></a>三、可选链 ?.</h2><h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h3><p>实际开发中常见写法<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj.list.map(<span class="function"><span class="params">()</span>=&gt;</span>&#123;...&#125;)) <span class="comment">// 此时报错</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.name.a) <span class="comment">// 此时报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 常见解决方法</span></span><br><span class="line"><span class="keyword">let</span> result = obj.list &amp;&amp; obj.list.map(<span class="function"><span class="params">()</span>=&gt;</span>&#123;...&#125;)</span><br><span class="line"><span class="keyword">let</span> result = obj.name &amp;&amp; obj.name.a || <span class="string">""</span></span><br></pre></td></tr></table></figure></p>
<h3 id="2-介绍"><a href="#2-介绍" class="headerlink" title="2.介绍"></a>2.介绍</h3><p>可选链 <code>?.</code> 是只用避免访问嵌套属性的放错误方法，即使访问的属性不存在，也不会出现错误。<br>如果可选链前边是 <code>undefined</code> 或者是 <code>null</code> ,他会停止运算并且返回 <code>undefined</code><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj?.name) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(obj?.name?.a) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//给默认值</span></span><br><span class="line"><span class="built_in">console</span>.log(obj?.name?.a ?? <span class="string">"我是默认值"</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3.注意事项"></a>3.注意事项</h3><ul>
<li><p>可选链使用在一些属性或者方法不存在的地方</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  admin() &#123;</span><br><span class="line">    alert(<span class="string">"I am admin"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">obj.admin?.(); <span class="comment">// I am admin</span></span><br><span class="line">obj1.admin?.(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可选链之前的变量必须声明，否则会报错</p>
</li>
<li><p>可选链不能用于赋值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">obj?.name = <span class="number">1</span> <span class="comment">// Uncaught SyntaxError: Invalid left-hand side in assignment</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可选链访问数组元素方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arrItem = arr?.[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h3><p>原理：判断左边部分是否为<code>undefined</code> 或者 <code>null</code> , 如果不是则继续执行，否则就 <code>undefined</code> </p>
<ul>
<li><code>obj?.prop</code>   –  如果 <code>obj</code> 存在则返回 <code>obj?.prop</code> ，否则返回 <code>undefined</code> </li>
<li><code>obj?.[prop]</code>   –  如果 <code>obj</code> 存在则返回 <code>obj?.[prop]</code> ，否则返回 <code>undefined</code></li>
<li><code>obj?.say()</code>   –  如果 <code>obj</code> 存在则调用 <code>obj?.say()</code> ，否则返回 <code>undefined</code></li>
</ul>
<h2 id="附加"><a href="#附加" class="headerlink" title="附加"></a>附加</h2><ul>
<li>let 、const声明的变量不在window下挂载，是在script的块级作用域下边挂载，var,function声明的变量还在window下，从es6之后全局变量将脱离顶层对象的属性。</li>
<li>可选链<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result = res.data &amp;&amp; res.data.n</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">var</span> result = res.data?.n</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于给个默认值</span></span><br><span class="line"><span class="keyword">var</span> result = res.data &amp;&amp; res.data.n || <span class="number">100</span></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">var</span> result = res.data?.n ?? <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果n为0的话  值就位100了   但是期望是0   所以使用上述 ？？写法</span></span><br><span class="line"><span class="keyword">var</span> result = res.data?.n || <span class="number">100</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>千分符：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"1232.2322"</span>.replace(<span class="regexp">/\d(?=(?:\d&#123;3&#125;)+(?:\.\d+|$))/g</span>, <span class="string">'$&amp;,'</span>) <span class="comment">// 1,232.2,322</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>Js</tag>
      </tags>
  </entry>
  <entry>
    <title>防抖、节流</title>
    <url>/2021/02/24/%E5%89%8D%E7%AB%AF/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/%E9%98%B2%E6%8A%96%E3%80%81%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<h1 id="一、防抖（debounce）"><a href="#一、防抖（debounce）" class="headerlink" title="一、防抖（debounce）"></a>一、防抖（debounce）</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h2><blockquote>
<p>防抖是将多次操作合并为一次进行操作。原理是维护一个定时器， 在delay时间后触发时间，当然，如果在delay时间内再次出发时间，将清除上一次的定时器，重新计时。这样只有最后一次会触发事件。</p>
</blockquote>
<h2 id="2-场景"><a href="#2-场景" class="headerlink" title="2.场景"></a>2.场景</h2><p>input时时输入掉接口拿列表</p>
<h2 id="3-核心代码"><a href="#3-核心代码" class="headerlink" title="3.核心代码"></a>3.核心代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> debounce = <span class="function"><span class="keyword">function</span> (<span class="params">fn, delay</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">let</span> _this = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">if</span>(timer)&#123;</span><br><span class="line">            clearTimeout(timer) </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 方法1</span></span><br><span class="line">        timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            timer = <span class="literal">null</span>;</span><br><span class="line">            fn.apply(_this, args) <span class="comment">// fn可接受参数</span></span><br><span class="line">        &#125;, delay)</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 方法2</span></span><br><span class="line">        timer = setTimeout(fn, delay) <span class="comment">// fn不接受参数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-例子-input框时时输入掉接口获取列表"><a href="#4-例子-input框时时输入掉接口获取列表" class="headerlink" title="4.例子:input框时时输入掉接口获取列表"></a>4.例子:input框时时输入掉接口获取列表</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;input</span><br><span class="line">  ref=<span class="string">"buyNameList"</span></span><br><span class="line">  type=<span class="string">"text"</span></span><br><span class="line">  v-model=<span class="string">"value"</span></span><br><span class="line">  @input=<span class="string">"buyerNameInput()"</span></span><br><span class="line">/&gt;</span><br><span class="line"><span class="keyword">let</span> debounce = <span class="function">(<span class="params">fn, delayTime</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> delay = delayTime || <span class="number">200</span>;</span><br><span class="line">  <span class="keyword">let</span> timer;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> th = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">      clearTimeout(timer);</span><br><span class="line">    &#125;</span><br><span class="line">    timer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      timer = <span class="literal">null</span>;</span><br><span class="line">      fn.apply(th, args);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">methods:&#123;</span><br><span class="line">    buyerNameInput: debounce(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> val = <span class="keyword">this</span>.value;</span><br><span class="line">      <span class="keyword">if</span> (val) &#123;</span><br><span class="line">      <span class="comment">// 获取列表接口</span></span><br><span class="line">        <span class="keyword">this</span>.queryBuyerInfos(val);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">500</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二、节流（throttle）"><a href="#二、节流（throttle）" class="headerlink" title="二、节流（throttle）"></a>二、节流（throttle）</h1><h2 id="1-概念："><a href="#1-概念：" class="headerlink" title="1.概念："></a>1.概念：</h2><blockquote>
<p>节流就是持续触发事件的时候，保证一定时间段内只调用一次事件处理函数。比如scorll事件一直触发，但是不会立即执行，每隔1000ms执行一次。</p>
</blockquote>
<h2 id="2-实现方法："><a href="#2-实现方法：" class="headerlink" title="2.实现方法："></a>2.实现方法：</h2><p>定时器、时间戳</p>
<h2 id="3-场景："><a href="#3-场景：" class="headerlink" title="3.场景："></a>3.场景：</h2><p>滚到页面底加载更多</p>
<h2 id="4-核心代码"><a href="#4-核心代码" class="headerlink" title="4.核心代码"></a>4.核心代码</h2><ul>
<li><p>定时器：当触发事件的时候，我们设置一个定时器，再次触发事件的时候，如果定时器存在，就不执行，直到delay时间后，定时器执行执行函数，并且清空定时器，这样就可以设置下个定时器。当第一次触发事件时，不会立即执行函数，而是在delay秒后才执行。而后再怎么频繁触发事件，也都是每delay时间才执行一次。当最后一次停止触发后，由于定时器的delay延迟，可能还会执行一次函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> throttle = <span class="function"><span class="keyword">function</span>(<span class="params">fn, delay</span>) </span>&#123;            </span><br><span class="line">    <span class="keyword">var</span> timer = <span class="literal">null</span>;            </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;                </span><br><span class="line">        <span class="keyword">var</span> _this = <span class="keyword">this</span>;               </span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">arguments</span>;                </span><br><span class="line">        <span class="keyword">if</span> (!timer) &#123;                    </span><br><span class="line">            timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;                        </span><br><span class="line">                fn.apply(_this, args);                        </span><br><span class="line">                timer = <span class="literal">null</span>;                    </span><br><span class="line">            &#125;, delay);                </span><br><span class="line">        &#125;            </span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>时间戳：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> throttle = <span class="function"><span class="keyword">function</span>(<span class="params">fn, delay</span>) </span>&#123;            </span><br><span class="line">  <span class="keyword">var</span> prev = <span class="built_in">Date</span>.now();            </span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;                </span><br><span class="line">    <span class="keyword">var</span> _this = <span class="keyword">this</span>;                </span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">arguments</span>;                </span><br><span class="line">    <span class="keyword">var</span> now = <span class="built_in">Date</span>.now();                </span><br><span class="line">    <span class="keyword">if</span> (now - prev &gt;= delay) &#123;                    </span><br><span class="line">      fn.apply(_this, args);                    </span><br><span class="line">      prev = <span class="built_in">Date</span>.now();                </span><br><span class="line">    &#125;            </span><br><span class="line">  &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定时器 + 节流：在节流函数内部使用开始时间startTime、当前时间curTime与delay来计算剩余时间remaining，当remaining&lt;=0时表示该执行事件处理函数了（保证了第一次触发事件就能立即执行事件处理函数和每隔delay时间执行一次事件处理函数）。如果还没到时间的话就设定在remaining时间后再触发 （保证了最后一次触发事件后还能再执行一次事件处理函数）。当然在remaining这段时间中如果又一次触发事件，那么会取消当前的计时器，并重新计算一个remaining来判断当前状态。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> throttle = <span class="function"><span class="keyword">function</span>(<span class="params">fn, delay</span>) </span>&#123;     </span><br><span class="line">    <span class="keyword">var</span> timer = <span class="literal">null</span>;     </span><br><span class="line">    <span class="keyword">var</span> startTime = <span class="built_in">Date</span>.now();     </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;             </span><br><span class="line">        <span class="keyword">var</span> curTime = <span class="built_in">Date</span>.now();             </span><br><span class="line">        <span class="keyword">var</span> remaining = delay - (curTime - startTime);             </span><br><span class="line">        <span class="keyword">var</span> _this = <span class="keyword">this</span>;             </span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">arguments</span>;             </span><br><span class="line">        clearTimeout(timer);              </span><br><span class="line">        <span class="keyword">if</span> (remaining &lt;= <span class="number">0</span>) &#123;                    </span><br><span class="line">            fn.apply(_this, args);                    </span><br><span class="line">            startTime = <span class="built_in">Date</span>.now();              </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                    </span><br><span class="line">            timer = setTimeout(fn, remaining);              </span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><ul>
<li>防抖跟节流主要是为了减少调用频率。</li>
<li><p>函数防抖：将几次操作合并为一此操作进行。原理是维护一个计时器，规定在<code>delay</code>时间后触发函数，但是在<code>delay</code>时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。</p>
</li>
<li><p>函数节流：使得一定时间内只触发一次函数。原理是通过判断是否到达一定时间来触发函数。</p>
</li>
<li><p>区别： 函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次 <code>Ajax</code> 请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流技术来实现。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>Js</tag>
      </tags>
  </entry>
  <entry>
    <title>项目迁移</title>
    <url>/2020/09/21/%E5%89%8D%E7%AB%AF/%E6%9D%82%E8%AE%B0/git%E9%A1%B9%E7%9B%AE%E8%BF%81%E7%A7%BB/</url>
    <content><![CDATA[<blockquote>
<p>使用背景</p>
</blockquote>
<p>项目要求从gitLab迁移到阿里云</p>
<blockquote>
<p>使用技术</p>
</blockquote>
<ul>
<li><p>保持本地代码是最新的<br><code>git pull</code></p>
</li>
<li><p>查看远程分支<br><code>git remote -v</code></p>
</li>
<li><p>删除本地项目与gitlab的联系<br><code>git remote remove origin</code></p>
</li>
<li><p>建立本地项目与阿里云的联系<br><code>git remote add origin 目的地地址</code></p>
</li>
<li><p>推送本地代码到阿里云<br><code>git push</code></p>
</li>
</ul>
]]></content>
      <categories>
        <category>记录篇</category>
      </categories>
      <tags>
        <tag>记录篇</tag>
      </tags>
  </entry>
  <entry>
    <title>git学习笔记</title>
    <url>/2020/09/21/%E5%89%8D%E7%AB%AF/%E6%9D%82%E8%AE%B0/git%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p><code>git</code>是代码管理工具</p>
<p><code>github</code>是基于<code>git</code>实现的代码管理平台</p>
<blockquote>
<p>创建一个文件，进入该文件查看当前文件所在目录</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir learngit</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> learngit</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">pwd</span></span></span><br><span class="line">/Users/michael/learngit</span><br></pre></td></tr></table></figure>
<blockquote>
<p>把该目录变成可以管理的git仓库</p>
</blockquote>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> <span class="regexp">/Users/mi</span>chael<span class="regexp">/learngit/</span>.git<span class="regexp">/</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>告诉git我要把readme.txt添加到仓库</p>
</blockquote>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">add</span><span class="bash"> readme.txt</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>告诉git我要提交文件到仓库，引号中的为注释。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">commit</span> -m <span class="string">"wrote a readme file"</span>   </span><br><span class="line">[<span class="keyword">master</span> (root-<span class="keyword">commit</span>) eaadf4e] wrote a readme <span class="keyword">file</span></span><br><span class="line"> <span class="number">1</span> <span class="keyword">file</span> <span class="keyword">changed</span>, <span class="number">2</span> insertions(+)</span><br><span class="line"> <span class="keyword">create</span> <span class="keyword">mode</span> <span class="number">100644</span> readme.txt</span><br></pre></td></tr></table></figure>
<blockquote>
<p>查看当前仓库的状态</p>
</blockquote>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>git status</span><br></pre></td></tr></table></figure>
<blockquote>
<p>查看readme.txt文件修改的不同的地方</p>
</blockquote>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>git diff readme.txt</span><br></pre></td></tr></table></figure>
<blockquote>
<p>命令显示从最近到最远的提交日志，可以加上–pretty=oneline参数简化下</p>
</blockquote>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> git <span class="built-in">log</span></span><br></pre></td></tr></table></figure>
<p>? 回退到上一个版本，当前版本是 HEAD,上一个版本是HEAD^,上上一个版本是HEAD^^,依次类推，上100个版本，简写为 HEAD~100</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">reset</span> <span class="comment">--hard HEAD^</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>查看某个文件内容</p>
</blockquote>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>cat readme.txt</span><br></pre></td></tr></table></figure>
<blockquote>
<p>直接变为版本号为1094开始的版本</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">reset</span> <span class="comment">--hard 1094a</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>记录篇</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>flex布局</title>
    <url>/2020/09/21/%E5%89%8D%E7%AB%AF/%E6%9D%82%E8%AE%B0/flex%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h1 id="一、flex布局是什么"><a href="#一、flex布局是什么" class="headerlink" title="一、flex布局是什么"></a>一、flex布局是什么</h1><p>Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。</p>
<blockquote>
<p>任何一个容器都可以指定为 Flex 布局。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">  display: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Webkit 内核的浏览器，必须加上-webkit前缀。</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-flex; <span class="comment">/* Safari */</span></span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，设为 <code>Flex</code> 布局以后，子元素的<code>float</code>、<code>clear</code>和<code>vertical-align</code>属性将失效。</p>
</blockquote>
<h1 id="二、基本概念"><a href="#二、基本概念" class="headerlink" title="二、基本概念"></a>二、基本概念</h1><blockquote>
<p>采用<code>flex</code>布局的元素称为‘容器’，容器中的子元素称为‘flex项目’，简称：‘项目’。</p>
</blockquote>
<h1 id="三、容器属性"><a href="#三、容器属性" class="headerlink" title="三、容器属性"></a>三、容器属性</h1><blockquote>
<p>以下是设置在容器上的属性</p>
</blockquote>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="attribute">flex-direction</span> <span class="attribute">flex-wrap</span> <span class="attribute">flex-flow</span> <span class="attribute">justify-content</span> <span class="attribute">align-items</span> <span class="attribute">align-content</span></span><br></pre></td></tr></table></figure>
<h2 id="3-1flex-direction属性"><a href="#3-1flex-direction属性" class="headerlink" title="3.1flex-direction属性"></a>3.1flex-direction属性</h2><p><code>flex-direction</code>属性决定主轴的方向（即项目的排列方向）。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">flex-direction</span>: row | row-reverse | column | column-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-2-flex-wrap属性"><a href="#3-2-flex-wrap属性" class="headerlink" title="3.2 flex-wrap属性"></a>3.2 flex-wrap属性</h2><p><code>flex-wrap</code>属性决定项目如何让换行</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-3-flex-flow"><a href="#3-3-flex-flow" class="headerlink" title="3.3 flex-flow"></a>3.3 flex-flow</h2><p><code>flex-flow</code>属性是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式,默认值为<code>row nowrap</code>。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">flex-flow</span>: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-4-justify-content属性"><a href="#3-4-justify-content属性" class="headerlink" title="3.4 justify-content属性"></a>3.4 justify-content属性</h2><p><code>justify-content</code>属性定义了项目在主轴上的对齐方式。</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  justify-content: flex-start | flex-<span class="keyword">end</span> | center | <span class="literal">space</span>-<span class="keyword">between</span> | <span class="literal">space</span>-<span class="keyword">around</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>space-between</code>：两端对齐，项目之间的间隔都相等。<br><code>space-around</code>：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</p>
<h2 id="3-5-align-items属性"><a href="#3-5-align-items属性" class="headerlink" title="3.5 align-items属性"></a>3.5 align-items属性</h2><p><code>align-items</code>属性定义项目在交叉轴上如何对齐</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  align-items: flex-start | <span class="type">flex</span>-<span class="keyword">end</span> | <span class="type">center</span> | <span class="type">baseline</span> | <span class="type">stretch</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>baseline</code>: 项目的第一行文字的基线对齐。</p>
<p><code>stretch</code>（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</p>
<blockquote>
<p>以下是单根轴线的（垂直方向）居中对齐方式</p>
</blockquote>
<p><img src="/images/杂记/align-items.png" alt="align-items"></p>
<h2 id="3-6-align-content属性"><a href="#3-6-align-content属性" class="headerlink" title="3.6 align-content属性"></a>3.6 align-content属性</h2><p><code>align-content</code>属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  align-content: flex-start | <span class="type">flex</span>-<span class="keyword">end</span> | <span class="type">center</span> | <span class="type">space</span>-between | <span class="type">space</span>-around | <span class="type">stretch</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以下是多根轴线的（垂直方向）居中对齐方式</p>
</blockquote>
<p><img src="/images/杂记/align-content.png" alt="align-content"></p>
<h1 id="四、项目的属性"><a href="#四、项目的属性" class="headerlink" title="四、项目的属性"></a>四、项目的属性</h1><h2 id="4-1-order属性"><a href="#4-1-order属性" class="headerlink" title="4.1 order属性"></a>4.1 order属性</h2><blockquote>
<p><code>order</code>属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p>
</blockquote>
 <figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="attribute">order</span> <span class="attribute">flex-grow</span> <span class="attribute">flex-shrink</span> <span class="attribute">flex-basis</span> <span class="attribute">flex</span> <span class="attribute">align-self</span></span><br></pre></td></tr></table></figure>
<h2 id="4-2-flex-grow属性"><a href="#4-2-flex-grow属性" class="headerlink" title="4.2 flex-grow属性"></a>4.2 flex-grow属性</h2><blockquote>
<p><code>flex-grow</code>属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</p>
</blockquote>
<blockquote>
<p>如果所有项目的<code>flex-grow</code>属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的<code>flex-grow</code>属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: &lt;number&gt;; <span class="comment">/* default 0 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="4-3-flex-shrink属性"><a href="#4-3-flex-shrink属性" class="headerlink" title="4.3 flex-shrink属性"></a>4.3 flex-shrink属性</h2><blockquote>
<p><code>flex-shrink</code>属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-shrink</span>: &lt;number&gt;; <span class="comment">/* default 1 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果所有项目的<code>flex-shrink</code>属性都为1，当空间不足时，都将等比例缩小。如果一个项目的<code>flex-shrink</code>属性为0，其他项目都为1，则空间不足时，前者不缩小。</p>
<p>负值对该属性无效</p>
<h2 id="4-4-flex-basis属性"><a href="#4-4-flex-basis属性" class="headerlink" title="4.4 flex-basis属性"></a>4.4 flex-basis属性</h2><blockquote>
<p><code>flex-basis</code>属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为<code>auto</code>，即项目的本来大小。</p>
</blockquote>
<h2 id="4-5-flex属性"><a href="#4-5-flex属性" class="headerlink" title="4.5 flex属性"></a>4.5 flex属性</h2><p><code>flex</code>属性是<code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>。后两个属性可选</p>
<p>该属性有两个快捷值：<code>auto (1 1 auto)</code> 和 <code>none (0 0 auto)</code>。</p>
<p>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p>
<h2 id="4-6-align-self属性"><a href="#4-6-align-self属性" class="headerlink" title="4.6 align-self属性"></a>4.6 align-self属性</h2><blockquote>
<p><code>align-self</code>属性允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性。默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code>。</p>
</blockquote>
<h1 id="五、实战例子"><a href="#五、实战例子" class="headerlink" title="五、实战例子"></a>五、实战例子</h1><blockquote>
<p>实现效果：如图所示</p>
</blockquote>
<p><img src="/images/杂记/flex.png" alt="align-content"></p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">  <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">  &amp;<span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">''</span>,</span><br><span class="line">    width: <span class="string">''</span>, //宽度跟每个item的宽度一样</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title>mac修改host</title>
    <url>/2020/09/21/%E5%89%8D%E7%AB%AF/%E6%9D%82%E8%AE%B0/mac%E4%B8%8A%E4%BF%AE%E6%94%B9host/</url>
    <content><![CDATA[<ul>
<li><p>sudo -s</p>
</li>
<li><p>输入本机密码</p>
</li>
<li><p>sudo vi /etc/hosts</p>
</li>
<li><p>方向键移动位置</p>
</li>
<li><p>i  编辑状态</p>
</li>
<li><p>esc  退出编辑</p>
</li>
<li><p>输入  :wq  保存修改    :q!  不保存修改   退出</p>
</li>
</ul>
]]></content>
      <categories>
        <category>记录篇</category>
      </categories>
      <tags>
        <tag>记录篇</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/09/21/%E5%89%8D%E7%AB%AF/%E6%9D%82%E8%AE%B0/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <categories>
        <category>记录篇</category>
      </categories>
      <tags>
        <tag>记录篇</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo + github</title>
    <url>/2020/09/21/%E5%89%8D%E7%AB%AF/%E6%9D%82%E8%AE%B0/hexo+github/</url>
    <content><![CDATA[<h2 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h2><p>在<a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a>官网根据自己系统版本下载安装。（直接下一步下一步就好了）</p>
<hr>
<h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><p>安装很简单，一直下一步 <a href="https://jingyan.baidu.com/article/9f7e7ec0b17cac6f2815548d.html" target="_blank" rel="noopener">git安装教程</a></p>
<p>安装成功你在桌面右键，就能看到多了两个git命令</p>
<hr>
<h2 id="注册一个github"><a href="#注册一个github" class="headerlink" title="注册一个github"></a>注册一个github</h2><p><a href="https://github.com/" target="_blank" rel="noopener">GitHub官网</a>。按照一般的网站注册登录执行就好了，不懂自行goole。</p>
<hr>
<h2 id="在github上新建一个厂库"><a href="#在github上新建一个厂库" class="headerlink" title="在github上新建一个厂库"></a>在github上新建一个厂库</h2><p>需要把Repository name 改成你自己的，例如我的：15735046155.github.io</p>
<p>创建时记得勾上选项 Initialize this repository with a README，完成之后，你可以在地址栏，打开yourname.github.io查看是否成功。</p>
<hr>
<h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><blockquote>
<p>Hexo是一个简单、快速、强大的基于 Github Pages 的博客发布工具，支持Markdown格式，有众多优秀插件和主题。</p>
</blockquote>
<p>hexo官网：<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a></p>
<p>这个时候nodejs的npm就排上用场了,你可以用系统自带的命令面板（window下是cmd），也可以用<code>git bash here</code>(推荐)</p>
<p>检查一下npm是否安装成功</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">npm</span>  -v</span><br><span class="line"><span class="built_in">npm</span> install hexo-cli -g</span><br></pre></td></tr></table></figure>
<p>如果npm安装很慢，被墙了，推荐使用<a href="http://npm.taobao.org/" target="_blank" rel="noopener">淘宝镜像</a></p>
<hr>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化:"></a>初始化:</h2><p>在电脑的某个地方新建一个名为blog的文件夹（名字可以随便取），比如我的是C:\blog，由于这个文件夹将来就作为你存放代码的地方，所以最好不要随便放。然后在这个文件夹内，右键打开git base here，就是这么神奇，哪里都有它。</p>
<p>检查你的hexo 是否安装成功</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hexo -v</span></span><br></pre></td></tr></table></figure>
<p>初始化hexo</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">hexo init <span class="comment">#hexo会自动下载一些文件到这个目录，包括node_modules</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-deployer-git</span><br></pre></td></tr></table></figure>
<p>此时直接执行hexo d的话一般会报如下错误：(安装hexo-deployer-git的原因)<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">Deployer not <span class="string">found:</span> github 或者 Deployer not <span class="string">found:</span> git</span><br></pre></td></tr></table></figure></p>
<p>然后依次执行以下命令：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>hexo g <span class="comment"># 生成</span></span><br><span class="line"><span class="variable">$ </span>hexo s <span class="comment"># 启动服务</span></span><br></pre></td></tr></table></figure>
<p>执行以上命令之后，hexo就会在public文件夹生成相关html文件，然后会提示你</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">INFO Hexo is running <span class="keyword">at</span> <span class="keyword">http</span>://<span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">4000</span>/. Press Ctrl+C <span class="built_in">to</span> <span class="built_in">stop</span>.</span><br></pre></td></tr></table></figure>
<p><code>hexo s</code>是开启本地预览服务,在浏览器中打开 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> ，即可看到内容, 很多人会碰到浏览器一直在转圈但是就是加载不出来的问题，一般情况下是因为端口占用的缘故，因为4000这个端口太常见了，解决端口冲突问题请参考这篇文章：<a href="http://blog.liuxianan.com/windows-port-bind.html" target="_blank" rel="noopener">http://blog.liuxianan.com/windows-port-bind.html</a></p>
<hr>
<h2 id="连接github，让别人也能访问你的blog"><a href="#连接github，让别人也能访问你的blog" class="headerlink" title="连接github，让别人也能访问你的blog"></a>连接github，让别人也能访问你的blog</h2><p>考虑到大家可能会存在的一种情况，就是换电脑，或者在家里和公司都想写blog，管理他，该怎么做呢！</p>
<ul>
<li>新建一个hexo分支(branches)</li>
</ul>
<p>这个分支就是用来装hexo的核心源文件的！慢慢往下看，一步一步来</p>
<p>在你的博客文件夹内，打开git base here。如果你的文件正确的话，现在是没有.git文件的，这是个隐藏文件夹，有的小伙伴没有设置怎么查看隐藏文件，不会的可以根据你的系统去百度一下，很简单的。</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">git init  <span class="comment">//初始化本地仓库 会生成一个.git文件</span></span><br><span class="line">git add <span class="keyword">source</span> scaffolds themes .gitignore _config.yml <span class="keyword">package</span>.json <span class="comment">//将这6个文件提交到hexo分支，这就是源文件了， source里面就是装的你的博客文章</span></span><br><span class="line">git commit -m <span class="string">"Blog Source Hexo"</span></span><br><span class="line">git branch hexo  <span class="comment">//新建hexo分支</span></span><br><span class="line">git checkout hexo  <span class="comment">//切换到hexo分支上</span></span><br><span class="line">git remote add origin https:<span class="comment">//github.com/15735046155/15735046155.github.io.git(换成你自己的)  //将本地与Github项目对接 很多教程说要用ssh，我这里用https也没有出错</span></span><br><span class="line">git <span class="keyword">push</span> origin hexo  <span class="comment">//push到Github项目的hexo分支上</span></span><br></pre></td></tr></table></figure>
<hr>
<p>提交完成之后，你可以在github上的厂库里看到：</p>
<ul>
<li>将博客文章提交到master页面</li>
</ul>
<p>在你博客文件夹中找的<code>C:\blog\_config.yml</code>文件，修改以下几处 (文末附上其他配置信息介绍)</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="meta"># Site</span></span><br><span class="line"><span class="symbol">title:</span> coder  <span class="meta"># 博客名</span></span><br><span class="line"><span class="symbol">subtitle:</span> <span class="meta"># 副标题</span></span><br><span class="line"><span class="symbol">description:</span>  <span class="meta"># 描述</span></span><br><span class="line"><span class="symbol">author:</span> 只有极其努力，才能看起来毫不费力。 <span class="meta"># 作者</span></span><br><span class="line"><span class="symbol">language:</span> <span class="built_in">zh</span>-Hans <span class="meta"># 语言，还是改成汉语吧</span></span><br><span class="line"><span class="symbol">timezone:</span></span><br></pre></td></tr></table></figure>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="attribute">deploy</span>:</span><br><span class="line">    <span class="attribute">type</span>: git</span><br><span class="line">    <span class="attribute">repository</span>: <span class="attribute">https</span>:<span class="comment">//github.com/15735046155/15735046155.github.io.git</span></span><br><span class="line">    <span class="attribute">branch</span>: master</span><br></pre></td></tr></table></figure>
<p>然后你就可以执行以下命令:</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hexo</span> g  <span class="comment">#生成静态文件。</span></span><br><span class="line">hexo d  <span class="comment">#部署网站。</span></span><br></pre></td></tr></table></figure>
<p>现在可以再打开yourname.github.io看看了。不出意外，就成功了。</p>
<h2 id="换了电脑之后怎么弄"><a href="#换了电脑之后怎么弄" class="headerlink" title="换了电脑之后怎么弄"></a>换了电脑之后怎么弄</h2><p>在新电脑上，nodejs，git，github这些都要有哦</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">git clone -b hexo <span class="keyword">https</span>://github.com/<span class="number">15735046155</span>/<span class="number">15735046155.</span>github.io.git <span class="comment"> //将Github中hexo分支clone到本地</span></span><br><span class="line">cd  yourname.github.io <span class="comment"> //切换到刚刚clone的文件夹内</span></span><br><span class="line">npm install   <span class="comment"> //注意，这里一定要切换到刚刚clone的文件夹内执行，安装必要的所需组件，不用再init</span></span><br><span class="line">npm install -g hexo-cli<span class="comment"> // 如果电脑上没有安装这个，需要先安装</span></span><br><span class="line">hexo <span class="built_in">new</span> <span class="built_in">post</span> <span class="string">"new blog name"</span>  <span class="comment"> //新建一个.md文件，并编辑完成自己的博客内容</span></span><br><span class="line">git <span class="built_in">add</span> source <span class="comment"> //经测试每次只要更新sorcerer中的文件到Github中即可，因为只是新建了一篇新博客</span></span><br><span class="line">git commit -m <span class="string">"XX"</span> <span class="comment"> //提交的注释</span></span><br><span class="line">git push origin hexo <span class="comment"> //更新分支</span></span><br><span class="line">hexo d -g  <span class="comment"> //push更新完分支之后将自己写的博客对接到自己搭的博客网站上，同时同步了Github中的master</span></span><br></pre></td></tr></table></figure>
<p>如果hexo d -g没有生效</p>
<p>可以再执行</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hexo g</span></span><br><span class="line"><span class="attribute">hexo d</span></span><br></pre></td></tr></table></figure>
<p>你如果有多个电脑在用，每次写了blog在其他电脑上执行一下:<br><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git pull origin hexo</span></span><br></pre></td></tr></table></figure></p>
<h2 id="next主题"><a href="#next主题" class="headerlink" title="next主题"></a>next主题</h2><blockquote>
<p>git地址：<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next</a></p>
</blockquote>
<ul>
<li>将下载的代码放在blog/theme/目录下</li>
<li>设置站点myBlog/_config.yml的theme字段值为hexo-theme-next</li>
<li>生成新页面hexo g</li>
<li>开启服务hexo s –debug</li>
<li>发布代码hexo d</li>
</ul>
<p>安装next主题：<a href="https://blog.csdn.net/zuoziji416/article/details/53204478" target="_blank" rel="noopener">https://blog.csdn.net/zuoziji416/article/details/53204478</a></p>
<p>主题配置：<a href="https://segmentfault.com/a/1190000009544924" target="_blank" rel="noopener">https://segmentfault.com/a/1190000009544924</a></p>
<h2 id="完整的配置信息如下"><a href="#完整的配置信息如下" class="headerlink" title="完整的配置信息如下"></a>完整的配置信息如下</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Site #站点信息</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">blog</span> <span class="string">Name</span> <span class="comment">#标题</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">Subtitle</span> <span class="comment">#副标题</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">my</span> <span class="string">blog</span> <span class="string">desc</span> <span class="comment">#描述</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">me</span> <span class="comment">#作者</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span> <span class="comment">#语言</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">Asia/Shanghai</span> <span class="comment">#时区</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">http://yoururl.com</span>   <span class="comment">#用于绑定域名, 其他的不需要配置</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br><span class="line"><span class="comment">#permalink: :year/:month/:day/:title/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">posts/title.html</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># Directory #目录</span></span><br><span class="line"><span class="attr">source_dir:</span> <span class="string">source</span> <span class="comment">#源文件</span></span><br><span class="line"><span class="attr">public_dir:</span> <span class="string">public</span> <span class="comment">#生成的网页文件</span></span><br><span class="line"><span class="attr">tag_dir:</span> <span class="string">tags</span> <span class="comment">#标签</span></span><br><span class="line"><span class="attr">archive_dir:</span> <span class="string">archives</span> <span class="comment">#归档</span></span><br><span class="line"><span class="attr">category_dir:</span> <span class="string">categories</span> <span class="comment">#分类</span></span><br><span class="line"><span class="attr">code_dir:</span> <span class="string">downloads/code</span></span><br><span class="line"><span class="attr">i18n_dir:</span> <span class="string">:lang</span> <span class="comment">#国际化</span></span><br><span class="line"><span class="attr">skip_render:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Writing #写作</span></span><br><span class="line"><span class="attr">new_post_name:</span> <span class="string">:title.md</span> <span class="comment">#新文章标题</span></span><br><span class="line"><span class="attr">default_layout:</span> <span class="string">post</span> <span class="comment">#默认模板(post page photo draft)</span></span><br><span class="line"><span class="attr">titlecase:</span> <span class="literal">false</span> <span class="comment">#标题转换成大写</span></span><br><span class="line"><span class="attr">external_link:</span> <span class="literal">true</span> <span class="comment">#新标签页里打开连接</span></span><br><span class="line"><span class="attr">filename_case:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">render_drafts:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">relative_link:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">future:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">highlight:</span> <span class="comment">#语法高亮</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">true</span> <span class="comment">#显示行号</span></span><br><span class="line">  <span class="attr">auto_detect:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">tab_replace:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Category &amp; Tag #分类和标签</span></span><br><span class="line"><span class="attr">default_category:</span> <span class="string">uncategorized</span> <span class="comment">#默认分类</span></span><br><span class="line"><span class="attr">category_map:</span></span><br><span class="line"><span class="attr">tag_map:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Date / Time format #日期时间格式</span></span><br><span class="line"><span class="comment">## http://momentjs.com/docs/#/displaying/format/</span></span><br><span class="line"><span class="attr">date_format:</span> <span class="string">YYYY-MM-DD</span></span><br><span class="line"><span class="attr">time_format:</span> <span class="string">HH:mm:ss</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Pagination #分页</span></span><br><span class="line"><span class="attr">per_page:</span> <span class="number">10</span> <span class="comment">#每页文章数, 设置成 0 禁用分页</span></span><br><span class="line"><span class="attr">pagination_dir:</span> <span class="string">page</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Extensions #插件和主题</span></span><br><span class="line"><span class="comment">## 插件: http://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## 主题: http://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">hexo-theme-next</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Deployment #部署, 同时发布在 GitHub 和 GitCafe 上面</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@gitcafe.com:username/username.git,gitcafe-pages</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:username/username.github.io.git,master</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Disqus #Disqus评论系统</span></span><br><span class="line"><span class="attr">disqus_shortname:</span> </span><br><span class="line"></span><br><span class="line"><span class="attr">plugins:</span> <span class="comment">#插件，例如生成 RSS 和站点地图的</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">hexo-generator-feed</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">hexo-generator-sitemap</span></span><br></pre></td></tr></table></figure>
<h2 id="常用命令："><a href="#常用命令：" class="headerlink" title="常用命令："></a>常用命令：</h2><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hexo</span> clean <span class="comment">#相当于清理下缓存</span></span><br><span class="line">hexo g <span class="comment">#生成public文件，相当于打包</span></span><br><span class="line">hexo s <span class="comment">#启动本地服务，在localhost:4000查看效果</span></span><br><span class="line">hexo d <span class="comment">#部署网站</span></span><br></pre></td></tr></table></figure>
<h2 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h2><p>参考:<a href="https://www.jianshu.com/p/728a9594bb6c" target="_blank" rel="noopener">评论功能连接</a></p>
]]></content>
      <categories>
        <category>记录篇</category>
      </categories>
      <tags>
        <tag>记录篇</tag>
      </tags>
  </entry>
  <entry>
    <title>作用域和闭包</title>
    <url>/2020/09/21/%E5%89%8D%E7%AB%AF/%E6%9D%82%E8%AE%B0/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<blockquote>
<p>什么是闭包？</p>
</blockquote>
<p>闭包的定义其实很简单：函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">  <span class="built_in">window</span>.B = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">A()</span><br><span class="line">B() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>很多人对于闭包的解释可能是函数嵌套了函数，然后返回一个函数。其实这个解释是不完整的，就比如我上面这个例子就可以反驳这个观点</p>
<p>在 JS 中，闭包存在的意义就是让我们可以间接访问函数内部的变量。</p>
<blockquote>
<p>经典面试题，循环中使用闭包解决 <code>var</code> 定义函数的问题</p>
</blockquote>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (var <span class="built_in">i</span> = <span class="number">1</span>; <span class="built_in">i</span> &lt;= <span class="number">5</span>; <span class="built_in">i</span>++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span><span class="params">()</span> &#123;</span></span><br><span class="line">    console.<span class="built_in">log</span>(<span class="built_in">i</span>)</span><br><span class="line">  &#125;, <span class="built_in">i</span> * <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先因为 <code>setTimeout</code> 是个异步函数，所以会先把循环全部执行完毕，这时候 <code>i</code>就是 6 了，所以会输出一堆 6。</p>
<p>解决办法有三种，第一种是使用闭包的方式</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (var <span class="built_in">i</span> = <span class="number">1</span>; <span class="built_in">i</span> &lt;= <span class="number">5</span>; <span class="built_in">i</span>++) &#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span><span class="params">(j)</span> &#123;</span></span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span><span class="params">()</span> &#123;</span></span><br><span class="line">      console.<span class="built_in">log</span>(<span class="built_in">j</span>)</span><br><span class="line">    &#125;, <span class="built_in">j</span> * <span class="number">1000</span>)</span><br><span class="line">  &#125;)(<span class="built_in">i</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，我们首先使用了立即执行函数将 <code>i</code> 传入函数内部，这个时候值就被固定在了参数 <code>j</code> 上面不会改变，当下次执行 <code>timer</code> 这个闭包的时候，就可以使用外部函数的变量 <code>j</code>，从而达到目的。</p>
<p>第二种就是使用 <code>setTimeout</code> 的第三个参数，这个参数会被当成 <code>timer</code> 函数的参数传入。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (var <span class="built_in">i</span> = <span class="number">1</span>; <span class="built_in">i</span> &lt;= <span class="number">5</span>; <span class="built_in">i</span>++) &#123;</span><br><span class="line">  setTimeout(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">timer</span><span class="params">(j)</span> &#123;</span></span><br><span class="line">      console.<span class="built_in">log</span>(<span class="built_in">j</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">i</span> * <span class="number">1000</span>,</span><br><span class="line">    <span class="built_in">i</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三种就是使用 <code>let</code> 定义 <code>i</code> 了来解决问题了，这个也是最为推荐的方式</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (let <span class="built_in">i</span> = <span class="number">1</span>; <span class="built_in">i</span> &lt;= <span class="number">5</span>; <span class="built_in">i</span>++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span><span class="params">()</span> &#123;</span></span><br><span class="line">    console.<span class="built_in">log</span>(<span class="built_in">i</span>)</span><br><span class="line">  &#125;, <span class="built_in">i</span> * <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>Js</tag>
      </tags>
  </entry>
  <entry>
    <title>var、let 及 const 区别</title>
    <url>/2020/09/21/%E5%89%8D%E7%AB%AF/%E6%9D%82%E8%AE%B0/var%E3%80%81let%20%E5%8F%8A%20const%20%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<blockquote>
<p>什么是提升？什么是暂时性死区？var、let 及 const 区别？</p>
</blockquote>
<p>提升（hoisting）这个概念</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">console.<span class="built_in">log</span>(<span class="keyword">a</span>)<span class="comment"> // undefined</span></span><br><span class="line">var <span class="keyword">a</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>从上述代码中我们可以发现，虽然变量还没有被声明，但是我们却可以使用这个未被声明的变量，这种情况就叫做提升，并且提升的是声明。</p>
<p>对于上述代码，我们可以这样解析</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">var <span class="keyword">a</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="keyword">a</span><span class="comment">)// undefine</span></span><br><span class="line"><span class="keyword">a</span>=<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>接下来我们再来看一个例子</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">var <span class="keyword">a</span> = <span class="number">10</span></span><br><span class="line">var <span class="keyword">a</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="keyword">a</span>)</span><br></pre></td></tr></table></figure>
<p>对于这个例子，如果你认为打印的值为 <code>undefined</code> 那么就错了，答案应该是 10，对于这种情况，我们这样来看代码</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">var <span class="keyword">a</span></span><br><span class="line">var <span class="keyword">a</span></span><br><span class="line"><span class="keyword">a</span> = <span class="number">10</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="keyword">a</span><span class="comment">)//10</span></span><br></pre></td></tr></table></figure>
<p>到这里为止，我们已经了解了 <code>var</code> 声明的变量会发生提升的情况，其实不仅变量会提升函数也会被提升。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// ƒ a() &#123;console.log(1)&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>对于上述代码，打印结果会是 <code>ƒ a() {}</code>，即使变量声明在函数之后，这也说明了函数会被提升，并且优先于变量提升。</p>
<p>说完了这些，想必大家也知道 <code>var</code> 存在的问题了，使用 <code>var</code> 声明的变量会被提升到作用域的顶部，接下来我们再来看 <code>let</code> 和 <code>const</code> 。</p>
<p>例子2：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.b) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>. c) <span class="comment">// undefined</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">  <span class="keyword">let</span> a</span><br><span class="line">&#125;</span><br><span class="line">test()</span><br></pre></td></tr></table></figure>
<p>首先在全局作用域下使用 <code>let</code> 和 <code>const</code> 声明变量，变量并不会被挂载到 <code>window</code> 上，这一点就和 <code>var</code> 声明有了区别。</p>
<p>再者当我们在声明 <code>a</code> 之前如果使用了 <code>a</code>，就会出现报错的情况</p>
<p><img src="/images/杂记/diff.png" alt="diff"></p>
<p>你可能会认为这里也出现了提升的情况，但是因为某些原因导致不能访问。</p>
<p>首先报错的原因是因为存在暂时性死区，我们不能在声明前就使用变量，这也是 <code>let</code> 和 <code>const</code> 优于 <code>var</code> 的一点。然后这里你认为的提升和 <code>var</code> 的提升是有区别的，虽然变量在编译的环节中被告知在这块作用域中可以访问，但是访问是受限制的。</p>
<p>那么到这里，想必大家也都明白 <code>var、let 及 const</code> 区别了，不知道你是否会有这么一个疑问，为什么要存在提升这个事情呢，其实提升存在的根本原因就是为了解决函数间互相调用的情况</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test2()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test1()</span><br><span class="line">&#125;</span><br><span class="line">test1()</span><br></pre></td></tr></table></figure>
<p>假如不存在提升这个情况，那么就实现不了上述的代码，因为不可能存在 <code>test1</code> 在 <code>test2</code> 前面然后 <code>test2</code> 又在 <code>test1</code> 前面。</p>
<p>那么最后我们总结下这小节的内容：</p>
<ul>
<li>函数提升优先于变量提升，函数提升会把整个函数挪到作用域顶部，变量提升只会把声明挪到作用域顶部</li>
<li><code>var</code> 存在提升，我们能在声明之前使用。<code>let、const</code> 因为暂时性死区的原因，不能在声明前使用</li>
<li><code>var</code> 在全局作用域下声明变量会导致变量挂载在 <code>window</code> 上，其他两者不会</li>
<li><code>let</code> 和 <code>const</code> 作用基本一致，但是后者声明的变量不能再次赋值</li>
</ul>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>Js</tag>
      </tags>
  </entry>
  <entry>
    <title>Permise在实际项目中应用记录</title>
    <url>/2020/09/22/%E5%89%8D%E7%AB%AF/%E6%9D%82%E8%AE%B0/promise/</url>
    <content><![CDATA[<ul>
<li>首先插播一段Permise的知识</li>
</ul>
<h1 id="Permise的执行"><a href="#Permise的执行" class="headerlink" title="Permise的执行"></a>Permise的执行</h1><blockquote>
<p>promise会在当前轮的最后当作微任务执行</p>
</blockquote>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'a'</span>), <span class="number">0</span>)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'b'</span>), <span class="number">1000</span>)</span><br><span class="line">Promise.resolve()</span><br><span class="line">    .<span class="keyword">then</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'c'</span>), <span class="number">0</span>)</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'d'</span>), <span class="number">1000</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'e'</span>);</span><br><span class="line">        Promise.resolve()</span><br><span class="line">            .<span class="keyword">then</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'f'</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="keyword">then</span>(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'g'</span>))</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'h'</span>), <span class="number">0</span>)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'i'</span>), <span class="number">1000</span>)</span><br><span class="line"><span class="regexp">//</span> efg ahc bid</span><br></pre></td></tr></table></figure>
<h2 id="解决上述问题"><a href="#解决上述问题" class="headerlink" title="解决上述问题"></a>解决上述问题</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p><code>promise.all</code> 其中一个失败导致整个的结果都是失败的处理方法<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> axios = <span class="built_in">require</span>(<span class="string">'axios'</span>)</span><br><span class="line"><span class="comment">//xxx 地址不存在肯定会失败</span></span><br><span class="line"><span class="keyword">let</span> arr = [</span><br><span class="line">  <span class="string">"https://www.baidu.com"</span>,</span><br><span class="line">  <span class="string">"httpss://github.com/"</span>,</span><br><span class="line">  <span class="string">"http://xxx"</span> </span><br><span class="line">]</span><br><span class="line"><span class="comment">// promise数组</span></span><br><span class="line"><span class="keyword">const</span> promises = arr.map(<span class="function"><span class="params">item</span> =&gt;</span> axios(item))</span><br><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.all(promises)</span><br><span class="line">p.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'res'</span>, res) <span class="comment">// 此处的res是每一个请求返回的结果</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上情况 如果其中一个任务失败，必定导致整个任务的结果都是失败的，</span></span><br><span class="line"><span class="comment">// 所以需要对数组中每个promise都去处理下catch,才会成功</span></span><br><span class="line"><span class="comment">// 解决办法  第九行代码，每一个都catch那么结果都是成功的，失败的都会返回hhh，后续也可根据hhh判断失败的</span></span><br><span class="line"><span class="keyword">const</span> promises = arr.map(<span class="function"><span class="params">item</span> =&gt;</span> axios(item).catch(e) =&gt; <span class="string">'hhh'</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [</span><br><span class="line">    <span class="string">"https://github.com/"</span>,</span><br><span class="line">    <span class="string">"https://www.baidu.com/"</span>,</span><br><span class="line">    <span class="string">"https://xxx"</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise = <span class="built_in">Promise</span>.allSettled(arr.map(<span class="function"><span class="params">item</span> =&gt;</span> axios(item)))</span><br><span class="line">promise.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    status: <span class="string">"fulflled"</span>,</span><br><span class="line">    value:&#123;</span><br><span class="line">      code: <span class="number">200</span>,</span><br><span class="line">      statustext: <span class="string">"ok"</span>,</span><br><span class="line">      ....</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,<span class="comment">// 成功的</span></span><br><span class="line">  ...</span><br><span class="line">  &#123;</span><br><span class="line">    status: <span class="string">"rejected"</span>,</span><br><span class="line">    reason:&#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="comment">// 失败的</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>实际项目记录</category>
      </categories>
      <tags>
        <tag>实际项目记录</tag>
      </tags>
  </entry>
  <entry>
    <title>初学react</title>
    <url>/2021/07/14/%E5%89%8D%E7%AB%AF/%E6%9D%82%E8%AE%B0/%E5%88%9D%E5%AD%A6react/</url>
    <content><![CDATA[<p>今年换了一份工作，使用的技术由原来的 <code>vue</code> 变为 <code>react</code>了，目前已经开始使用了快三个月了，此文记录一下。</p>
<h1 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h1><h2 id="Hook（16-8）比class优势？"><a href="#Hook（16-8）比class优势？" class="headerlink" title="Hook（16.8）比class优势？"></a>Hook（16.8）比class优势？</h2><blockquote>
<p>目前我就感受到的有如下几个。</p>
<ol>
<li>假如使用class的写法，分为有状态跟无状态组件，倘若有一天你的需求使你的组件迫不得已由无状态变为有状态的话，你就需要更改一些列代码。但是钥匙使用hook的写法的话，他只需引入对应的<code>useState</code>就好了。无需更改太多。</li>
<li>class写法需要写一系列的生命周期钩子，hook就不用写了，只需要使用<code>useEffect</code>就好了.详情见官网。</li>
</ol>
</blockquote>
<h2 id="useEffect的使用"><a href="#useEffect的使用" class="headerlink" title="useEffect的使用"></a>useEffect的使用</h2><ol>
<li>useEffect(a) // componentDidMount，componentDidUpdate。</li>
<li>useEffect(a,[]) // 第二个参数为空数组的时候只会在componentDidMount的时候执行。</li>
<li>useEffect(a,[num]) // componentDidUpdate，第二个参数使定义其依赖的变量，当变量更改的时候，会执行。</li>
</ol>
]]></content>
      <categories>
        <category>记录篇</category>
      </categories>
      <tags>
        <tag>记录篇</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试题</title>
    <url>/2020/09/21/%E5%89%8D%E7%AB%AF/%E6%9D%82%E8%AE%B0/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h1 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h1><h2 id="前端性能优化"><a href="#前端性能优化" class="headerlink" title="前端性能优化"></a>前端性能优化</h2><p>1.清理 HTML 文档</p>
<p>HTML，即超文本标记语言，几乎是所有网站的支柱。HTML 为网页带来标题、子标题、列表和其它一些文档结构的格式。在最近更新的 HTML5 中，甚至可以创建图表。</p>
<p>HTML 很容易被网络爬虫识别，因此搜索引擎可以根据网站的内容在一定程度上实时更新。在写 HTML 的时候，你应该尝试让它简洁而有效。此外，在 HTML 文档中引用外部资源的时候也需要遵循一些最佳实践方法。</p>
<p>a.恰当放置 CSS</p>
<p>Web 设计者喜欢在网页建立起主要的 HTML 骨架之后再来创建样式表。这样一来，网页中的样式表往往会放在 HTML 的后面，接近文档结束的地方。然而推荐的做法是把 CSS 放在 HTML 的上面部分，文档头之内，这可以确保正常的渲染过程。</p>
<p>这个策略不能提高网站的加载速度，但它不会让访问者长时间看着空白屏幕或者无格式的文本（FOUT）等待。如果网页大部分可见元素已经加载出来了，访问者才更有可能等待加载整个页面，从而带来对前端的优化效果。这就是知觉性能</p>
<p>b.正确放置 Javascript</p>
<p>另一方面，如果将 JavaScript 放置在 head 标签内或 HTML 文档的上部，这会阻塞 HTML 和 CSS 元素的加载过程。这个错误会导致页面加载时间增长，增加用户等待时间，容易让人感到不耐烦而放弃对网站的访问。不过，您可以通过将 JavaScript 属性置于 HTML 底部来避免此问题。</p>
<p>此外，在使用 JavaScript 时，人们通常喜欢用异步脚本加载。这会阻止<code>&lt;script&gt;</code>标签在 HTML 中的呈现过程，如，在文档中间的情况。</p>
<p>虽然对于网页设计师来说， HTML 是最值得使用的工具之一，但它通常要与 CSS 和 JavaScript 一起使用，这可能会导致网页浏览速度减慢。 虽然 CSS 和 JavaScript 有利于网页优化，但使用时也要注意一些问题。使用 CSS 和 JavaScript 时，要避免嵌入代码。因为当您嵌入代码时，要将 CSS 放置在样式标记中，并在脚本标记中使用 JavaScript，这会增加每次刷新网页时必须加载的 HTML 代码量。</p>
<p>2.优化 CSS 性能</p>
<p>CSS，即级联样式表，能从 HTML 描述的内容生成专业而又整洁的文件。很多 CSS 需要通过 HTTP 请求来引入（除非使用内联 CSS），所以你要努力去除累赘的 CSS 文件，但要注意保留其重要特征。</p>
<p>如果你的 Banner、插件和布局样式是使用 CSS 保存在不同的文件内，那么，访问者的浏览器每次访问都会加载很多文件。虽然现在 HTTP/2 的存在，减少了这种问题的发生，但是在外部资源加载的情况下，仍会花费较长时间。要了解如何减少 HTTP 请求以大幅度缩减加载时间，请阅读WordPress 性能。</p>
<p>此外，不少网站管理员在网页中错误的使用 @import 指令 来引入外部样式表。这是一个过时的方法，它会阻止浏览并行下载。link 标签才是最好的选择，它也能提高网站的前端性能。多说一句，通过 link 标签请求加载的外部样式表不会阻止并行下载。</p>
<p>3.减少外部HTTP请求</p>
<p>在很多情况下，网站的大部分加载时间来自于外部的 Http 请求。外部资源的加载速度随着主机提供商的服务器架构、地点等不同而不同。减少外部请求要做的第一步就是简略地检查网站。研究你网站的每个组成部分，消除任何影响访问者体验不好的成分。这些成分可能是：</p>
<ul>
<li>不必要的图片</li>
<li>没用的 JavaScript 代码</li>
<li>过多的 css</li>
<li>多余的插件</li>
</ul>
<p>在你去掉这些多余的成分之后，再对剩下的内容进行整理，如，压缩工具、CDN 服务和预获取（prefetching）等，这些都是管理 HTTP 请求的最佳选择。除此之外，减少DNS路由查找教程会教你如何一步一步的减少外部 HTTP 请求。</p>
<p>4.压缩 CSS, JS 和 HTML</p>
<p>压缩技术可以从文件中去掉多余的字符。你在编辑器中写代码的时候，会使用缩进和注释，这些方法无疑会让你的代码简洁而且易读，但它们也会在文档中添加多余的字节。</p>
<p>5.使用预先获取</p>
<p>预先获取可以在真正需要之前通过取得必需的资源和相关数据来改善访问用户的浏览体验，主要有3类预先获取:</p>
<ul>
<li>链接预先获取</li>
<li>DNS 预先获取</li>
<li>预先渲染</li>
</ul>
<p>在你离开当前 web 页面之前，使用预先获取方式，对应每个链接的 URL 地址，CSS，图片和脚本都会被预先获取。这保证了访问者能在最短时间内使用链接在画面间切换。</p>
<p>幸运的是，预先获取很容易实现。根据你想要使用的预先获取形式，你只需在网站 HTML 中的链接属性上增加 rel=”prefetch”,rel=”dns-prefetch”，或者 rel=”prerender” 标记。</p>
<p>6.使用 CDN 和缓存提高速度</p>
<p>内容分发网络能显著提高网站的速度和性能。使用 CDN 时，您可以将网站的静态内容链接到全球各地的服务器扩展网络。如果您的网站观众遍布全球，这项功能十分有用。 CDN 允许您的网站访问者从最近的服务器加载数据。如果您使用 CDN，您网站内的文件将自动压缩，以便在全球范围内快速分发。</p>
<p>CDN 是一种缓存方法，可极大改善资源的分发时间，同时，它还能实现一些其他的缓存技术，如，利用浏览器缓存。</p>
<p>合理地设置浏览器缓存，能让浏览器自动存储某些文件，以便加快传输速度。此方法的配置可以直接在源服务器的配置文件中完成。</p>
<p>7.压缩文件</p>
<p>虽然许多 CDN 服务可以压缩文件，但如果不使用 CDN，您也可以考虑在源服务器上使用文件压缩方法来改进前端优化。 文件压缩能使网站的内容轻量化，更易于管理。 最常用的文件压缩方法之一是 Gzip。 这是缩小文档、音频文件、PNG图像和等其他大文件的绝佳方法。</p>
<p>Brotli 是一个比较新的文件压缩算法，目前正变得越来越受欢迎。 此开放源代码算法由来自 Google 和其他组织的软件工程师定期更新，现已被证明比其他现有压缩方法更好用。 这种算法的支持目前还比较少，但作为后起之秀指日可待。</p>
<p>8.使用轻量级框架</p>
<p>除非你只用现有的编码知识构建网站，不然，你可以尝试使用一个好的前端框架来避免许多不必要的前端优化错误。虽然有一些更大，更知名的框架能提供更多功能和选项，但它们不一定适合你的 Web 项目。</p>
<p>所以说，不仅确定项目所需功能很重要，选择合适的框架也很重要——它要在提供所需功能的同时保持轻量。最近许多框架都使用简洁的 HTML，CSS 和 JavaScript 代码。</p>
<h2 id="一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？"><a href="#一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？" class="headerlink" title="一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？"></a>一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？</h2><p>参考链接：<br>详细解读<a href="https://segmentfault.com/a/1190000006879700" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006879700</a><br>详细解读<a href="https://mp.weixin.qq.com/s/jjL4iA7p6aYEAQyWhn4QbQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/jjL4iA7p6aYEAQyWhn4QbQ</a></p>
<p>输入地址<br>1.浏览器查找域名的 IP 地址<br>2.这一步包括 DNS 具体的查找过程，包括：浏览器缓存-&gt;系统缓存-&gt;路由器缓存…<br>3.浏览器向 web 服务器发送一个 HTTP 请求<br>4.服务器的永久重定向响应（从 <a href="http://example.com" target="_blank" rel="noopener">http://example.com</a> 到 <a href="http://www.example.com）" target="_blank" rel="noopener">http://www.example.com）</a><br>5.浏览器跟踪重定向地址<br>6.服务器处理请求<br>7.服务器返回一个 HTTP 响应<br>8.浏览器显示 HTML<br>9.浏览器发送请求获取嵌入在 HTML 中的资源（如图片、音频、视频、CSS、JS等等）<br>10.浏览器发送异步请求</p>
<h2 id="URL-到底是啥"><a href="#URL-到底是啥" class="headerlink" title="URL 到底是啥"></a>URL 到底是啥</h2><p>URL（Uniform Resource Locator），统一资源定位符，用于定位互联网上资源，俗称网址。</p>
<p><code>scheme://host.domain:port/path/filename</code><br>各部分解释如下：<br>scheme - 定义因特网服务的类型。常见的协议有 http、https、ftp、file，其中最常见的类型是 http，而 https 则是进行加密的网络传输。<br>host - 定义域主机（http 的默认主机是 www）<br>domain - 定义因特网域名，比如 w3school.com.cn<br>port - 定义主机上的端口号（http 的默认端口号是 80）<br>path - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。<br>filename - 定义文档/资源的名称</p>
<h2 id="讲tcp-ip网络层、三次握手，为什么不能两次握手"><a href="#讲tcp-ip网络层、三次握手，为什么不能两次握手" class="headerlink" title="讲tcp/ip网络层、三次握手，为什么不能两次握手"></a>讲tcp/ip网络层、三次握手，为什么不能两次握手</h2><blockquote>
<p>客服端和服务端在进行http请求和返回的工程中，需要创建一个TCP connection（由客户端发起）,http不存在连接这个概念，它只有请求和响应。请求和响应都是数据包，它们之间的传输通道就是TCP connection。</p>
</blockquote>
<p>位码即tcp标志位，有6种标示：SYN(synchronous建立联机) ACK(acknowledgement 确认) PSH(push传送) FIN(finish结束) RST(reset重置) URG(urgent紧急)Sequence number(顺序号码) Acknowledge number(确认号码)</p>
<p>第一次握手：主机A发送位码为syn＝1，随机产生seq number=1234567的数据包到服务器，主机B由SYN=1知道，A要求建立联机；（第一次握手，由浏览器发起，告诉服务器我要发送请求了）</p>
<p>第二次握手：主机B收到请求后要确认联机信息，向A发送ack number=(主机A的seq+1)，syn=1，ack=1，随机产生seq=7654321的包；（第二次握手，由服务器发起，告诉浏览器我准备接受了，你赶紧发送吧）</p>
<p>第三次握手：主机A收到后检查ack number是否正确，即第一次发送的seq number+1，以及位码ack是否为1，若正确，主机A会再发送ack number=(主机B的seq+1)，ack=1，主机B收到后确认seq值与ack=1则连接建立成功；（第三次握手，由浏览器发送，告诉服务器，我马上就发了，准备接受吧）</p>
<blockquote>
<p>谢希仁著《计算机网络》中讲“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</p>
</blockquote>
<p>这种情况是：一端(client)A发出去的第一个连接请求报文并没有丢失，而是因为某些未知的原因在某个网络节点上发生滞留，导致延迟到连接释放以后的某个时间才到达另一端(server)B。本来这是一个早已失效的报文段，但是B收到此失效的报文之后，会误认为是A再次发出的一个新的连接请求，于是B端就向A又发出确认报文，表示同意建立连接。如果不采用“三次握手”，那么只要B端发出确认报文就会认为新的连接已经建立了，但是A端并没有发出建立连接的请求，因此不会去向B端发送数据，B端没有收到数据就会一直等待，这样B端就会白白浪费掉很多资源。如果采用“三次握手”的话就不会出现这种情况，B端收到一个过时失效的报文段之后，向A端发出确认，此时A并没有要求建立连接，所以就不会向B端发送确认，这个时候B端也能够知道连接没有建立。</p>
<p>问题的本质是，信道是不可靠的，但是我们要建立可靠的连接发送可靠的数据，也就是数据传输是需要可靠的。在这个时候三次握手是一个理论上的最小值，并不是说是tcp协议要求的，而是为了满足在不可靠的信道上传输可靠的数据所要求的。</p>
<p>这个网上转载的例子不错：</p>
<p>三次握手：<br>A:“喂，你听得到吗？”A-&gt;SYN_SEND<br>B:“我听得到呀，你听得到我吗？”应答与请求同时发出 B-&gt;SYN_RCVD | A-&gt;ESTABLISHED<br>A:“我能听到你，今天balabala……”B-&gt;ESTABLISHED</p>
<p>四次挥手：<br>A:“喂，我不说了。”A-&gt;FIN_WAIT1<br>B:“我知道了。等下，上一句还没说完。Balabala…..”B-&gt;CLOSE_WAIT | A-&gt;FIN_WAIT2<br>B:”好了，说完了，我也不说了。”B-&gt;LAST_ACK<br>A:”我知道了。”A-&gt;TIME_WAIT | B-&gt;CLOSED<br>A等待2MSL,保证B收到了消息,否则重说一次”我知道了”,A-&gt;CLOSE</p>
<h2 id="iframe有那些缺点？"><a href="#iframe有那些缺点？" class="headerlink" title="iframe有那些缺点？"></a>iframe有那些缺点？</h2><p>1.iframe会阻塞主页面的Onload事件；<br>2.搜索引擎的检索程序无法解读这种页面，不利于SEO;<br>3.iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。<br>4.使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript动态给iframe添加src属性值，这样可以绕开以上两个问题</p>
<h2 id="websocket握手过程"><a href="#websocket握手过程" class="headerlink" title="websocket握手过程"></a>websocket握手过程</h2><p>在实现websocket连线过程中，需要通过浏览器发出websocket连线请求，然后服务器发出回应，这个过程通常称为“握手” (handshaking)。</p>
<p>客户端请求web socket连接时，会向服务器端发送握手请求</p>
<p>请求头大致内容:</p>
<blockquote>
<p>请求包说明：</p>
<ul>
<li>必须是有效的http request 格式；</li>
<li>HTTP request method 必须是GET，协议应不小于1.1 如： Get / HTTP/1.1；</li>
<li>必须包括Upgrade头域，并且其值为”websocket”;</li>
<li>必须包括”Connection” 头域，并且其值为”Upgrade”;</li>
<li>必须包括”Sec-WebSocket-Key”头域，其值采用base64编码的随机16字节长的字符序列;</li>
<li>如果请求来自浏览器客户端，还必须包括Origin头域 。 该头域用于防止未授权的跨域脚本攻击，服务器可以从Origin决定是否接受该WebSocket连接;</li>
<li>必须包括”Sec-webSocket-Version” 头域，当前值必须是13;</li>
<li>可能包括”Sec-WebSocket-Protocol”，表示client（应用程序）支持的协议列表，server选择一个或者没有可接受的协议响应之;</li>
<li>可能包括”Sec-WebSocket-Extensions”， 协议扩展， 某类协议可能支持多个扩展，通过它可以实现协议增强;</li>
<li>可能包括任意其他域，如cookie.</li>
</ul>
</blockquote>
<p>服务端响应如下:</p>
<blockquote>
<p>应答包说明：</p>
</blockquote>
<blockquote>
<ul>
<li>必须包括Upgrade头域，并且其值为”websocket”; 必须包括Connection头域，并且其值为”Upgrade”;</li>
<li>必须包括Sec-WebSocket-Accept头域，其值是将请求包“Sec-WebSocket-Key”的值，与”258EAFA5-E914-47DA-95CA-C5AB0DC85B11″这个字符串进行拼接，然后对拼接后的字符串进行sha-1运算，再进行base64编码，就是“Sec-WebSocket-Accept”的值； 应答包中冒号后面有一个空格；</li>
<li>最后需要两个空行作为应答包结束</li>
</ul>
</blockquote>
<p>参考链接：</p>
<p><a href="https://yq.aliyun.com/articles/229594" target="_blank" rel="noopener">Websocket协议之握手连接</a></p>
<h2 id="跨域以及解决办法"><a href="#跨域以及解决办法" class="headerlink" title="跨域以及解决办法"></a>跨域以及解决办法</h2><ul>
<li><p>同源<br>符合”协议+域名+端口”三者相同，就是同源</p>
</li>
<li><p>同源策略<br>同源策略，其初衷是为了浏览器的安全性，通过以下三种限制，保证浏览器不易受到XSS、CSFR等攻击。</p>
<ul>
<li>Cookie、LocalStorage 和 IndexDB 无法读取</li>
<li>DOM 和 Js对象无法获得</li>
<li>AJAX 请求不能发送</li>
<li>跨域解决方案</li>
</ul>
</li>
<li><p>通过jsonp跨域</p>
<ul>
<li>document.domain + iframe跨域</li>
<li>location.hash + iframe</li>
<li>window.name + iframe跨域</li>
<li>postMessage跨域</li>
<li>跨域资源共享（CORS）</li>
<li>nginx代理跨域</li>
<li>nodejs中间件代理跨域</li>
<li>WebSocket协议跨域</li>
</ul>
</li>
</ul>
<h2 id="前端持久化的方式、区别"><a href="#前端持久化的方式、区别" class="headerlink" title="前端持久化的方式、区别"></a>前端持久化的方式、区别</h2><p>最容易想到的解决方案是：</p>
<p>1.使用前端cookie技术来保存本地化数据，如jquery.cookie.js；<br>2.使用html5提供的Web Storage技术来提供解决方案；</p>
<p>用cookie存储永久数据存在以下几个问题：<br>1.大小：cookie的大小被限制在4KB。<br>2.带宽：cookie是随HTTP事务一起被发送的，因此会浪费一部分发送cookie时使用的带宽。<br>3.复杂性：要正确的操纵cookie是很困难的。</p>
<p>针对这些问题，在HTML5中，重新提供了一种在客户端本地保存数据的功能，它就是Web Storage。<br>具体来说，Web Storage又分为两种：<br>1.sessionStorage：将数据保存在session对象中。所谓session，是指用户在浏览某个网站时，从进入网站到浏览器关闭所经过的这段时间，也就是用户浏览这个网站所花费的时间。session对象可以用来保存在这段时间内所要求保存的任何数据。<br>2.localStorage：将数据保存在客户端本地的硬件设备(通常指硬盘，也可以是其他硬件设备)中，即使浏览器被关闭了，该数据仍然存在，下次打开浏览器访问网站时仍然可以继续使用。</p>
<p>这两者的区别在于，sessionStorage为临时保存，而localStorage为永久保存。</p>
<p><a href="http://www.cnblogs.com/DevinnZ/p/6752574.html" target="_blank" rel="noopener">前端持久化–evercookie</a></p>
<h2 id="介绍http2-0"><a href="#介绍http2-0" class="headerlink" title="介绍http2.0"></a>介绍http2.0</h2><ul>
<li>所有数据以二进制传输。HTTP1.x是基于文本的，无法保证健壮性，HTTP2.0绝对使用新的二进制格式，方便且健壮</li>
<li>同一个连接里面发送多个请求不再需要按照顺序来</li>
<li>头信息压缩以及推送等提高效率的功能<br><a href="https://www.jdon.com/dl/http2.html" target="_blank" rel="noopener">Http 2.0协议简介</a><br><a href="http://www.513bk.com/xdjq/1159147.html#top" target="_blank" rel="noopener">HTTP 2.0 详细介绍，http2.0详细介绍</a><br><a href="https://www.zhihu.com/question/34074946" target="_blank" rel="noopener">HTTP/2.0 相比1.0有哪些重大改进</a></li>
</ul>
<h2 id="通过什么做到并发请求"><a href="#通过什么做到并发请求" class="headerlink" title="通过什么做到并发请求"></a>通过什么做到并发请求</h2><p>我能想到的只有<code>Promise.all()</code>,欢迎补充</p>
<h2 id="b和strong的区别"><a href="#b和strong的区别" class="headerlink" title="b和strong的区别"></a>b和strong的区别</h2><p><code>&lt;b&gt;</code> 粗体文本，<code>&lt;strong&gt;</code> 用于强调文本,他们的样式是一样的<br>有一种说法，是<code>&lt;strong&gt;</code>貌似在盲人用的机器上会读两遍。因为没有对应的测试条件，所以没做验证。</p>
<h2 id="Access-Control-Allow-Origin在服务端哪里配置"><a href="#Access-Control-Allow-Origin在服务端哪里配置" class="headerlink" title="Access-Control-Allow-Origin在服务端哪里配置"></a>Access-Control-Allow-Origin在服务端哪里配置</h2><p><code>header(&#39;Access-Control-Allow-Origin:*&#39;);</code></p>
<h2 id="csrf跨站攻击怎么解决"><a href="#csrf跨站攻击怎么解决" class="headerlink" title="csrf跨站攻击怎么解决"></a>csrf跨站攻击怎么解决</h2><p>CSRF，全称为Cross-Site Request Forgery，跨站请求伪造，是一种网络攻击方式，它可以在用户毫不知情的情况下，以用户的名义伪造请求发送给被攻击站点，从而在未授权的情况下进行权限保护内的操作。</p>
<p>具体来讲，可以这样理解CSRF。攻击者借用用户的名义，向某一服务器发送恶意请求，对服务器来讲，这一请求是完全合法的，但攻击者确完成了一个恶意操作，比如以用户的名义发送邮件，盗取账号，购买商品等等</p>
<p>一般网站防御CSRF攻击的方案:<br>(1)验证token值。<br>(2)验证HTTP头的Referer。<br>(3)在HTTP头中自定义属性并验证<br>(4)服务器端表单hash认证<br>在所有的表单里面随机生成一个hash，server在表单处理时去验证这个hash值是否正确，这样工作量比较大</p>
<p><a href="https://www.cnblogs.com/xinaixia/p/5852379.html" target="_blank" rel="noopener">CSRF(跨站请求伪造攻击)漏洞详解</a></p>
<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="清除浮动的方式"><a href="#清除浮动的方式" class="headerlink" title="清除浮动的方式"></a>清除浮动的方式</h2><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一种</span></span><br><span class="line"><span class="selector-class">.ovh</span>&#123;</span><br><span class="line">  <span class="attribute">overflow</span>:hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第二种</span></span><br><span class="line"><span class="selector-class">.clear</span>&#123;</span><br><span class="line">  <span class="attribute">clear</span>:both;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第三种</span></span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span>&#123; </span><br><span class="line">　<span class="attribute">content</span>:<span class="string">""</span>;<span class="comment">//设置内容为空</span></span><br><span class="line">　<span class="attribute">height</span>:<span class="number">0</span>;<span class="comment">//高度为0</span></span><br><span class="line">　<span class="attribute">line-height</span>:<span class="number">0</span>;<span class="comment">//行高为0</span></span><br><span class="line">　<span class="attribute">display</span>:block;<span class="comment">//将文本转为块级元素</span></span><br><span class="line">　<span class="attribute">visibility</span>:hidden;<span class="comment">//将元素隐藏</span></span><br><span class="line">　<span class="attribute">clear</span>:both//清除浮动</span><br><span class="line">&#125;</span><br><span class="line">.clearfix&#123;</span><br><span class="line">　zoom:<span class="number">1</span>;为了兼容IE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当给父元素设置”overflow:hidden”时，实际上创建了一个超级属性BFC，此超级属性反过来决定了”height:auto”是如何计算的。在“BFC布局规则”中提到：计算BFC的高度时，浮动元素也参与计算。因此，父元素在计算其高度时，加入了浮动元素的高度，“顺便”达成了清除浮动的目标，所以父元素就包裹住了子元素。</p>
</blockquote>
<h2 id="BFC是什么"><a href="#BFC是什么" class="headerlink" title="BFC是什么"></a>BFC是什么</h2><p>BFC(Block Formatting Context),块级格式化上下文,是Web页面中盒模型布局的CSS渲染模式。它的定位体系属于常规文档流。</p>
<blockquote>
<p>浮动，绝对定位元素，inline-blocks, table-cells, table-captions,和overflow的值不为visible的元素，（除了这个值已经被传到了视口的时候）将创建一个新的块级格式化上下文。</p>
</blockquote>
<p>上面的引述几乎总结了一个BFC是怎样形成的。但是让我们以另一种方式来重新定义以便能更好的去理解。一个BFC是一个HTML盒子并且至少满足下列条件中的任何一个：</p>
<ul>
<li>float的值不为none</li>
<li>position的值不为static或者relative</li>
<li>display的值为 table-cell, table-caption, inline-block, flex, 或者 inline-flex中的其中一个</li>
<li>overflow的值不为visible </li>
</ul>
<h2 id="讲flex，手写出flex常用的属性，并且讲出作用"><a href="#讲flex，手写出flex常用的属性，并且讲出作用" class="headerlink" title="讲flex，手写出flex常用的属性，并且讲出作用"></a>讲flex，手写出flex常用的属性，并且讲出作用</h2><p>这个请看：  </p>
<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="js三座大山"><a href="#js三座大山" class="headerlink" title="js三座大山"></a>js三座大山</h2><p>原型与原型链，作用域及闭包，异步和单线程。</p>
<br>  
<p><a href="https://yangbo5207.github.io/wutongluo/ji-chu-jin-jie-xi-lie/shi-er-3001-shi-jian-xun-huan-ji-zhi.html" target="_blank" rel="noopener">事件循环机制</a></p>
<h2 id="bind、call、apply的区别"><a href="#bind、call、apply的区别" class="headerlink" title="bind、call、apply的区别"></a>bind、call、apply的区别</h2><p>1.每个函数都包含两个非继承而来的方法：call()方法和apply()方法。<br>2.相同点：这两个方法的作用是一样的。<br>都是在特定的作用域中调用函数，等于设置函数体内this对象的值，以扩充函数赖以运行的作用域。<br>一般来说，this总是指向调用某个方法的对象，但是使用call()和apply()方法时，就会改变this的指向。<br>3.不同点：接收参数的方式不同。</p>
<p>apply()方法 接收两个参数，一个是函数运行的作用域（this），另一个是参数数组。<br>语法：apply([thisObj [,argArray] ]);，调用一个对象的一个方法，2另一个对象替换当前对象。<br>说明：如果argArray不是一个有效数组或不是arguments对象，那么将导致一个TypeError，如果没有提供argArray和thisObj任何一个参数，那么Global对象将用作thisObj。<br>call()方法 第一个参数和apply()方法的一样，但是传递给函数的参数必须列举出来。<br>语法：call([thisObject[,arg1 [,arg2 [,…,argn]]]]);，应用某一对象的一个方法，用另一个对象替换当前对象。<br>说明： call方法可以用来代替另一个对象调用一个方法，call方法可以将一个函数的对象上下文从初始的上下文改变为thisObj指定的新对象，如果没有提供thisObj参数，那么Global对象被用于thisObj。</p>
<p>bind和call、apply最大的区别就是，call、apply不仅改变this的指向，还会直接支持代码，而bind不会。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cat = &#123;</span><br><span class="line">  name: <span class="string">'咪咪'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">beatTheMonster</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">beatTheMonster.call(cat);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.call 改变了this的指向。改变到了cat上。</span></span><br><span class="line"><span class="comment">// 2.beatTheMonster函数/方法执行了</span></span><br><span class="line"><span class="comment">// 3.bind()，保存了方法，并没有直接调用它</span></span><br></pre></td></tr></table></figure>
<p>原文链接：<a href="https://finget.github.io/2019/01/15/interview-questions/" target="_blank" rel="noopener">https://finget.github.io/2019/01/15/interview-questions/</a></p>
]]></content>
      <categories>
        <category>前端面试题</category>
      </categories>
      <tags>
        <tag>前端面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试题3</title>
    <url>/2020/09/21/%E5%89%8D%E7%AB%AF/%E6%9D%82%E8%AE%B0/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%983/</url>
    <content><![CDATA[<blockquote>
<p>渐进增强跟优雅降级的区别</p>
</blockquote>
<p>渐进增强写法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.transition</span>&#123;</span><br><span class="line">  <span class="attribute">-webkit-transition</span>: all .<span class="number">5s</span>;</span><br><span class="line">     <span class="attribute">-moz-transition</span>: all .<span class="number">5s</span>;</span><br><span class="line">       <span class="attribute">-o-transition</span>: all .<span class="number">5s</span>;</span><br><span class="line">          <span class="attribute">transition</span>: all .<span class="number">5s</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优雅降级写法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.transition</span>&#123; </span><br><span class="line">　　     <span class="attribute">transition</span>: all .<span class="number">5s</span>;</span><br><span class="line">　　  <span class="attribute">-o-transition</span>: all .<span class="number">5s</span>;</span><br><span class="line">  　<span class="attribute">-moz-transition</span>: all .<span class="number">5s</span>;</span><br><span class="line"> <span class="attribute">-webkit-transition</span>: all .<span class="number">5s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>渐进增强（progressive enhancement）：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。（从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能，向页面添加无害于基础浏览器的额外样式和功能。当浏览器支持时，它们会自动地呈现出来并发挥作用。）</p>
<p>优雅降级（graceful degradation）：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。但由于它们并非我们所关注的焦点，因此除了修复较 大的错误之外，其它的差异将被直接忽略。也就是以高要求，高版本为基准，向下兼容。</p>
<p>区别：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的、能够起作用的版本开始，并不断扩充，以适应未来环境的需要。</p>
<blockquote>
<p>进程跟线程的关系</p>
</blockquote>
<p>进程：是执行中一段程序，即一旦程序被载入到内存中并准备执行，它就是一个进程。进程是表示资源分配的的基本概念，又是调度运行的基本单位，是系统中的并发执行的单位。</p>
<p>线程：单个进程中执行中每个任务就是一个线程。线程是进程中执行运算的最小单位。</p>
<p>一个线程只能属于一个进程，但是一个进程可以拥有多个线程。多线程处理就是允许一个进程中在同一时刻执行多个任务。</p>
<p>区别：</p>
<ul>
<li><p>地址空间：同一进程的线程共享本进程的地址空间，而进程之间则是独立的地址空间。</p>
</li>
<li><p>资源拥有：同一进程内的线程共享本进程的资源如内存、I/O、cpu等，但是进程之间的资源是独立的。</p>
</li>
</ul>
<p>　　　　　一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。</p>
<p>　　　　　进程切换时，消耗的资源大，效率高。所以涉及到频繁的切换时，使用线程要好于进程。同样如果要求同时进行并且又要共享某些变量的并发操作，只能用线程不能用进程</p>
<ul>
<li><p>执行过程：每个独立的进程程有一个程序运行的入口、顺序执行序列和程序入口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</p>
</li>
<li><p>线程是处理器调度的基本单位，但是进程不是。</p>
</li>
<li><p>两者均可并发执行</p>
</li>
</ul>
<blockquote>
<p><code>react</code>中的<code>jsx</code>了解</p>
</blockquote>
<p><code>jsx</code>就是<code>javascipt+html</code>的混合写法</p>
<blockquote>
<p><code>react</code>中生命周期</p>
</blockquote>
<ul>
<li><p><code>componentWillMount</code>：组件将要被挂载，虚拟<code>dom</code>或者<code>react</code>元素转换成真正的<code>dom元</code>素，插入页面前执行的方法</p>
</li>
<li><p><code>render</code>:组件挂载过程，将<code>react</code>元素渲染成真正的dom元素，插入到页面中的过程</p>
</li>
<li><p><code>componentDidMount</code>:组件挂载完成，虚拟<code>dom</code></p>
</li>
<li><p><code>componentWillReceiveProps(newProps)</code>:组件将要接受新的属性对象,一般是父组件状态改变的时候，子组件的值也要更新。</p>
</li>
<li><p><code>shouldComponentUpdate(newProps,newState)</code>:组件是否要进行更新，状态发生改变的时候判断是否更新页面（状态是肯定变化了），一般来说都要更新，但是有时候不需要更新。该方法返回<code>true</code>的时候执行<code>componentWillUpdate</code>，否则不执行。两个参数：<code>newProps</code>新的属性对象，<code>newState</code>新的状态对象</p>
</li>
<li><p><code>componentWillUpdate</code>:组件将要更新</p>
</li>
<li><p><code>render</code>:重新更新</p>
</li>
<li><p><code>componentDidUpdate</code>:组件更新完成</p>
</li>
<li><p><code>componentWillUnmount</code>:组件卸载之前调用，可以清理一些定时器，或者是<code>componentDidMount</code>中手动添加的<code>dom</code>元素,避免内存泄露。</p>
</li>
</ul>
<blockquote>
<p><code>react</code>中请求接口为什么放在<code>componentDidMount</code>这个生命周期函数中?</p>
</blockquote>
<ul>
<li><p><code>React</code> 下一代调和算法 <code>Fiber</code> 会通圌过开始或停止渲染的方式优化应用性能，其会影响到 <code>componenТWillMount</code> 的触发次数。对于 <code>componenТWillMount</code> 这个生命周期函数的调用次数会变得不确定，<code>React</code> 可能会多次频繁调用<code>componenТWillMount</code>。如果我们将 <code>AJAX</code> 请求放到 <code>componenТWillMount</code> 函数中，那么显而易见其会被触发多次，自然也就不是好的选择。</p>
</li>
<li><p>如果我们将 <code>AJAX</code> 请求放置在生命周期的其他函数中，我们并不能保证请求仅在组件挂载完毕后才会要求响应。如果我们的数据请求在组件挂载之前就完成，并且调用了setState函数将数据添加到组件状态中，对于未挂载的组件则会报错。而在 <code>componentDidMount</code> 函数中进行 <code>AJAX</code> 请求则能有效避免这个问题。</p>
</li>
</ul>
<!-- >`react`中受控组件跟非受控组件的区别
>`react`中路由方式(以及传参方式)
>`vue`的生性周期函数(10个),active
>`vue`的`keep-alive`
>`vue`、`react`、`jquery`的区别
>`react`跟`react native`的区别
>`localstoarge`、`sessionstorage`、`cookie`的区别
>`es6`中`promise`的了解，几种状态。方法有那些
>`async、await`的了解，具体原理以及使用
>`es6`中的解构，`set`以及`map`
>`foreach`、`map`、`for...in`、`for...of`区别
>`bind`、`call`、`apply`的区别
>`h5`的语义化，`input`的有几种类型，
>`input`的`autocomplete`属性
>`css3`新增
>`css`样式的先后顺序
>`import`跟`link`的区别
>`jsonp`的原理
>`script`可以跨域的原理
`<script>`标签的`src`属性并不被同源策略所约束，所以可以获取任何服务器上脚本并执行。

>一个`div`在另一个`div`中居中的方式
>图片上传
>图片跟表单一起上传的方法
>什么是闭包，有什么缺点?
>介绍下项目：主要包括项目的搭建，路由，组件化，等
>对dva的了解 -->
]]></content>
      <categories>
        <category>前端面试题</category>
      </categories>
      <tags>
        <tag>前端面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>动画</title>
    <url>/2020/09/21/%E5%89%8D%E7%AB%AF/%E6%9D%82%E8%AE%B0/%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[<p>动画：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> myfirst&#123;</span><br><span class="line">    <span class="selector-tag">from</span> &#123;<span class="attribute">background</span>: red;&#125;</span><br><span class="line">    <span class="selector-tag">to</span> &#123;<span class="attribute">background</span>: yellow;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> myfirst&#123;</span><br><span class="line">    0%   &#123;<span class="attribute">background</span>: red;&#125;</span><br><span class="line">    25%  &#123;<span class="attribute">background</span>: yellow;&#125;</span><br><span class="line">    50%  &#123;<span class="attribute">background</span>: blue;&#125;</span><br><span class="line">    100% &#123;<span class="attribute">background</span>: green;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">animation</span>:myfirst <span class="number">5s</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>@keyframes</code>    规定动画<br><code>animation</code>    所有动画属性的简写属性，除了 <code>animation-play-state</code> 属性。<br><code>animation-name</code>    规定 <code>@keyframes</code> 动画的名称。<br><code>animation-duration</code>    规定动画完成一个周期所花费的秒或毫秒。默认是 0。<br><code>animation-timing-function</code>    规定动画的速度曲线。默认是 <code>&quot;ease&quot;</code>。<br><code>animation-delay</code>    规定动画何时开始。默认是 0。<br><code>animation-iteration-count</code>    规定动画被播放的次数。默认是 1。<br><code>animation-direction</code>    规定动画是否在下一周期逆向地播放。默认是 <code>&quot;normal&quot;</code>。<br><code>animation-play-state</code>    规定动画是否正在运行或暂停。默认是 <code>&quot;running&quot;</code><br><code>animation-fill-mode</code>    规定对象动画时间之外的状态。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transform</span>:translateX(<span class="number">50px</span>)</span><br><span class="line"><span class="attribute">transform</span>:translateY(<span class="number">50px</span>)</span><br><span class="line"><span class="function"><span class="title">translate</span><span class="params">(dx, dy)</span></span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title>常见正则</title>
    <url>/2020/09/21/%E5%89%8D%E7%AB%AF/%E6%9D%82%E8%AE%B0/%E6%AD%A3%E5%88%99/</url>
    <content><![CDATA[<blockquote>
<p>正整数</p>
</blockquote>
<p><code>let reg = /^[1-9]\d*$/</code></p>
<blockquote>
<p>数字、字母、数字字母组合</p>
</blockquote>
<p><code>let reg = /^[0-9a-zA-Z]{1,20}$/</code></p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>Js</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试题2</title>
    <url>/2020/09/21/%E5%89%8D%E7%AB%AF/%E6%9D%82%E8%AE%B0/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%982/</url>
    <content><![CDATA[<h1 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h1><h2 id="页面布局类"><a href="#页面布局类" class="headerlink" title="页面布局类"></a>页面布局类</h2><p>1.题目：假设高度已知，请写出三栏布局，其中左栏、右栏宽度各为300px，中间自适应。</p>
<p><code>float、position、flex、table、grid</code>五中解决方案</p>
<p>首先设置下整体样式</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    *&#123;</span><br><span class="line">        margin: 0;</span><br><span class="line">        padding: 0;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.layout</span>&#123;</span></span><br><span class="line">        margin-top: 20px;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.layout</span> <span class="selector-tag">article</span> <span class="selector-tag">div</span>&#123;</span></span><br><span class="line">        min-height: 100px;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>浮动解决方案</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"layout float"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span> <span class="attr">media</span>=<span class="string">"screen"</span>&gt;</span></span><br><span class="line"><span class="css">            <span class="selector-class">.layout</span><span class="selector-class">.float</span> <span class="selector-class">.left</span>&#123;</span></span><br><span class="line">                float: left;</span><br><span class="line">                width: 300px;</span><br><span class="line">                background-color: red;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="css">            <span class="selector-class">.layout</span><span class="selector-class">.float</span> <span class="selector-class">.right</span>&#123;</span></span><br><span class="line">                float: right;</span><br><span class="line">                width: 300px;</span><br><span class="line">                background-color: blue;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="css">            <span class="selector-class">.layout</span><span class="selector-class">.float</span> <span class="selector-class">.center</span>&#123;</span></span><br><span class="line">                background-color: yellow;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"left-right-center"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"center"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h1</span>&gt;</span>浮动解决方案<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">                1.这是三栏布局中间部分 浮动解决方案</span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>绝对定位解决方案</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"layout absolute"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span> <span class="attr">media</span>=<span class="string">"screen"</span>&gt;</span></span><br><span class="line"><span class="css">            <span class="selector-class">.layout</span><span class="selector-class">.absolute</span> <span class="selector-class">.left-right-center</span>&gt;<span class="selector-tag">div</span>&#123;</span></span><br><span class="line">                position: absolute;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="css">            <span class="selector-class">.layout</span><span class="selector-class">.absolute</span> <span class="selector-class">.left</span>&#123;</span></span><br><span class="line">                left: 0;</span><br><span class="line">                width: 300px;</span><br><span class="line">                background-color: red;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="css">            <span class="selector-class">.layout</span><span class="selector-class">.absolute</span> <span class="selector-class">.right</span>&#123;</span></span><br><span class="line">                right: 0;</span><br><span class="line">                width: 300px;</span><br><span class="line">                background-color: blue;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="css">            <span class="selector-class">.layout</span><span class="selector-class">.absolute</span> <span class="selector-class">.center</span>&#123;</span></span><br><span class="line">                left: 300px;</span><br><span class="line">                right: 300px;</span><br><span class="line">                background-color: yellow;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"left-right-center"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"center"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>绝对定位解决方案<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">                    1.这是三栏布局中间部分 绝对定位解决方案</span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>flex解决方案</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"layout flexbox"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">            <span class="selector-class">.layout</span><span class="selector-class">.flexbox</span>&#123;</span></span><br><span class="line">                margin-top: 140px;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="css">            <span class="selector-class">.layout</span><span class="selector-class">.flexbox</span> <span class="selector-class">.left-center-right</span>&#123;</span></span><br><span class="line">                display: flex;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="css">            <span class="selector-class">.layout</span><span class="selector-class">.flexbox</span> <span class="selector-class">.left</span>&#123;</span></span><br><span class="line">                width: 300px;</span><br><span class="line">                background: red</span><br><span class="line">            &#125;</span><br><span class="line"><span class="css">            <span class="selector-class">.layout</span><span class="selector-class">.flexbox</span> <span class="selector-class">.center</span>&#123;</span></span><br><span class="line">                flex: 1;</span><br><span class="line">                background-color: yellow</span><br><span class="line">            &#125;</span><br><span class="line"><span class="css">            <span class="selector-class">.layout</span><span class="selector-class">.flexbox</span> <span class="selector-class">.right</span>&#123;</span></span><br><span class="line">                width: 300px;</span><br><span class="line">                background-color: blue;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"left-center-right"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"center"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>flexobox解决方案<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">                    1.这是三栏布局中间部分 flexobox解决方案</span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>表格解决方案</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"layout table"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">            <span class="selector-class">.layout</span><span class="selector-class">.table</span> <span class="selector-class">.left-center-right</span>&#123;</span></span><br><span class="line">                width: 100%;</span><br><span class="line">                display: table;</span><br><span class="line">                height: 100px;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="css">            <span class="selector-class">.layout</span><span class="selector-class">.table</span> <span class="selector-class">.left-center-right</span>&gt;<span class="selector-tag">div</span>&#123;</span></span><br><span class="line">                display: table-cell</span><br><span class="line">            &#125;</span><br><span class="line"><span class="css">            <span class="selector-class">.layout</span><span class="selector-class">.table</span> <span class="selector-class">.left</span>&#123;</span></span><br><span class="line">                width: 300px;</span><br><span class="line">                background: red;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="css">            <span class="selector-class">.layout</span><span class="selector-class">.table</span> <span class="selector-class">.center</span>&#123;</span></span><br><span class="line">                background: yellow;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="css">            <span class="selector-class">.layout</span><span class="selector-class">.table</span> <span class="selector-class">.right</span>&#123;</span></span><br><span class="line">                width: 300px;</span><br><span class="line">                background: blue;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">acticle</span> <span class="attr">class</span>=<span class="string">"left-center-right"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"center"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>表格布局解决方案<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">                    1.这是三栏布局中间部分 表格布局解决方案</span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">acticle</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>网格解决方案</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"layout grid"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">            <span class="selector-class">.layout</span><span class="selector-class">.grid</span> <span class="selector-class">.left-center-right</span>&#123;</span></span><br><span class="line">                display: grid;</span><br><span class="line">                width: 100%;</span><br><span class="line">                grid-template-rows: 100px;</span><br><span class="line">                grid-template-columns: 300px auto 300px;</span><br><span class="line">            &#125;    </span><br><span class="line"><span class="css">            <span class="selector-class">.layout</span><span class="selector-class">.grid</span> <span class="selector-class">.left</span>&#123;</span></span><br><span class="line">                background: red</span><br><span class="line">            &#125;</span><br><span class="line"><span class="css">            <span class="selector-class">.layout</span><span class="selector-class">.grid</span> <span class="selector-class">.center</span>&#123;</span></span><br><span class="line">                background: yellow</span><br><span class="line">            &#125;</span><br><span class="line"><span class="css">            <span class="selector-class">.layout</span><span class="selector-class">.grid</span> <span class="selector-class">.right</span>&#123;</span></span><br><span class="line">                background: blue</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"left-center-right"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"center"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>网格布局解决方案<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">                    1.这是三栏布局中间部分 网格布局解决方案</span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>效果图展示</p>
<p><img src="/images/mianshijiqiao/sanlanbuju.png" alt></p>
<p>2.各种方案的优缺点</p>
<ul>
<li><p>浮动方案</p>
<p>  缺点：浮动会脱离文档流,清楚浮动需要处理好。</p>
<p>  优点：兼容性好</p>
</li>
<li><p>定位方案</p>
<p>  缺点：快捷方便</p>
<p>  优点：布局脱离文档流，所以其他下边的也需要定位，使用性差</p>
</li>
<li><p>flex方案</p>
<p>  缺点：</p>
<p>  优点：解决上述两个方案的缺点</p>
</li>
<li><p>表格方案</p>
<p>  缺点：操作行差</p>
<p>  优点：兼容性非常好，<code>ie8</code>不支持<code>flex</code>布局。两边的高度会根据中间高度变化。</p>
</li>
<li><p>网格方案</p>
<p>  缺点：</p>
<p>  优点：代码量少。</p>
</li>
</ul>
<p>（有不足之处，欢迎补充！！）</p>
<p>3.假设高度不固定，左右两侧的高度需要根据中间内容高度撑开，哪种还适用？</p>
<p>flex、表格布局还可以使用。两侧高度会随着中间高度改变。效果图如下：</p>
<p><img src="/images/mianshijiqiao/gaodubuding.png" alt></p>
<p>4.哪种兼容性更好？</p>
<h2 id="CSS盒模型、DOM事件类"><a href="#CSS盒模型、DOM事件类" class="headerlink" title="CSS盒模型、DOM事件类"></a>CSS盒模型、DOM事件类</h2><h3 id="CSS盒模型"><a href="#CSS盒模型" class="headerlink" title="CSS盒模型"></a>CSS盒模型</h3><p>1.谈谈对盒模型的认识</p>
<p>基本模型：<code>content、padding、border、margin</code></p>
<p>标准模型、IE模型</p>
<p>2.标准模型和IE模型的区别</p>
<ul>
<li><p>标准模型：</p>
<ul>
<li><p>宽 = <code>content</code>的宽</p>
</li>
<li><p>高 = <code>content</code>的高</p>
</li>
<li><p>不包含 <code>border</code> 跟 <code>padding</code> 的宽高</p>
</li>
</ul>
</li>
<li><p>IE模型：</p>
<ul>
<li><p>宽 = <code>content</code>的宽 + <code>padding</code> 宽 + <code>border</code>宽</p>
</li>
<li><p>高 = <code>content</code>的高 + <code>padding</code> 高 + <code>border</code>高</p>
</li>
<li><p>包含<code>border</code>跟<code>padding</code>的宽高</p>
</li>
</ul>
</li>
</ul>
<p>3.<code>css</code>如何让设置这两种类型</p>
<ul>
<li><p><code>box-sizing : border-box;</code> //设置为IE模型</p>
</li>
<li><p><code>box-sizing : content-box;</code> //标准模型</p>
</li>
</ul>
<p>4.JS如何设置盒模型对应的高度</p>
<ul>
<li><p><code>dom.style.width/height</code>                        //这种只能拿到内联样式</p>
</li>
<li><p><code>dom.currentStyle.width/height</code>                 //能拿到渲染后的各种样式的宽高，但是只有IE浏览器支持</p>
</li>
<li><p><code>window.getComputedStyle(dom).width/height</code>     //能拿到渲染后的各种样式的宽高，兼容性更好</p>
</li>
<li><p><code>dom.getBoundingClientRect().width/height</code>      //能拿到渲染后的各种样式的宽高，使用场所，计算一个元素的绝对位置，视窗的<code>left、top、width、height</code></p>
</li>
</ul>
<p>5.根据盒模型解释边距重叠</p>
<ul>
<li><p>父子元素、兄弟元素，当有外边距时，会取其中一个边距的最大值，作为实际的边距。</p>
</li>
<li><p>空元素的有上下边距时，也会取其中更大的一个边距值，作为实际的边距。</p>
</li>
</ul>
<p>这就是边距重叠。</p>
<p>6.<code>BFC</code>(边距重叠解决方案)</p>
<ul>
<li><p><code>BFC</code>的基本概念：块级、格式化、上下文</p>
</li>
<li><p><code>IFC</code>的内联元素的格式化、上下文</p>
</li>
<li><p><code>BFC</code>原理：</p>
<ul>
<li><p>在<code>BFC</code>元素的垂直方向边距会发生重叠</p>
</li>
<li><p><code>BFC</code>区域不会与浮动的box元素重叠（经常用来清除浮动的）</p>
</li>
<li><p><code>BFC</code>是一个独立的元素，外边的元素不会影响里边的元素，同理里边的元素也不会影响外边的元素，</p>
</li>
<li><p>计算<code>BFC</code>高度的时候，浮动的元素也会参与计算</p>
</li>
</ul>
</li>
<li><p>如何创建一个<code>BFC</code></p>
<ul>
<li><p><code>overflow: hidden||auto;</code></p>
</li>
<li><p><code>float</code>值不为<code>null</code></p>
</li>
<li><p><code>position</code>的值不为<code>relative、static</code></p>
</li>
<li><p><code>display</code>的值<code>tablel</code>类、<code>inline-box</code>的</p>
</li>
</ul>
</li>
</ul>
<h3 id="DOM事件"><a href="#DOM事件" class="headerlink" title="DOM事件"></a>DOM事件</h3><p>1.基本概念<code>DOM</code>事件的级别</p>
<p><code>DOM0</code>  <code>element.onclick=function(){}</code></p>
<p><code>DOM2</code>  <code>element.addEventListener(&#39;click&#39;,function(){},false)</code>   //第三个参数代表捕获还是冒泡,true代表捕获事件，false代表冒泡事件。</p>
<p><code>DOM3</code>  <code>element.addEventListener(&#39;keyup&#39;,function(){},false)</code></p>
<p>2.<code>DOM</code>事件模型：冒泡、捕获</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"ev"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-id">#ev</span>&#123;</span></span><br><span class="line">            width: 300px;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background: red;</span><br><span class="line"><span class="css">            <span class="selector-tag">color</span>: <span class="selector-id">#fff</span>;</span></span><br><span class="line">            text-align: center;</span><br><span class="line">            line-height: 100px;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">        目标元素</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> ev = <span class="built_in">document</span>.getElementById(<span class="string">'ev'</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'window captrue'</span>)</span></span><br><span class="line"><span class="actionscript">&#125;,<span class="literal">true</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'document captrue'</span>)</span></span><br><span class="line"><span class="actionscript">&#125;,<span class="literal">true</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.documentElement.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'html captrue'</span>)</span></span><br><span class="line"><span class="actionscript">&#125;,<span class="literal">true</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.body.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'body captrue'</span>)</span></span><br><span class="line"><span class="actionscript">&#125;,<span class="literal">true</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">ev.addEventListenerev.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'ev captrue'</span>)</span></span><br><span class="line"><span class="actionscript">&#125;,<span class="literal">true</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>效果图如下：(此图为捕获事件，冒泡事件把<code>true</code>改为<code>false</code>即可)</p>
<p><img src="/images/mianshijiqiao/buhuo1.png" alt></p>
<p>3.<code>DOM</code>事件流</p>
<p>事件流所描述的就是从页面中接受事件的顺序。</p>
<p>事件流三个阶段：</p>
<ul>
<li><p>捕获阶段</p>
</li>
<li><p>目标阶段</p>
</li>
<li><p>冒泡阶段</p>
</li>
</ul>
<p>4.描述<code>DOM</code>事件捕获的具体流程</p>
<p>捕获从大到小，<code>window-document-html(document.documentElement获取html)-body(document.body获取body元素)</code>-…-目标元素</p>
<p>冒泡从小到大，与捕获相反。</p>
<p>5.Event对象的常见应用</p>
<ul>
<li><p><code>event.preventDefault()</code>  //例如阻止<code>a</code>标签跳转的行为</p>
</li>
<li><p><code>event.stopPropagation()</code>  //阻止事件冒泡</p>
</li>
<li><p><code>event.stopImmediatePropagation()</code>   //事件响应的优先级，比如一个按钮上有事件<code>a</code>跟事件<code>b</code>,点击按钮时，想只触发事件<code>a</code>的不触发事件<code>b</code>,此时就在事件<code>a</code>中添加这句话，就阻止了事件<code>b</code>的触发</p>
</li>
<li><p><code>event.currentTarget</code>   //当前绑定的事件，值的是父级元素</p>
</li>
<li><p><code>event.target</code>   //当前被点击的子元素，用于事件委派</p>
</li>
</ul>
<p>6.自定义事件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"ev"</span>&gt;</span></span><br><span class="line">        目标元素</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> eve = <span class="keyword">new</span> Event(<span class="string">'test'</span>)  <span class="comment">//创建自定义事件，并且定义事件名称test</span></span></span><br><span class="line"><span class="actionscript">ev.addEventListener(<span class="string">'test'</span>,<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'test dispatchEvent'</span>)</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="actionscript">ev.dispatchEvent(eve)  <span class="comment">//事件的触发，触发的是时间对象，不是事件名称</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>效果如下图</p>
<p><img src="/images/mianshijiqiao/zidingyi.png" alt></p>
<p>自己理解：当一个按钮点击时触发的不是<code>click</code>这种事件，自己定义的一个名称叫做<code>custome</code>的事件，然后使用<code>ev</code>的<code>dom</code>节点使用<code>dispatchEvent</code>调用。</p>
<p>自定义事件可以使用<code>Event</code>，也可以使用<code>CustomEvent</code>，区别在于使用<code>CustomEvent</code>不仅仅可以指定事件名称，还可以跟一个<code>Oblect</code>作为指定参数，这可参数是自己定义的。</p>
<h2 id="HTTP协议类、原型链类"><a href="#HTTP协议类、原型链类" class="headerlink" title="HTTP协议类、原型链类"></a>HTTP协议类、原型链类</h2><h3 id="HTTP协议类"><a href="#HTTP协议类" class="headerlink" title="HTTP协议类"></a>HTTP协议类</h3><p>1.HTTP协议的主要特点</p>
<ul>
<li><p>简单快速  每个资源<code>uri</code>(统一资源符)是固定的，想访问某个资源，直接输入这个<code>uri</code>就可以了。</p>
</li>
<li><p>灵活      每个<code>http</code>协议中有一个头部分，会有一个额数据类型，通过一个<code>http</code>协议就可完成不同数据类型的传输</p>
</li>
<li><p>无连接    连接一次就会断掉 </p>
</li>
<li><p>无状态    客户端跟服务端两种身份，客户端向附区段请求一个图片，然后<code>http</code>协议帮助建立连接，帮助传输，传输完成就断开。下次请求在连接。</p>
</li>
</ul>
<p>2.HTTP报文的组成部分</p>
<ul>
<li><p>请求报文</p>
<ul>
<li><p>请求行</p>
<ul>
<li><p><code>http</code>方法</p>
</li>
<li><p>页面地址</p>
</li>
<li><p><code>http</code>协议以及版本</p>
</li>
</ul>
</li>
<li><p>请求头</p>
<ul>
<li>一些<code>key</code>、<code>value</code>值</li>
</ul>
</li>
<li><p>空行</p>
</li>
<li><p>请求体</p>
</li>
</ul>
</li>
<li><p>响应报文</p>
<ul>
<li><p>状态行</p>
</li>
<li><p>响应头</p>
</li>
<li><p>空行</p>
</li>
<li><p>响应体</p>
</li>
</ul>
</li>
</ul>
<p>3.HTTP的方法</p>
<ul>
<li><p><code>GET</code>    获取资源</p>
</li>
<li><p><code>POST</code>   传输资源</p>
</li>
<li><p><code>PUT</code>    根心资源</p>
</li>
<li><p><code>DELETE</code> 删除资源</p>
</li>
<li><p><code>HEAD</code>   活得报文首部</p>
</li>
</ul>
<p>4.<code>POST</code>和<code>GET</code>区别</p>
<ul>
<li><p><code>GET</code>在浏览器回退是无害的，而<code>POST</code>会再次提交请求</p>
</li>
<li><p><code>GET</code>请求会被浏览器主动缓存，而<code>POST</code>不会，除非手动设置</p>
</li>
<li><p><code>GET</code>请求参数会被完整保留才浏览器历史记录里，而<code>POST</code>中的参数不会被保留</p>
</li>
<li><p><code>GET</code>请求在<code>URL</code>中传送的参数长度是有限制的,一般是2<code>kb</code>，拼接的参数不要太长，会被<code>HTTP</code>协议截断，而<code>POST</code>没有限制</p>
</li>
<li><p><code>GET</code>参数通过<code>URL</code>传递，<code>POST</code>放在<code>Request body</code>中</p>
</li>
<li><p><code>GET</code>产生的<code>URL</code>的地址可以收藏，而<code>POST</code>不可以</p>
</li>
<li><p><code>GET</code>请求只能进行URL编码，而<code>POST</code>支持多种编码方式</p>
</li>
<li><p><code>GET</code>请求参数会被完整保留才浏览器历史记录里，而<code>POST</code>中的参数不会被保留</p>
</li>
<li><p>对参数的数据类型，<code>GET</code>只接受<code>ASCII</code>字符，而<code>POST</code>没有限制</p>
</li>
<li><p><code>GET</code>比<code>POST</code>更不安全，因为直接暴露在<code>URL</code>上，所以不能用来传输敏感信息</p>
</li>
</ul>
<p>5.HTTP状态码</p>
<ul>
<li><p>1xx:指示信息–表示请求已接收，继续处理</p>
</li>
<li><p>2xx:成功–表示请求已经被成功接受</p>
<ul>
<li><p>200:客户端请求成功</p>
</li>
<li><p>206:额护短发送了一个<code>Range</code>头的<code>GET</code>请求，服务端完成了它</p>
</li>
</ul>
</li>
<li><p>3xx:重定向–要完成请求必须进行更进一步的操作</p>
<ul>
<li><p>301:所有请求页面已经转移到新的<code>url</code></p>
</li>
<li><p>302:所有请求页面已经临时转移到新的<code>url</code></p>
</li>
<li><p>304:服务器告诉浏览器已经有缓存，可以取缓存的文档用</p>
</li>
</ul>
</li>
<li><p>4xx:客户端错误–请求有语法错误活请求无法实现</p>
<ul>
<li><p>400:客户端语法错误，不能被服务端理解</p>
</li>
<li><p>401:请求未经授权</p>
</li>
<li><p>403:请求的资源禁止被访问</p>
</li>
<li><p>404:请求资源不存在</p>
</li>
</ul>
</li>
<li><p>5xx:服务端错误–服务端未能实现合法的请求</p>
<ul>
<li>500:服务器错误</li>
</ul>
</li>
</ul>
<p>6.什么是持久连接</p>
<p>HTTP协议采用的是’请求-应答‘模式，每个请求/应答客户和服务器都要新建立一个链接，完成之后就立即断开(HTTP协议为无连接的协议)</p>
<p>HTTP协议1.1是支持持久连接的，当使用持久连接的时候，当出现客户端对服务端的后续请求的时候，持久连接避免了建立或者重新建立连接。</p>
<p>7.什么是管线化</p>
<ul>
<li>HTTP管线化是将多个HTTP请求（<code>request</code>）整批提交的技术，而在发送过程中不需先等待服务端的回应。</li>
</ul>
<p>在持久连接的情况下，某个连接上的消息的传递类似于：</p>
<p>请求1 -&gt; 相应1 -&gt; 请求2 -&gt; 相应2 -&gt; 请求3 -&gt; 相应3</p>
<p>管线化的某个连接上的消息的传递类似于：</p>
<p>请求1 -&gt; 请求2 -&gt; 请求3 -&gt; 相应1 -&gt; 相应2 -&gt; 相应3</p>
<ul>
<li><p>特点：</p>
<ul>
<li><p>管线化机制须透过永久连线完成,仅仅HTTP协议1.1</p>
</li>
<li><p>只有 <code>GET</code> 和 <code>HEAD</code>可以进行管线化，<code>POST</code> 有所限制</p>
</li>
<li><p>初次创建连线时也不应启动管线机制，因为对方（服务器）不一定支持 HTTP/1.1 版本的协议。</p>
</li>
<li><p>管线化不会影响响应到来的顺序，响应返回的顺序并未改变。</p>
</li>
</ul>
</li>
</ul>
<h2 id="面向对象类、通信类"><a href="#面向对象类、通信类" class="headerlink" title="面向对象类、通信类"></a>面向对象类、通信类</h2><h3 id="面向对象类"><a href="#面向对象类" class="headerlink" title="面向对象类"></a>面向对象类</h3><p>1.创建对象有几种方法</p>
<ul>
<li><p>字面量</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123;name:<span class="string">'o1'</span>&#125;</span><br><span class="line"><span class="keyword">var</span> o2= <span class="keyword">new</span> <span class="built_in">Object</span>(&#123;name:<span class="string">'o2'</span>&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>显式的构造函数</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> M = <span class="function"><span class="keyword">function</span><span class="params">(name)</span></span>&#123;<span class="keyword">this</span>.name = name&#125;</span><br><span class="line"><span class="keyword">var</span> o3 = <span class="keyword">new</span> M(<span class="string">'o3'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Object.create</code>方法</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> P = &#123;name:<span class="string">'o4'</span>&#125;</span><br><span class="line"><span class="keyword">var</span> o4 = <span class="built_in">Object</span>.create(P)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>2.原型</p>
<ul>
<li><p>所有引用类型都有一个<strong>proto</strong>(隐式原型)属性，属性值是一个普通的对象 </p>
</li>
<li><p>所有函数都有一个prototype(原型)属性，属性值是一个普通的对象 </p>
</li>
<li><p>所有引用类型的<strong>proto</strong>属性指向它构造函数的prototype</p>
</li>
</ul>
<p>构造函数：凡是被<code>new</code>使用了，后边的函数就是构造函数。任何函数都会有一个<code>prototype</code>属性,函数的<code>prototype</code>属性指的就是原型对象。</p>
<p>实例：只要是对象就是一个实例（o1 o2）就会有<code>__proto__</code>属性。</p>
<p>原型对象：原型对象中有有一个构造器<code>constructor</code>,这个构造器可以看出原型对象是被那个构造函数引用的。</p>
<p>3.原型链</p>
<p>原型链：当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会去它的<code>__proto__</code>隐式原型上查找，即它的构造函数的<code>prototype</code>，如果还没有找到就会再在构造函数的<code>prototype</code>的<code>__proto__</code>中查找，这样一层一层向上查找就会形成一个链式结构，我们称为原型链。</p>
<ul>
<li><p>一直往上层查找，直到到<code>null</code>还没有找到，则返回<code>undefined</code></p>
</li>
<li><p><code>Object.prototype.__proto__ === null</code> </p>
</li>
<li><p>所有从原型或更高级原型中的得到、执行的方法，其中的this在执行时，指向当前这个触发事件执行的对象</p>
</li>
</ul>
<p>3.<code>instanceof</code>的原理</p>
<p>原理是判断实例对象的<code>__proto__</code>属性跟构造函数的<code>prototype</code>属性是不是同一个引用，如果是，就成立，否则反之。只要是在一条原型链上的<code>instanceof</code>都会返回<code>true</code>。例如上述例子，<code>o3</code>是<code>M</code>构造函数的实例，也是<code>Obiect</code>的实例。所以使用<code>constructor</code>来判断更加准确。</p>
<p>如图所示：</p>
<p><img src="/images/mianshijiqiao/instanceof.png" alt></p>
<p>4.new运算符</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> new2 = function(<span class="function"><span class="keyword">func</span>)</span>&#123;    <span class="comment">//func为传入的构造函数</span></span><br><span class="line">    <span class="keyword">var</span> o = Object.create(<span class="function"><span class="keyword">func</span>.<span class="title">prototype</span>)    //创建一个对象，并且绑定构造函数的原型对象</span></span><br><span class="line">    <span class="keyword">var</span> k = <span class="function"><span class="keyword">func</span>.<span class="title">call</span><span class="params">(o)</span>;    //构造函数被执行，执行的时候上下文（<span class="title">this</span>）会被指定为这个新实例，使用<span class="title">call</span>转移<span class="title">func</span>的上下文</span></span><br><span class="line">    <span class="keyword">if</span>(typeof k === <span class="string">'object'</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> k    <span class="comment">//如果返回的是一个对象，那么整个对象会取代真个`new`出来的结果。</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o    <span class="comment">//没有返回一个对象时，那么 new 出来的结果为第一步创建的对象 o</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="类与实例"><a href="#类与实例" class="headerlink" title="类与实例"></a>类与实例</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类的声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'name'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// es6中class声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal2</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化  new后边的构造函数不传参数，那么有没有括号是一样的。</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Animal(),<span class="keyword">new</span> Animal2);</span><br></pre></td></tr></table></figure>
<h4 id="类与继承"><a href="#类与继承" class="headerlink" title="类与继承"></a>类与继承</h4><p>1.继承的几种方式</p>
<ul>
<li>借助构造函数实现继承<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'Parent1'</span></span><br><span class="line">&#125;</span><br><span class="line">Parent1.prototype.say=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Parent1.call(<span class="keyword">this</span>)  <span class="comment">//子类执行父类的构造函数，call/apply改变this指向。将父级的构造函数的this指向子构造函数Child的实例，所以子类有父类的所有属性以及方法。</span></span><br><span class="line">    <span class="keyword">this</span>.type = <span class="string">'Child1'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Child1)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Child1().say())</span><br><span class="line"><span class="comment">//此时Parent1原型链上的东西没有被Child1继承</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>打印结果图：<br><img src="/images/mianshijiqiao/gouzao1.png" alt>  </p>
<p><img src="/images/mianshijiqiao/gouzao2.png" alt></p>
<ul>
<li>借助原型链实现继承<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'Parent2'</span></span><br><span class="line">    <span class="keyword">this</span>.play = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.type = <span class="string">'Child2'</span></span><br><span class="line">&#125;</span><br><span class="line">Child2.prototype = <span class="keyword">new</span> Parent2(); <span class="comment">//Child2.prototype这个对象赋值为Parent2这个对象</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Child2)<span class="comment">//new Child2这个实例对象的__proto__跟Child2这个构造函数的prototype的属性是相等的。</span></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> Child2();</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="keyword">new</span> Child2();</span><br><span class="line"><span class="built_in">console</span>.log(s1.play,s2.play)</span><br><span class="line">s1.play.push(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s1.play,s2.play)</span><br><span class="line"><span class="comment">// 缺点：多个实例共享一个原型对象，有一个实例中改变原型对象中的某个属性，则其他实例使用的原型对象上的属性的值也回相应的改变。</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>打印结果图：<br><img src="/images/mianshijiqiao/yuanxinglian1.png" alt>  </p>
<p><img src="/images/mianshijiqiao/yuanxinglian2.png" alt></p>
<p><img src="/images/mianshijiqiao/yuanxinglian3.png" alt></p>
<ul>
<li>组合方式<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent3</span></span>()&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">'Parent3'</span></span><br><span class="line">    <span class="built_in">this</span>.play = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child3</span></span>()&#123;</span><br><span class="line">    Parent3.call(<span class="built_in">this</span>) <span class="comment">//第一次</span></span><br><span class="line">    <span class="built_in">this</span>.type = <span class="string">'Child3'</span></span><br><span class="line">&#125;</span><br><span class="line">Child3.prototype = <span class="keyword">new</span> <span class="type">Parent3</span>  <span class="comment">//第二次</span></span><br><span class="line">console.log(<span class="keyword">new</span> <span class="type">Child3</span>)</span><br><span class="line"><span class="keyword">var</span> s3 = <span class="keyword">new</span> <span class="type">Child3</span>();</span><br><span class="line"><span class="keyword">var</span> s4 = <span class="keyword">new</span> <span class="type">Child3</span>();</span><br><span class="line">s3.play.push(<span class="number">4</span>)</span><br><span class="line">console.log(s3.play,s4.play)</span><br><span class="line"><span class="comment">//缺点：实例化子类的时候，父类的构造函数执行了两次，</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>打印结果图：<br><img src="/images/mianshijiqiao/zuhe1.png" alt>  </p>
<p><img src="/images/mianshijiqiao/zuhe1.1.png" alt></p>
<ul>
<li>组合优化1<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent4</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'Parent4'</span></span><br><span class="line">    <span class="keyword">this</span>.play = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child4</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Parent4.call(<span class="keyword">this</span>) </span><br><span class="line">    <span class="keyword">this</span>.type = <span class="string">'Child4'</span></span><br><span class="line">&#125;</span><br><span class="line">Child4.prototype = Parent4.prototype  <span class="comment">//此处直接引用父类的原型对象，子类与父类用的是同一个原型对象</span></span><br><span class="line"><span class="keyword">var</span> s5 = <span class="keyword">new</span> Child4();</span><br><span class="line"><span class="keyword">var</span> s6 = <span class="keyword">new</span> Child4();</span><br><span class="line"><span class="built_in">console</span>.log(s5,s6)</span><br><span class="line"><span class="built_in">console</span>.log(s5 <span class="keyword">instanceof</span> Child4,s5 <span class="keyword">instanceof</span> Parent4)<span class="comment">//true true</span></span><br><span class="line"><span class="built_in">console</span>.log(s5.constructor)<span class="comment">//Parent4.prototype的constructor当然是Parent4自己</span></span><br><span class="line"><span class="comment">// 缺点：因为Child4跟Parent4公用的是一个原型对象。所以不能确定一个对象（s5）是由他的子类（Child4）实例化的还是由他的父类（Parent4）实例化的。</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>打印结果图：<br><img src="/images/mianshijiqiao/youhua1.png" alt>  </p>
<p><img src="/images/mianshijiqiao/youhua1.1.png" alt></p>
<ul>
<li>组合优化2<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent5</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'Parent5'</span></span><br><span class="line">    <span class="keyword">this</span>.play = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child5</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Parent5.call(<span class="keyword">this</span>) </span><br><span class="line">    <span class="keyword">this</span>.type = <span class="string">'Child5'</span></span><br><span class="line">&#125;</span><br><span class="line">Child5.prototype = <span class="built_in">Object</span>.create(Parent5.prototype)<span class="comment">//首先把父类子类的原型对象隔离</span></span><br><span class="line">Child5.prototype.constructor = Child5<span class="comment">//子类还是会通过原型对象找，需要给子类写一个自己的constructor。</span></span><br><span class="line"><span class="comment">// 通过创建中间对象的方法把Child5跟Parent5的原型对象区分开，这个中间对象的原型对象是指向父类的</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>打印结果图：<br><img src="/images/mianshijiqiao/zuizhong.png" alt>  </p>
<h3 id="通信类"><a href="#通信类" class="headerlink" title="通信类"></a>通信类</h3><p>1.什么是同源策略以及限制</p>
<p>同源策略：限制从一个源加载的文档或者脚本如何让与来自另一个源的资源进行交互。这还是一个用于隔离潜在恶意摁键的关键的安全机制。源包含：协议、域名、端口。</p>
<p>限制：</p>
<ul>
<li><p>cookie、localstorage、indexDB取法读取</p>
</li>
<li><p>DOM无法获得</p>
</li>
<li><p>AJAX请求不饿能发送</p>
</li>
</ul>
<p>2.前后端如何让通信</p>
<ul>
<li><p>Ajax:同源通信</p>
</li>
<li><p>webscoket:不受同源策略的限制</p>
</li>
<li><p>cors:支持跨域通信、也支持同源通信</p>
</li>
</ul>
<p>3.如何让创建Ajax</p>
<p>考察点：</p>
<ul>
<li><p>XMLHttpRequest对象的工作流程</p>
</li>
<li><p>兼容性处理</p>
</li>
<li><p>事件的出发条件</p>
</li>
<li><p>事件的出发顺序</p>
</li>
</ul>
<figure class="highlight qml"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">settings</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> type=settings.type||<span class="string">"get"</span>;</span><br><span class="line">	<span class="keyword">var</span> <span class="built_in">url</span>=settings.url;</span><br><span class="line">	<span class="keyword">var</span> data=settings.data||<span class="string">""</span>;</span><br><span class="line">	<span class="keyword">var</span> dataType=settings.dataType||<span class="string">""</span>;</span><br><span class="line">	<span class="keyword">var</span> success=settings.success;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">typeof</span> data===<span class="string">"object"</span>)&#123;</span><br><span class="line">		<span class="keyword">let</span> str=<span class="string">""</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> data)&#123;</span><br><span class="line">			str+=i+<span class="string">"="</span>+data[i]+<span class="string">"&amp;"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		data=str.slice(<span class="number">0</span>,<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> xhr=<span class="keyword">new</span> XMLHttpRequest ? <span class="keyword">new</span> XMLHttpRequest() : <span class="keyword">new</span> <span class="built_in">window</span>.ActiveXObject(<span class="string">'Microsoft.XMLHTTP'</span>);</span><br><span class="line">	<span class="keyword">if</span>(xhr.type===<span class="string">"get"</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(data===<span class="string">""</span>)&#123;</span><br><span class="line">			xhr.open(<span class="string">"get"</span>,<span class="built_in">url</span>);</span><br><span class="line">			xhr.send();</span><br><span class="line">		&#125;<span class="title">else</span>&#123;</span><br><span class="line">			xhr.open(<span class="string">"get"</span>,<span class="built_in">url</span>+<span class="string">"?"</span>+data);</span><br><span class="line">			xhr.send();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="title">else</span>&#123;</span><br><span class="line">		xhr.open(<span class="string">"post"</span>,<span class="built_in">url</span>);</span><br><span class="line">		xhr.setRequestHeader(<span class="string">"Content-Type"</span>,<span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line">		xhr.send(data);</span><br><span class="line">	&#125;</span><br><span class="line">	xhr.responseType=dataType;<span class="comment">//</span></span><br><span class="line">	xhr.onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">var</span> res=xhr.response;<span class="comment">//</span></span><br><span class="line">		<span class="keyword">if</span>(xhr.status === <span class="number">200</span> || xhr.status === <span class="number">304</span>)&#123;</span><br><span class="line">			success(res);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.跨域通信的方式</p>
<ul>
<li><p>jsonp：使用script标签的异步加载实现的</p>
</li>
<li><p>cors</p>
</li>
<li><p>websocket</p>
</li>
<li><p>hash:hash改变页面不刷新</p>
</li>
<li><p>postMessage</p>
</li>
</ul>
<!-- <!-- ## 前端安全类、前端算法类 -->
<h1 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h1><h2 id="渲染机制类"><a href="#渲染机制类" class="headerlink" title="渲染机制类"></a>渲染机制类</h2><p>1.什么是DOCTYPE以及作用</p>
<p>作用：告诉浏览器应当前文档是什么类型，声明文档类型和DTD规范的，DTD是文档类型定义</p>
<p>2.浏览器渲染过程</p>
<ul>
<li><p><code>html</code>转为<code>DOM Tree</code></p>
</li>
<li><p><code>css</code>转为<code>css Tree</code></p>
</li>
<li><p><code>DOM Tree</code>跟<code>css Tree</code>结合形成 <code>render tree</code></p>
</li>
<li><p><code>render tree</code>跟<code>layout</code>结合，精确计算<code>dom</code>的位置以及宽高</p>
</li>
<li><p>浏览器绘图</p>
</li>
</ul>
<p>3.重排Reflow</p>
<p>dom结构中的每个元素都有自己的盒子，这些都需要浏览器根据各种样式来计算结果将元素放到该出现的位置，这个过程会重排</p>
<p>4.重绘Repaint</p>
<p>当各种盒子的位置、大小以及其他属性，例如颜色、字体大小确定后，浏览器吧这些元素按照找各自的特性绘制一边，于是页面内容出现了，这个过程称为重绘</p>
<h2 id="JS运行机制"><a href="#JS运行机制" class="headerlink" title="JS运行机制"></a>JS运行机制</h2><p>1.JS的单线程机制：同一个时间只能干一件事</p>
<p>2.任务队列：同步任务队列、异步任务队列</p>
<p>3.事件循环机制</p>
<p>JS从上往下执行，先把同步任务放置同步队列中，把异步队列先挂起，到达指定时间，才把异步任务放到异步对列中，同步任务执行完，就去异步队列中查看是否有执行的，有，就拿到同步队列中执行，执行完，再去异步队列中查找，一次循环，知道执行完毕。</p>
<p>4.哪些语句是异步任务队列:setTimeout、setInterval、es6的promise、DOM事件(addEventListener)</p>
<p>5.异步语句放入异步任务队列的时间，不是立马放入异步任务队列，到达指定时间或者是点击事件出发后才会放入，即使延迟写的是0秒，也会在4s之后才加入异步任务队列。</p>
<h2 id="页面性能"><a href="#页面性能" class="headerlink" title="页面性能"></a>页面性能</h2><p>1.提升页面性能的方法：</p>
<ul>
<li><p>资源压缩合并，减少<code>HTTP</code>请求</p>
</li>
<li><p>非核心代码的异步加载–异步加载的方式有哪些–异步加载的区别</p>
</li>
<li><p>利用浏览器缓存–缓存的分类–缓存的原理</p>
</li>
<li><p>使用<code>cdn</code></p>
</li>
<li><p>预解析<code>dns</code></p>
<ul>
<li><p><code>head</code>中插入<code>&lt;link rel=&quot;dns-prefetch&quot;&gt;</code></p>
</li>
<li><p>页面中所有<code>a</code>标签默认打开dns预解析的，<code>https</code>开头的页面预解析是关闭的，徐强制打开的<code>&lt;meta http-equiv=&quot;x-dns-prefetch-control&gt;</code></p>
</li>
</ul>
</li>
</ul>
<p>2.异步加载的方式</p>
<ul>
<li><p>动态脚本加载:通过<code>js</code>创建的元素，然后添加到<code>body</code>中</p>
</li>
<li><p>defer</p>
</li>
<li><p>async</p>
</li>
</ul>
<p>3.异步加载方式的区别</p>
<ul>
<li><p><code>defer</code>是在<code>html</code>解析完成之后才会执行，如果是多个，按照加载的顺序依次执行</p>
</li>
<li><p><code>async</code>是在加载完成之后立即执行，如果是多个，执行顺序和加载顺序无关。</p>
</li>
</ul>
<p>4.缓存分为强缓存和协商缓存</p>
<h2 id="错误监控"><a href="#错误监控" class="headerlink" title="错误监控"></a>错误监控</h2><p>1.前端错误的分类</p>
<ul>
<li><p>代码错误</p>
</li>
<li><p>资源加载错误</p>
</li>
</ul>
<p>2.错误的捕获方式</p>
<ul>
<li><p>代码错误： <code>try..catch</code>     <code>window.onerror</code></p>
</li>
<li><p>资源错误：<code>obiect.onerror</code>     <code>performance.getEntries()</code>     <code>Error</code>事件捕获</p>
</li>
</ul>
<p>3.跨域的js运行错误可以捕获吗？错误提示是什么？应该怎么处理？</p>
<p>可以，提示：<code>script error</code> ,在客户端的<code>script</code>标签添加<code>crossorigin</code>属性，服务端设置<code>js</code>资源响应头<code>Access-Controol-Allow-Origin:*</code></p>
<p>4.上报错误的基本原理</p>
<ul>
<li><p>使用AJAX上报</p>
</li>
<li><p>使用image上报：(new Image()).src = ‘上报地址’</p>
</li>
</ul>
]]></content>
      <categories>
        <category>前端面试题</category>
      </categories>
      <tags>
        <tag>前端面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>数组的方法</title>
    <url>/2020/09/21/%E5%89%8D%E7%AB%AF/%E6%9D%82%E8%AE%B0/%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="数组常用方法"><a href="#数组常用方法" class="headerlink" title="数组常用方法"></a>数组常用方法</h2><ul>
<li>数组的方法</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//json数组格式</span></span><br><span class="line"><span class="keyword">let</span> json = &#123;</span><br><span class="line">  <span class="string">'0'</span> : <span class="string">'我是我'</span>,</span><br><span class="line">  <span class="string">'1'</span> : <span class="string">'你是你'</span>,</span><br><span class="line">  <span class="string">'2'</span> : <span class="string">'他是他'</span>,</span><br><span class="line">  length:<span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 转为数组</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.from(json)<span class="comment">//把json数组格式转为数组 ["我是我", "你是你", "他是他"]</span></span><br><span class="line"><span class="keyword">let</span> arr1 = <span class="built_in">Array</span>.of(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)<span class="comment">//转为数组 [3,4,5,6]</span></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="built_in">Array</span>.of(<span class="string">'测试1'</span>,<span class="string">'测试2'</span>)<span class="comment">//转为数组 ["测试1", "测试2"]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>concat():合并数组，首先会复制原数组，在合并，最后返回一个新的数组，原数组不变</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">let</span> <span class="string">arr</span> <span class="string">=</span> <span class="string">[11,22,33,44]</span></span><br><span class="line"><span class="string">let</span> <span class="string">arrCopy</span> <span class="string">=</span> <span class="string">arr.concat([55,66])</span></span><br><span class="line"><span class="string">console.log(arr,arrCopy)</span></span><br><span class="line"><span class="string">//</span> <span class="string">(4)</span> <span class="string">[11,</span> <span class="number">22</span><span class="string">,</span> <span class="number">33</span><span class="string">,</span> <span class="number">44</span><span class="string">]</span> <span class="string">(6)</span> <span class="string">[11,</span> <span class="number">22</span><span class="string">,</span> <span class="number">33</span><span class="string">,</span> <span class="number">44</span><span class="string">,</span> <span class="number">55</span><span class="string">,</span> <span class="number">66</span><span class="string">]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>copyWithin() 方法用于从数组的指定位置拷贝元素到数组的另一个指定位置中。<br>例子：复制数组索引3-4（4）的元素到数组索引为1的位置</li>
</ul>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].copyWithin(<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>) <span class="comment">// [1, 4, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>join(separator):将数组转换为字符串，接受一个参数，该参数为分割符，默认使用逗号。(一维数组)</li>
</ul>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line">console.<span class="keyword">log</span>(arr.<span class="keyword">join</span>(<span class="string">'-'</span>))<span class="comment">//11-22-33-44</span></span><br></pre></td></tr></table></figure>
<p>通过join()方法可以实现重复字符串，只需传入字符串以及重复的次数，就能返回重复后的字符串，函数如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">repeatString</span>(<span class="params">str, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Array</span>(n + <span class="number">1</span>).join(str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(repeatString(<span class="string">"abc"</span>, <span class="number">3</span>)); <span class="comment">// abcabcabc</span></span><br></pre></td></tr></table></figure>
<ul>
<li>split():用于把一个字符串分割成字符串数组,根据传递的参数来分割</li>
</ul>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[1,2,3,4,5]</span><span class="selector-class">.join</span>(<span class="string">'-'</span>)<span class="selector-class">.split</span>(<span class="string">'-'</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>push():在数组的末尾添加一个元素,返回的数组的长度</p>
</li>
<li><p>pop():在数组的末尾删除一个元素，返回的是删除的元素</p>
</li>
<li><p>unshift():在数组的初始位置添加一个元素，返回的是数组的长度</p>
</li>
<li><p>shift():在数组的初始位置删除一个元素，返回的是删除的元素，如果数组为空则返回 <code>undefined</code></p>
</li>
<li><p>sort()：按升序排列数组项——即最小的值位于最前面，最大的值排在最后面。</p>
</li>
</ul>
<p>在排序时，<code>sort()</code>方法会调用每个数组项的 <code>toString()</code>转型方法，然后比较得到的字符串，以确定如何排序。即使数组中的每一项都是数值,<code>sort()</code>方法比较的也是字符串，因此会出现以下的这种情况：</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="built_in">var</span> arr1 = [<span class="string">"a"</span>, <span class="string">"d"</span>, <span class="string">"c"</span>, <span class="string">"b"</span>];</span><br><span class="line">console.<span class="built_in">log</span>(arr1.<span class="built_in">sort</span>()); // [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>]</span><br><span class="line"></span><br><span class="line">arr2 = [<span class="number">13</span>, <span class="number">24</span>, <span class="number">51</span>, <span class="number">3</span>];</span><br><span class="line">console.<span class="built_in">log</span>(arr2.<span class="built_in">sort</span>()); // [<span class="number">13</span>, <span class="number">24</span>, <span class="number">3</span>, <span class="number">51</span>]</span><br><span class="line">console.<span class="built_in">log</span>(arr2); // [<span class="number">13</span>, <span class="number">24</span>, <span class="number">3</span>, <span class="number">51</span>](元数组被改变)</span><br></pre></td></tr></table></figure>
<p>为了解决上述问题，<code>sort()</code>方法可以接收一个比较函数作为参数，以便我们指定哪个值位于哪个值的前面。比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回 0，如果第一个参数应该位于第二个之后则返回一个正数。以下就是一个简单的比较函数：</p>
<figure class="highlight ceylon"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> compare(<span class="keyword">value</span><span class="number">1</span>, <span class="keyword">value</span><span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">value</span><span class="number">1</span> &lt; <span class="keyword">value</span><span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">value</span><span class="number">1</span> &gt; <span class="keyword">value</span><span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">arr<span class="number">2</span> = [<span class="number">13</span>, <span class="number">24</span>, <span class="number">51</span>, <span class="number">3</span>];</span><br><span class="line">console.log(arr<span class="number">2</span>.sort(compare)); <span class="comment">// [3, 13, 24, 51]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>reverse()：反转数组项的顺序。原数组改变.</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">var</span> <span class="string">arr</span> <span class="string">=</span> <span class="string">[13,</span> <span class="number">24</span><span class="string">,</span> <span class="number">51</span><span class="string">,</span> <span class="number">3</span><span class="string">];</span></span><br><span class="line"><span class="string">console.log(arr.reverse());</span> <span class="string">//[3,</span> <span class="number">51</span><span class="string">,</span> <span class="number">24</span><span class="string">,</span> <span class="number">13</span><span class="string">]</span></span><br><span class="line"><span class="string">console.log(arr);</span> <span class="string">//[3,</span> <span class="number">51</span><span class="string">,</span> <span class="number">24</span><span class="string">,</span> <span class="number">13</span><span class="string">]</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>slice()：返回从原数组中指定开始下标到结束下标之间的项组成的新数组。<code>slice()</code>方法可以接受一或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下，<code>slice()</code>方法返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项——但不包括结束位置的项。</p>
</li>
<li><p>splice()：可以实现删除、插入和替换。原数组改变。</p>
</li>
</ul>
<p>删除：可以删除任意数量的项，只需指定 2 个参数：要删除的第一项的位置和要删除的项数。例如:<code>splice(0,2)</code>会删除数组中的前两项。</p>
<p>插入：可以向指定位置插入任意数量的项，只需提供 3 个参数：起始位置、 0（要删除的项数）和要插入的项。例如，<code>splice(2,0,4,6)</code>会从当前数组的位置 2 开始插入4和6。</p>
<p>替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。例如，<code>splice (2,1,4,6)</code>会删除当前数组位置 2 的项，然后再从位置 2 开始插入4和6。</p>
<ul>
<li><p>indexOf()：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的开头（位置 0）开始向后查找。 </p>
</li>
<li><p>lastIndexOf()：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的末尾开始向前查找。</p>
</li>
</ul>
<p><code>indexOf()</code>和<code>lastIndexOf()</code>这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回-1。在比较第一个参数与数组中的每一项时，会使用全等操作符。</p>
<ul>
<li><p>includes():检查是否数组包含某些元素，返回 true 或 false </p>
</li>
<li><p>forEach():对数组进行遍历循环，对数组中的每一项运行给定函数。这个方法没有返回值。参数都是<code>function</code>类型，默认有传参，参数分别为：遍历的数组内容；第对应的数组索引，数组本身。</p>
</li>
<li><p>filter()：“过滤”功能，数组中的每一项运行给定函数，返回满足过滤条件组成的数组。  </p>
</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">var</span> <span class="string">arr</span> <span class="string">=</span> <span class="string">[1,</span> <span class="number">2</span><span class="string">,</span> <span class="number">3</span><span class="string">,</span> <span class="number">4</span><span class="string">,</span> <span class="number">5</span><span class="string">,</span> <span class="number">6</span><span class="string">,</span> <span class="number">7</span><span class="string">,</span> <span class="number">8</span><span class="string">,</span> <span class="number">9</span><span class="string">,</span> <span class="number">10</span><span class="string">];</span></span><br><span class="line"><span class="string">var</span> <span class="string">arr2</span> <span class="string">=</span> <span class="string">arr.filter(function(item,</span> <span class="string">index)</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="string">return</span> <span class="string">item</span> <span class="string">%</span> <span class="number">2</span> <span class="string">===</span> <span class="number">0</span> <span class="string">||</span> <span class="string">item</span> <span class="string">&gt;=</span> <span class="number">8</span><span class="string">;</span></span><br><span class="line"><span class="string">&#125;);</span> </span><br><span class="line"><span class="string">console.log(arr2);//[2,</span> <span class="number">4</span><span class="string">,</span> <span class="number">6</span><span class="string">,</span> <span class="number">8</span><span class="string">,</span> <span class="number">9</span><span class="string">,</span> <span class="number">10</span><span class="string">]</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>every()：判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回true。</p>
</li>
<li><p>some()：判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回true。</p>
</li>
<li><p>find():对数组中的每一项运行给定函数,返回符合条件的元素，之后的值不会再调用执行函数，如果没有返回undefined。对于空数组，函数是不会执行的。不改变原数组</p>
</li>
<li><p>fill():填充数组，fill(‘替换为什么’,’开始替换的下标’,’结束替换的下标（不包含结束的下标）’)</p>
</li>
<li><p>map():映射，一个对一个,对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。</p>
</li>
</ul>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">let arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">arr.map((item)=&gt;&#123;</span><br><span class="line">    return console.log(item*<span class="number">2</span>)</span><br><span class="line">&#125;)<span class="comment">//2,4,6,8,10,12</span></span><br></pre></td></tr></table></figure>
<ul>
<li>reduce()和 reduceRight()<br>这两个方法都会实现迭代数组的所有项，然后构建一个最终返回的值。 <code>reduce()</code>方法从数组的第一项开始，逐个遍历到最后。而 <code>reduceRight()</code>则从数组的最后一项开始，向前遍历到第一项。</li>
</ul>
<p>这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。</p>
<p>传给 <code>reduce()</code>和 <code>reduceRight()</code>的函数接收 4 个参数：前一个值、当前值、项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。</p>
<p>下面代码用<code>reduceRight()</code>实现数组求和，数组一开始加了一个初始值10。</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="built_in">var</span> <span class="built_in">values</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="built_in">var</span> <span class="built_in">sum</span> = <span class="built_in">values</span>.reduceRight(function(prev, cur, index, <span class="built_in">array</span>)&#123;</span><br><span class="line"><span class="built_in">return</span> prev + cur;</span><br><span class="line">&#125;,<span class="number">10</span>);</span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">sum</span>); //<span class="number">25</span></span><br></pre></td></tr></table></figure>
<h2 id="数组扁平化的方法"><a href="#数组扁平化的方法" class="headerlink" title="数组扁平化的方法"></a>数组扁平化的方法</h2><ul>
<li>toString &amp; split  调用数组的toString方法，将数组变为字符串然后再用split分割还原为数组</li>
</ul>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span><span class="params">(arr)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> arr.toString().split(<span class="string">','</span>).map(<span class="function"><span class="keyword">function</span><span class="params">(item)</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Number(item);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125; </span><br><span class="line">//[<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>]].toString()   结果：<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></span><br><span class="line">//[<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>]].toString().split(<span class="string">','</span>)   结果：[<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>join &amp; split   </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.join(<span class="string">','</span>).split(<span class="string">','</span>).map(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">parseInt</span>(item);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>JSON.stringify &amp; split  先转换为字符串，然后正则匹配</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(arr).replace(<span class="regexp">/[\[\]]/g</span>,<span class="string">''</span>).split(<span class="string">','</span>).map(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Number</span>(item)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>reduce  遍历数组每一项，若值为数组则递归遍历，否则concat。</li>
</ul>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">flatten</span>(arr) &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="type">arr.reduce((result,</span> item)=&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> result.concat(<span class="keyword">Array</span>.isArray(item) ? flatten(item) : <span class="type">item</span>);</span><br><span class="line">    &#125;, []);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>递归的遍历每一项，若为数组则继续遍历，否则concat</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res = [];</span><br><span class="line">    arr.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(item)) &#123;</span><br><span class="line">            res = res.concat(flatten(item));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res.push(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>es6的扩展运算符能将二维数组变为一维</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">console.log([].concat(...[1,</span> <span class="number">2</span><span class="string">,</span> <span class="number">3</span><span class="string">,</span> <span class="string">[4,</span> <span class="number">5</span><span class="string">]]))//</span> <span class="string">[1,</span> <span class="number">2</span><span class="string">,</span> <span class="number">3</span><span class="string">,</span> <span class="number">4</span><span class="string">,</span> <span class="number">5</span><span class="string">]</span></span><br><span class="line"><span class="string">console.log([].concat(...[1,</span> <span class="string">[2,</span> <span class="number">3</span><span class="string">,</span> <span class="string">[4,</span> <span class="number">5</span><span class="string">]]]))//(4)</span> <span class="string">[1,</span> <span class="number">2</span><span class="string">,</span> <span class="number">3</span><span class="string">,</span> <span class="string">Array(2)]</span></span><br></pre></td></tr></table></figure>
<p>单纯的使用扩展运算符，只适用于二维数组。所以我们遍历数组，有数组就使用扩展运算符，直到没有数组为止</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(arr.some(<span class="function"><span class="params">item</span>=&gt;</span><span class="built_in">Array</span>.isArray(item))) &#123;</span><br><span class="line">        arr = [].concat(...arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类数组转换为数组"><a href="#类数组转换为数组" class="headerlink" title="类数组转换为数组"></a>类数组转换为数组</h2><ul>
<li><code>Array.of</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = <span class="built_in">Array</span>.of(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)<span class="comment">//转为数组 [3,4,5,6]</span></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="built_in">Array</span>.of(<span class="string">'测试1'</span>,<span class="string">'测试2'</span>)<span class="comment">//转为数组 ["测试1", "测试2"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'[3,4,5,6]'</span></span><br><span class="line"><span class="keyword">let</span> leval = <span class="built_in">eval</span>(str) <span class="comment">//es5转为数组</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>遍历类数组，将元素依次添加到空数组中,使用前提是对象有Interator接口 </p>
</li>
<li><p>扩展运算符或者<code>Array.from()</code>方法转换,使用前提是对象有Interator接口    <code>arrlist</code>为类数组名称</p>
<p>  <code>[...arrlist]    Array.from(arrlist)</code></p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> json = &#123;</span><br><span class="line">    <span class="string">'0'</span> : <span class="string">'我是我'</span>,</span><br><span class="line">    <span class="string">'1'</span> : <span class="string">'你是你'</span>,</span><br><span class="line">    <span class="string">'2'</span> : <span class="string">'他是他'</span>,</span><br><span class="line">    length:3</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> arr = Array.from(json)  //json格式 [<span class="string">"我是我"</span>, <span class="string">"你是你"</span>, <span class="string">"他是他"</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>slice</code>方法</p>
<p>  <code>[].slice.call(arguments)</code> 或者 <code>Array.prototype.slice.call(arguments)</code></p>
</li>
<li><p>利用<code>apply</code>展开     <code>apply</code>方法的第二个参数是数组，也可以是类数组，在调用的时候会将第二个参数依次展开</p>
<p>  <code>[].concat.apply([],arrlist)</code></p>
</li>
</ul>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>Js</tag>
      </tags>
  </entry>
  <entry>
    <title>踩坑记录</title>
    <url>/2020/09/21/%E5%89%8D%E7%AB%AF/%E6%9D%82%E8%AE%B0/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>2019-11-16，今天突然觉醒了，有了学习的念头，对我来说不容易，立一个flag，从今天开始，记录每天自己采的坑，只为记录自己的采坑记录，不论难易程度。</p>
<blockquote>
<p>2020-06-22</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"123"</span></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    name: <span class="string">"tom"</span>,</span><br><span class="line">    say:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name) <span class="comment">// tom</span></span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">        <span class="comment">// setTimeout(function()&#123;</span></span><br><span class="line">        <span class="comment">//     console.log(this.name) // 此处this指向全局</span></span><br><span class="line">        <span class="comment">// &#125;, 1000);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">person.say()</span><br></pre></td></tr></table></figure>
<p><code>settimeout</code> 调用的代码，在执行时会与函数所在的环境分离，这样会使代码在执行时 <code>this</code> 在非严格模式下指向 <code>window</code> （全局）。严格情况下为 <code>undefined</code> ，但默认严格模式下是指向 <code>window</code>，不是 <code>undefined</code>。</p>
<blockquote>
<p>2020-06-22</p>
</blockquote>
<p><code>vue</code> 动态组件使用,根据不同角色展示不同组件，不使用费<code>if、else if</code></p>
<figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"info"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"roleComponent"</span> <span class="attr">v-if</span>=<span class="string">"roleComponent"</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml">import Admin from './admin'</span></span><br><span class="line"><span class="xml">import Hr from './hr'</span></span><br><span class="line"><span class="xml">import User from './user'</span></span><br><span class="line"><span class="xml">export default </span><span class="template-variable">&#123;</span></span><br><span class="line"><span class="template-variable">  components: &#123;</span></span><br><span class="line"><span class="template-variable">    Admin,</span></span><br><span class="line"><span class="template-variable">    Hr,</span></span><br><span class="line"><span class="template-variable">    User</span></span><br><span class="line"><span class="template-variable">  &#125;</span><span class="xml">,</span></span><br><span class="line"><span class="xml">  data() </span><span class="template-variable">&#123;</span></span><br><span class="line"><span class="template-variable">    return &#123;</span></span><br><span class="line"><span class="template-variable">      roleComponents: &#123;</span></span><br><span class="line"><span class="template-variable">        admin: Admin,</span></span><br><span class="line"><span class="template-variable">        hr: Hr,</span></span><br><span class="line"><span class="template-variable">        user: User</span></span><br><span class="line"><span class="template-variable">      &#125;</span><span class="xml">,</span></span><br><span class="line"><span class="xml">      role: 'user',</span></span><br><span class="line"><span class="xml">      roleComponent: undefined</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;,</span></span><br><span class="line"><span class="xml">  created() </span><span class="template-variable">&#123;</span></span><br><span class="line"><span class="template-variable">    const &#123; role, roleComponents &#125;</span><span class="xml"> = this</span></span><br><span class="line"><span class="xml">    this.roleComponent = roleComponents[role]</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>2020-06-21 防抖节流使用</p>
</blockquote>
<p>在使用 <code>input</code> 框的 <code>input</code> 事件的时候去掉接口，动态展示下拉列表的数据，此时需要防抖，废话不多说，直奔主题。</p>
<p><img src="/images/caikengjilu/fangdoujieshi.png" alt><br><img src="/images/caikengjilu/jieliujieshi.png" alt><br><img src="/images/caikengjilu/yingyongchangjing.png" alt></p>
<blockquote>
<p>防抖代码</p>
</blockquote>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> debounce = <span class="function"><span class="keyword">function</span><span class="params">(fn, delay)</span> </span>&#123;</span><br><span class="line">  let timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">(<span class="rest_arg">...args</span>)</span> </span>&#123;</span><br><span class="line">    let context = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span>(timer) clearTimeout(timer);</span><br><span class="line">    timer = setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      fn.apply(context, args);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>节流代码</p>
</blockquote>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> throttle = <span class="function"><span class="keyword">function</span><span class="params">(fn, interval)</span> </span>&#123;</span><br><span class="line">  let last = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">(<span class="rest_arg">...args</span>)</span> </span>&#123;</span><br><span class="line">    let context = <span class="keyword">this</span>;</span><br><span class="line">    let now = +<span class="keyword">new</span> Date();</span><br><span class="line">    <span class="comment">// 还没到时间</span></span><br><span class="line">    <span class="keyword">if</span>(now - last &lt; interval) <span class="keyword">return</span>;</span><br><span class="line">    last = now;</span><br><span class="line">    fn.apply(<span class="keyword">this</span>, args)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>2019-11-16  </p>
</blockquote>
<ul>
<li><code>input</code>的<code>onchange</code>的事件跟<code>oninput</code>事件<ul>
<li><code>onchange</code>事件是在内容改变后，并且失去焦点时才出发回调</li>
<li><code>oninput</code>事件是实时触发。</li>
</ul>
</li>
</ul>
<blockquote>
<p>2019-11-26</p>
</blockquote>
<p><code>mac</code>下安装<code>hexo-cli</code>，执行命令npm install -g hexo-cli时候， 报错如下的解决方法：<br><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">npm WARN checkPermissions Missing write access to /usr/<span class="keyword">local</span>/lib/node_modules/hexo-<span class="keyword">cli</span></span><br><span class="line">npm WARN checkPermissions Missing write access to /usr/<span class="keyword">local</span>/lib/node_modules/hexo-<span class="keyword">cli</span>/node_modules/chokidar</span><br><span class="line">npm <span class="keyword">ERR</span>! code EACCES</span><br><span class="line">npm <span class="keyword">ERR</span>! syscall access</span><br><span class="line">npm <span class="keyword">ERR</span>! path /usr/<span class="keyword">local</span>/lib/node_modules/hexo-<span class="keyword">cli</span></span><br><span class="line">npm <span class="keyword">ERR</span>! errno -13</span><br><span class="line">npm <span class="keyword">ERR</span>! <span class="keyword">Error</span>: EACCES: permission denied, access '/usr/<span class="keyword">local</span>/lib/node_modules/hexo-<span class="keyword">cli</span>'</span><br><span class="line">npm <span class="keyword">ERR</span>!  [<span class="keyword">Error</span>: EACCES: permission denied, access '/usr/<span class="keyword">local</span>/lib/node_modules/hexo-<span class="keyword">cli</span>'] &#123;</span><br><span class="line">npm <span class="keyword">ERR</span>!   <span class="keyword">stack</span>: <span class="string">"Error: EACCES: permission denied, access '/usr/local/lib/node_modules/hexo-cli'"</span>,</span><br><span class="line">npm <span class="keyword">ERR</span>!   errno: -13,</span><br><span class="line">npm <span class="keyword">ERR</span>!   code: 'EACCES',</span><br><span class="line">npm <span class="keyword">ERR</span>!   syscall: 'access',</span><br><span class="line">npm <span class="keyword">ERR</span>!   path: '/usr/<span class="keyword">local</span>/lib/node_modules/hexo-<span class="keyword">cli</span>'</span><br><span class="line">npm <span class="keyword">ERR</span>! &#125;</span><br><span class="line">npm <span class="keyword">ERR</span>! </span><br><span class="line">npm <span class="keyword">ERR</span>! The operation was rejected <span class="keyword">by</span> your operating system.</span><br><span class="line">npm <span class="keyword">ERR</span>! It is likely you <span class="keyword">do</span> not have the permissions to access this <span class="keyword">file</span> <span class="keyword">as</span> the current user</span><br><span class="line">npm <span class="keyword">ERR</span>! </span><br><span class="line">npm <span class="keyword">ERR</span>! <span class="keyword">If</span> you believe this might be a permissions issue, please double-check the</span><br><span class="line">npm <span class="keyword">ERR</span>! permissions of the <span class="keyword">file</span> and its containing directories, or try running</span><br><span class="line">npm <span class="keyword">ERR</span>! the command again <span class="keyword">as</span> root/Administrator.</span><br><span class="line"></span><br><span class="line">npm <span class="keyword">ERR</span>! A complete <span class="keyword">log</span> of this <span class="keyword">run</span> can be found <span class="keyword">in</span>:</span><br><span class="line">npm <span class="keyword">ERR</span>!     /Users/yuanyi/.npm/_logs/2019-10-30T11_43_55_100Z-debug.<span class="keyword">log</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>错误原因1:  没有使用管理员权限安装<br>解决方法:1.赋予目录权限   2.安装<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">sudo chown -R <span class="string">`whoami`</span> /usr/local/<span class="class"><span class="keyword">lib</span>/<span class="title">node_modules</span></span></span><br><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>2019-11-30</p>
</blockquote>
<p><code>vue</code>中父子组件传值，事件一定使用 <code>@</code>符号传递</p>
<blockquote>
<p>2020-03-12</p>
</blockquote>
<p>需求：vue中兄弟组件相互调用方法，父组件 <code>parent</code>,子组件1 <code>child1</code> 调用子组件2 <code>child2</code> 中的 <code>transOrderList</code> 方法</p>
<p>父组件:引入两个组件,父组件接收<code>child1</code>发送事件，给 <code>child2</code> 起名字 <code>refreshData</code><br><figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"account_root"</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">AccountBalanceModule</span> @<span class="attr">refreshList</span> =<span class="string">'refreshList'</span>/&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">TradingOrderModule</span> <span class="attr">ref</span>=<span class="string">'refreshData'</span>/&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">methods:&#123;</span><br><span class="line">    refreshList()&#123;</span><br><span class="line">        this.<span class="variable">$refs</span>.refreshData.transOrderList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>子组件1:<code>child1</code>发送事件给父组件<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">handleCloseServe</span><span class="params">()</span></span>&#123;</span><br><span class="line">    this.<span class="variable">$emit</span>(<span class="string">'refreshList'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>子组件2:<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">transOrderList</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>2020-06-04</p>
</blockquote>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">""</span> == <span class="number">0</span>) <span class="regexp">//</span> <span class="literal">true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">""</span> === <span class="number">0</span>) <span class="regexp">//</span> <span class="literal">false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> == <span class="literal">undefined</span>) <span class="regexp">//</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>1.场景：从系统<code>a</code>跳转到系统<code>b</code>携带参数，在系统<code>b</code>，使用该参数获取企业名称，存入<code>vuex</code>然后在<code>navbar</code>渲染，渲染迟缓，使用<code>computed</code>属性，得到解决。代码如下<br><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    companyName() &#123;</span><br><span class="line">      return this.<span class="variable">$store</span>.<span class="keyword">state</span>.<span class="keyword">user</span>.companyName;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>记录篇</category>
      </categories>
      <tags>
        <tag>记录篇</tag>
      </tags>
  </entry>
  <entry>
    <title>证书生成清晰度</title>
    <url>/2022/12/16/%E5%89%8D%E7%AB%AF/%E6%9D%82%E8%AE%B0/%E8%AF%81%E4%B9%A6%E7%94%9F%E6%88%90%E6%B8%85%E6%99%B0%E5%BA%A6/</url>
    <content><![CDATA[<h3 id="1-生成图片前需要把html的宽度放大一些，这样html2canvas才会清晰，生成完成后再把布局缩小回去，因为业务需要展示证书样式（此处使用布局展示）"><a href="#1-生成图片前需要把html的宽度放大一些，这样html2canvas才会清晰，生成完成后再把布局缩小回去，因为业务需要展示证书样式（此处使用布局展示）" class="headerlink" title="1.生成图片前需要把html的宽度放大一些，这样html2canvas才会清晰，生成完成后再把布局缩小回去，因为业务需要展示证书样式（此处使用布局展示）"></a>1.生成图片前需要把html的宽度放大一些，这样html2canvas才会清晰，生成完成后再把布局缩小回去，因为业务需要展示证书样式（此处使用布局展示）</h3><h3 id="2-图片转pdf时，设置画布大小一级图片大小"><a href="#2-图片转pdf时，设置画布大小一级图片大小" class="headerlink" title="2.图片转pdf时，设置画布大小一级图片大小"></a>2.图片转pdf时，设置画布大小一级图片大小</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// html转为图片（base64格式），且上传到七牛</span></span><br><span class="line"><span class="keyword">async</span> sureMade() &#123;</span><br><span class="line">  <span class="keyword">const</span> targetDom = <span class="built_in">document</span>.querySelector(<span class="string">'#certificate_box'</span>); <span class="comment">// html布</span></span><br><span class="line">  targetDom.style.transform = <span class="string">'scale(3, 3)'</span>;</span><br><span class="line">  <span class="keyword">this</span>.loading = <span class="literal">true</span>;</span><br><span class="line">  html2canvas(targetDom, &#123;</span><br><span class="line">    width: targetDom.scrollWidth * <span class="number">3</span>,</span><br><span class="line">    height: targetDom.scrollHeight * <span class="number">3</span>,</span><br><span class="line">    useCORS: <span class="literal">true</span>,</span><br><span class="line">  &#125;).then(<span class="function">(<span class="params">canvas</span>) =&gt;</span> &#123;</span><br><span class="line">    targetDom.style.transform = <span class="string">'scale(1,1)'</span></span><br><span class="line">    <span class="keyword">const</span> pageData = canvas.toDataURL(<span class="string">'image/jpeg'</span>, <span class="number">1.0</span>)</span><br><span class="line">    <span class="comment">//注意这个url,可以指定key(文件名), mimeType(文件类型)</span></span><br><span class="line">    <span class="keyword">var</span> url = <span class="string">"http://up.qiniu.com/putb64/-1"</span>;</span><br><span class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    xhr.open(<span class="string">"POST"</span>, url, <span class="literal">true</span>);</span><br><span class="line">    xhr.setRequestHeader(<span class="string">"Content-Type"</span>, <span class="string">"application/octet-stream"</span>);</span><br><span class="line">    xhr.setRequestHeader(<span class="string">"Authorization"</span>, <span class="string">`UpToken <span class="subst">$&#123;你的token&#125;</span>`</span>);</span><br><span class="line">    xhr.send(pageData.substring(<span class="number">23</span>));</span><br><span class="line">    xhr.onloadend = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123;status, responseText&#125; = e.currentTarget</span><br><span class="line">      <span class="keyword">if</span> (status == <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(responseText)</span><br><span class="line">        <span class="keyword">const</span> result = <span class="string">`<span class="subst">$&#123;域名&#125;</span>/<span class="subst">$&#123;上传后七牛返回的key&#125;</span>`</span></span><br><span class="line">        <span class="keyword">this</span>.madeCertificate(result) <span class="comment">// 掉后端的保存接口</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.loading = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">this</span>.$message.error(<span class="string">'生成失败'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 图片转pdf</span></span><br><span class="line">download()&#123;</span><br><span class="line">  <span class="keyword">const</span> loading = <span class="keyword">this</span>.$loading(&#123;</span><br><span class="line">    lock: <span class="literal">true</span>,</span><br><span class="line">    spinner: <span class="string">'el-icon-loading'</span>,</span><br><span class="line">    background: <span class="string">'rgba(0, 0, 0, 0.7)'</span></span><br><span class="line">  &#125;); <span class="comment">// 加loading，防止多次点击</span></span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> img = <span class="keyword">this</span>.$refs.refImg <span class="comment">// 获取图片</span></span><br><span class="line">    <span class="comment">// pdf的参数：pdf方向(横向，竖向), pdf大小单位，  pdf的宽，高 </span></span><br><span class="line">    <span class="keyword">const</span> PDF = <span class="keyword">new</span> <span class="built_in">window</span>.jspdf.default(<span class="string">'l'</span>, <span class="string">'px'</span>, [img.width + <span class="number">100</span>,img.height + <span class="number">100</span>]);</span><br><span class="line">    <span class="comment">// 生成时参数：图片url(eg:https://xxx.com/Fskhkaszh),图片格式，间距（相当于padding 上下，左右），生成时pdf中图片宽度，生成时pdf中图片图片高度</span></span><br><span class="line">    PDF.addImage(img, <span class="string">'JPEG'</span>, <span class="number">50</span>, <span class="number">50</span>, img.width, img.height);</span><br><span class="line">    <span class="comment">// 启用promise,完成后关闭loading</span></span><br><span class="line">    PDF.save(<span class="string">`<span class="subst">$&#123;文档名称&#125;</span>.pdf`</span>, &#123;<span class="attr">returnPromise</span>: <span class="literal">true</span>&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      loading.close()</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,<span class="number">100</span>)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>记录篇</category>
      </categories>
      <tags>
        <tag>记录篇</tag>
      </tags>
  </entry>
  <entry>
    <title>深浅拷贝</title>
    <url>/2020/09/21/%E5%89%8D%E7%AB%AF/%E6%9D%82%E8%AE%B0/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<h1 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h1><blockquote>
<p>浅拷贝能拷贝所有深层次的对象，但是拷贝后的深层次的对象与元对象还是引用的是同一个堆内存。所以改变拷贝的新的深层次的对象，原来的也会改变。但是不是引用类型的不受影响。</p>
</blockquote>
<blockquote>
<p>Object.assign()也可以实现浅复制</p>
</blockquote>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 浅克隆函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowClone</span></span>(o) &#123;</span><br><span class="line">  const obj = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> ( let i <span class="keyword">in</span> o) &#123;</span><br><span class="line">    obj[i] = o[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 被克隆对象</span></span><br><span class="line">const oldObj = &#123;</span><br><span class="line">  a: <span class="type">1</span>,</span><br><span class="line">  b: <span class="type"></span>[ <span class="string">'e'</span>, <span class="string">'f'</span>, <span class="string">'g'</span> ],</span><br><span class="line">  c: <span class="type"></span>&#123; h: <span class="type"></span>&#123; i: <span class="type">2 </span>&#125; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const <span class="keyword">new</span><span class="type">Obj</span> = shallowClone(oldObj);</span><br><span class="line">console.log(<span class="keyword">new</span><span class="type">Obj</span>.c.h, oldObj.c.h); <span class="comment">// &#123; i: 2 &#125; &#123; i: 2 &#125;</span></span><br><span class="line">console.log(oldObj.c.h === <span class="keyword">new</span><span class="type">Obj</span>.c.h); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 改变</span></span><br><span class="line"><span class="keyword">new</span><span class="type">Obj</span>.c.h = &#123;i:<span class="type">5</span>&#125;</span><br><span class="line">console.log(<span class="keyword">new</span><span class="type">Obj</span>.c.h, oldObj.c.h); <span class="comment">// &#123;i: 5&#125; &#123;i: 5&#125;</span></span><br><span class="line"><span class="keyword">new</span><span class="type">Obj</span>.a = <span class="number">2</span></span><br><span class="line">console.log(<span class="keyword">new</span><span class="type">Obj</span>.a, oldObj.a); <span class="comment">// 2 1</span></span><br><span class="line"><span class="keyword">new</span><span class="type">Obj</span>.b[<span class="number">0</span>] = <span class="string">'huang'</span></span><br><span class="line">console.log(<span class="keyword">new</span><span class="type">Obj</span>.b, oldObj.b); <span class="comment">// ["huang", "f", "g"] ["huang", "f", "g"]</span></span><br></pre></td></tr></table></figure>
<h1 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h1><h2 id="JSON-parse方法"><a href="#JSON-parse方法" class="headerlink" title="JSON.parse方法"></a>JSON.parse方法</h2><blockquote>
<p>使用<code>JSON.parse</code>跟<code>JSON.stringify</code>这两个方法可以实现深拷贝。</p>
</blockquote>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">const <span class="keyword">new</span><span class="type">Obj</span> = JSON.parse(JSON.stringify(oldObj));</span><br><span class="line"><span class="comment">//例子</span></span><br><span class="line">const oldObj = &#123;</span><br><span class="line">  a: <span class="type">1</span>,</span><br><span class="line">  b: <span class="type"></span>[ <span class="string">'e'</span>, <span class="string">'f'</span>, <span class="string">'g'</span> ],</span><br><span class="line">  c: <span class="type"></span>&#123; h: <span class="type"></span>&#123; i: <span class="type">2 </span>&#125; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const <span class="keyword">new</span><span class="type">Obj</span> = JSON.parse(JSON.stringify(oldObj))</span><br><span class="line">console.log(<span class="keyword">new</span><span class="type">Obj</span>.c.h, oldObj.c.h); <span class="comment">// &#123;i:2&#125; &#123;i:2&#125;</span></span><br><span class="line">console.log(oldObj.c.h === <span class="keyword">new</span><span class="type">Obj</span>.c.h); <span class="comment">//false</span></span><br><span class="line"><span class="keyword">new</span><span class="type">Obj</span>.c.h = &#123;i:<span class="type">5</span>&#125;</span><br><span class="line">console.log(<span class="keyword">new</span><span class="type">Obj</span>.c.h, oldObj.c.h); <span class="comment">// &#123;i:5&#125; &#123;i:2&#125;</span></span><br><span class="line"><span class="keyword">new</span><span class="type">Obj</span>.a = <span class="number">2</span></span><br><span class="line">console.log(<span class="keyword">new</span><span class="type">Obj</span>.a, oldObj.a); <span class="comment">// 2  1</span></span><br><span class="line"><span class="keyword">new</span><span class="type">Obj</span>.b[<span class="number">0</span>] = <span class="string">'huang'</span></span><br><span class="line">console.log(<span class="keyword">new</span><span class="type">Obj</span>.b, oldObj.b); <span class="comment">// [ 'huang', 'f', 'g' ] [ 'e', 'f', 'g' ]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>缺点</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params">pname</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = pname;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> Messi = <span class="keyword">new</span> person(<span class="string">'Messi'</span>);</span><br><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hi'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> oldObj = &#123;</span><br><span class="line">  a: say,</span><br><span class="line">  b: <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>),</span><br><span class="line">  c: <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'ab+c'</span>, <span class="string">'i'</span>),</span><br><span class="line">  d: Messi</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> newObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(oldObj));</span><br><span class="line"><span class="comment">// 无法复制函数</span></span><br><span class="line"><span class="built_in">console</span>.log(newObj.a, oldObj.a); <span class="comment">// undefined [Function: say]</span></span><br><span class="line"><span class="comment">// 稀疏数组复制错误</span></span><br><span class="line"><span class="built_in">console</span>.log(newObj.b[<span class="number">0</span>], oldObj.b[<span class="number">0</span>]); <span class="comment">// null undefined</span></span><br><span class="line"><span class="comment">// 无法复制正则对象</span></span><br><span class="line"><span class="built_in">console</span>.log(newObj.c, oldObj.c); <span class="comment">// &#123;&#125; /ab+c/i</span></span><br><span class="line"><span class="comment">// 构造函数指向错误</span></span><br><span class="line"><span class="built_in">console</span>.log(newObj.d.constructor, oldObj.d.constructor); <span class="comment">// [Function: Object] [Function: person]</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>Js</tag>
      </tags>
  </entry>
  <entry>
    <title>part1 模块一 es6与ts</title>
    <url>/2020/09/23/%E5%A4%A7%E5%89%8D%E7%AB%AF/part1/%E6%A8%A1%E5%9D%97%E4%B8%80%20-%20es6%E4%B8%8Ets/</url>
    <content><![CDATA[<h1 id="es6"><a href="#es6" class="headerlink" title="es6"></a>es6</h1><h2 id="闭包就是利用函数作用域摆脱全局作用域带来的影响"><a href="#闭包就是利用函数作用域摆脱全局作用域带来的影响" class="headerlink" title="闭包就是利用函数作用域摆脱全局作用域带来的影响"></a>闭包就是利用函数作用域摆脱全局作用域带来的影响</h2><h2 id="let其实也是闭包"><a href="#let其实也是闭包" class="headerlink" title="let其实也是闭包"></a>let其实也是闭包</h2><h2 id="for循环其实有两个作用域"><a href="#for循环其实有两个作用域" class="headerlink" title="for循环其实有两个作用域"></a>for循环其实有两个作用域</h2><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">for (<span class="name">let</span> i = <span class="number">0</span><span class="comment">;i &lt; 3; i++)&#123;</span></span><br><span class="line">    let i = 'foo'</span><br><span class="line">    console.log(<span class="name">i</span>) // foo foo foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 相当于</span><br><span class="line">let i = <span class="number">0</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">if (<span class="name">i</span> &lt; <span class="number">3</span>) &#123;</span><br><span class="line">    let i = 'foo'</span><br><span class="line">    console.log(<span class="name">i</span>)</span><br><span class="line">&#125;</span><br><span class="line">i++<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">if (<span class="name">i</span> &lt; <span class="number">3</span>) &#123;</span><br><span class="line">    let i = 'foo'</span><br><span class="line">    console.log(<span class="name">i</span>)</span><br><span class="line">&#125;</span><br><span class="line">i++<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">if (<span class="name">i</span> &lt; <span class="number">3</span>) &#123;</span><br><span class="line">    let i = 'foo'</span><br><span class="line">    console.log(<span class="name">i</span>)</span><br><span class="line">&#125;</span><br><span class="line">i++<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h2 id="数组结构，根据位置结构"><a href="#数组结构，根据位置结构" class="headerlink" title="数组结构，根据位置结构"></a>数组结构，根据位置结构</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a,b,<span class="built_in">c</span>] = arr </span><br><span class="line">console.log(a,b,<span class="built_in">c</span>)<span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [,,<span class="built_in">c</span>] = arr</span><br><span class="line">console.log(<span class="built_in">c</span>) <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a,...rest] = arr</span><br><span class="line">console.log(rest) <span class="comment">// [2,3]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a,b,<span class="built_in">c</span>,d] = arr</span><br><span class="line">console.log(d) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a,b,<span class="built_in">c</span>,d = <span class="string">"9"</span>] = arr</span><br><span class="line">console.log(d) <span class="comment">// 9  设置默认值</span></span><br></pre></td></tr></table></figure>
<h2 id="对象的结构，按照变量名结构"><a href="#对象的结构，按照变量名结构" class="headerlink" title="对象的结构，按照变量名结构"></a>对象的结构，按照变量名结构</h2><figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">let obj = &#123;name: <span class="string">'hjj'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; name: <span class="built_in">objname</span> = <span class="string">"defalut"</span> &#125; = obj</span><br><span class="line"><span class="keyword">const</span> name= <span class="string">"hh"</span></span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">objname</span>) // <span class="built_in">objname</span>   别名、并且可以设置默认值</span><br></pre></td></tr></table></figure>
<h2 id="object-defineProperty"><a href="#object-defineProperty" class="headerlink" title="object.defineProperty"></a>object.defineProperty</h2><p>object.defineProperty是劫持数据，对原本的属性或者方法进行重载，并且需要使用object.keys对对象进项遍历操作。对数组变化不方便，使用proxy更简单。具体之后自行百度</p>
<h2 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h2><figure class="highlight qml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj =&#123;</span><br><span class="line">    <span class="attribute">name</span>:<span class="string">'hhh'</span>,</span><br><span class="line">    <span class="attribute">age</span>: <span class="number">7</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj,&#123;</span><br><span class="line">    get(target, <span class="keyword">property</span><span class="string"></span>, value)&#123;</span><br><span class="line">        <span class="keyword">return</span> target[<span class="keyword">property</span><span class="string">]</span></span><br><span class="line">    &#125;, </span><br><span class="line">    set(target, <span class="keyword">property</span><span class="string"></span>, value)&#123;</span><br><span class="line">        <span class="keyword">return</span> target[<span class="keyword">property</span><span class="string">] </span>= value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(proxy.name = <span class="string">"1"</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.age) <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>
<h2 id="class"><a href="#class" class="headerlink" title="class"></a>class</h2><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只要类的方法没有加static， 那么方法里边的this就指的是实例，否则就是指的是类。</span></span><br><span class="line"><span class="comment">// 静态方法只能通过类调用，不能通过实例调用。eg:Foo.bar()</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">bar</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.baz();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">baz</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        console.log(<span class="string">'hello'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    baz() &#123;</span><br><span class="line">      console.log(<span class="string">'world'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">Foo.bar() <span class="comment">// hello</span></span><br></pre></td></tr></table></figure>
<h2 id="reflect"><a href="#reflect" class="headerlink" title="reflect"></a>reflect</h2><p>reflect其实就是对对象的API进行统一操作的，是proxy第二个参数没有设置的时候，默认会设置reflect.get()方法</p>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line">let s = <span class="keyword">new</span> Set()</span><br><span class="line">s.<span class="built_in">add</span>(<span class="number">1</span>).<span class="built_in">add</span>(<span class="number">2</span>).<span class="built_in">add</span>(<span class="number">3</span>)</span><br><span class="line">console.<span class="built_in">log</span>(s) <span class="comment">// Set(3) &#123; 1, 2, 3 &#125;</span></span><br><span class="line">console.<span class="built_in">log</span>(s.has(<span class="number">2</span>)) <span class="comment">// true</span></span><br><span class="line">console.<span class="built_in">log</span>(s.has(<span class="number">4</span>)) <span class="comment">// false</span></span><br><span class="line">console.<span class="built_in">log</span>(s.<span class="built_in">size</span>) <span class="comment">// 3</span></span><br><span class="line">console.<span class="built_in">log</span>(s.delete(<span class="number">4</span>)) <span class="comment">// false</span></span><br><span class="line">console.<span class="built_in">log</span>(s.delete(<span class="number">2</span>)) <span class="comment">// true  参数为要删除的元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i of s) &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(i) <span class="comment">// 1  3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> res = [... <span class="keyword">new</span> Set(s)]</span><br><span class="line">console.<span class="built_in">log</span>(res) <span class="comment">// [1,3]</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="keyword">Array</span>.from(s)) <span class="comment">// [1,3]</span></span><br></pre></td></tr></table></figure>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>map结构的数据跟对象的结构一样，都是存储的键值对，但是对象中的键只能是字符串，但是map结构的键不仅仅局限于字符串</p>
<h2 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a>symbol</h2><figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">let <span class="built_in">name</span> = Symbol()</span><br><span class="line">let person =  &#123;</span><br><span class="line">    [<span class="built_in">name</span>]: <span class="string">"hjj"</span>,</span><br><span class="line">    <span class="built_in">say</span> () &#123;</span><br><span class="line">        console.<span class="built_in">log</span>(this[<span class="built_in">name</span>])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(person[Symbol()]) <span class="comment">// undefined</span></span><br><span class="line">console.<span class="built_in">log</span>(person[<span class="built_in">name</span>]) <span class="comment">// hjj</span></span><br><span class="line">person.<span class="built_in">say</span>() <span class="comment">// hjj</span></span><br></pre></td></tr></table></figure>
<h2 id="for-…-of"><a href="#for-…-of" class="headerlink" title="for … of"></a>for … of</h2><p>forEach、map 都不可以跳出循环</p>
<h2 id="字符串补长度"><a href="#字符串补长度" class="headerlink" title="字符串补长度"></a>字符串补长度</h2><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">padStart       <span class="string">"0.1"</span><span class="string">.padStart</span><span class="params">(5,0)</span> <span class="string">//</span> 000.1</span><br><span class="line">padEnd        <span class="string">"0.1"</span><span class="string">.padEnd</span><span class="params">(5,0)</span> <span class="string">//</span> 0.100</span><br></pre></td></tr></table></figure>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeIterator</span> <span class="params">(arr)</span></span> &#123;</span><br><span class="line">    let index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="built_in">next</span>: <span class="function"><span class="keyword">function</span> <span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">return</span> index &lt; arr.length ? &#123;value:arr[index ++],done:<span class="literal">false</span>&#125; : &#123;done: <span class="literal">true</span>&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let arr = makeIterator([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">console.<span class="built_in">log</span>(arr.<span class="built_in">next</span>()) // &#123; value: <span class="number">1</span>, done: <span class="literal">false</span> &#125;</span><br><span class="line">console.<span class="built_in">log</span>(arr.<span class="built_in">next</span>()) // &#123; value: <span class="number">2</span>, done: <span class="literal">false</span> &#125;</span><br><span class="line">console.<span class="built_in">log</span>(arr.<span class="built_in">next</span>()) // &#123; value: <span class="number">3</span>, done: <span class="literal">false</span> &#125;</span><br><span class="line">console.<span class="built_in">log</span>(arr.<span class="built_in">next</span>()) // &#123; done: <span class="literal">true</span> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>简单来说，生成器（Generator）就是一个自带迭代器（Iterator）的函数。<br><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">fn</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let it = fn();</span><br><span class="line">console.<span class="built_in">log</span>(it.<span class="built_in">next</span>()); // &#123;value: <span class="number">1</span>, done: <span class="literal">false</span>&#125;</span><br><span class="line">console.<span class="built_in">log</span>(it.<span class="built_in">next</span>()); // &#123;value: <span class="number">2</span>, done: <span class="literal">false</span>&#125;</span><br><span class="line">console.<span class="built_in">log</span>(it.<span class="built_in">next</span>()); // &#123;value: <span class="number">3</span>, done: <span class="literal">false</span>&#125;</span><br><span class="line">console.<span class="built_in">log</span>(it.<span class="built_in">next</span>()); // &#123;value: undefined, done: <span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    foo = foo + <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="number">10</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'main'</span>, foo)</span><br><span class="line">&#125;</span><br><span class="line">main()</span><br><span class="line"></span><br><span class="line">foo++</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'foo'</span>, foo)</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo 101</span></span><br><span class="line"><span class="comment">// main 110</span></span><br></pre></td></tr></table></figure>
<p>理解：为什么main的时候输出不是111呢，在执行main函数的时候，还没有执行到await的时候都是同步执行的，也就是说await之前的foo还是同步的是100，还没执行到foo++，所以输出是110.</p>
<h1 id="javascript异步编程"><a href="#javascript异步编程" class="headerlink" title="javascript异步编程"></a>javascript异步编程</h1><h1 id="ts"><a href="#ts" class="headerlink" title="ts"></a>ts</h1>]]></content>
      <categories>
        <category>大前端</category>
      </categories>
      <tags>
        <tag>大前端</tag>
      </tags>
  </entry>
  <entry>
    <title>part1 模块二 函数式编程、js性能优化</title>
    <url>/2020/09/23/%E5%A4%A7%E5%89%8D%E7%AB%AF/part1/%E6%A8%A1%E5%9D%97%E4%BA%8C%20-%20%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E3%80%81js%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h3 id="一、函数式编程"><a href="#一、函数式编程" class="headerlink" title="一、函数式编程"></a>一、函数式编程</h3><h4 id="1-高阶函数的意义"><a href="#1-高阶函数的意义" class="headerlink" title="1.高阶函数的意义"></a>1.高阶函数的意义</h4><h4 id="2-柯里化函数"><a href="#2-柯里化函数" class="headerlink" title="2.柯里化函数"></a>2.柯里化函数</h4><p>定义一个函数A，他可以接收多个参数，对其进行改造，先定义一个函数B，让其接收一部分参数，并且该函数（B）的返回值是另一个函数（C），然后另一个函数（C）接收剩余的参数。<br>官方描述：</p>
<ul>
<li>当一个函数有多个参数的时候，先传递一部分参数调用它(这部分参数后续永远不变)</li>
<li>然后返回一个新的函数，接收其他参数，返回结果。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// function fn(min) &#123;</span></span><br><span class="line"><span class="comment">//     return function(age)&#123;</span></span><br><span class="line"><span class="comment">//         return age &gt;= min</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// es6 写法</span></span><br><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="params">min</span> =&gt;</span> (<span class="function"><span class="params">age</span> =&gt;</span> age &gt;= min)</span><br><span class="line"><span class="comment">// 定义标准为18岁的函数</span></span><br><span class="line"><span class="keyword">let</span> fn18 = fn(<span class="number">18</span>)</span><br><span class="line"><span class="comment">// 定义标准为18岁的函数</span></span><br><span class="line"><span class="keyword">let</span> fn20 = fn(<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fn18(<span class="number">20</span>))</span><br><span class="line"><span class="built_in">console</span>.log(fn20(<span class="number">66</span>))</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="二、性能优化"><a href="#二、性能优化" class="headerlink" title="二、性能优化"></a>二、性能优化</h3><p>GC执行的时候程序是暂停的<br>使用工具<br>performance 、 浏览器的任务管理器、堆块照（查找分离dom）<br>分离dom：在页面上没有显示，但是在js中有引用</p>
<h4 id="v8垃圾回收"><a href="#v8垃圾回收" class="headerlink" title="v8垃圾回收"></a>v8垃圾回收</h4><p>1.v8是一款主流的js执行引擎<br>2.v8内存设置上限<br>3.v8采用基于分代回收思想实现垃圾回收机制<br>4.v8内存分为新生代跟老生代<br>5.v8垃圾回收机制常见的GC算法<br>对于新生代</p>
<ul>
<li>复制算法、标记算法</li>
</ul>
<p>对于老生代</p>
<ul>
<li>标记清除、标记整理、增量标记<h4 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h4></li>
</ul>
<ol>
<li><p>精准测试自己的代码</p>
<p>  benchmark.js 地址<a href="https://jsperf.com/" target="_blank" rel="noopener">https://jsperf.com/</a></p>
</li>
<li><p>foreach性能比for好</p>
</li>
<li>字面量定义object的性能比用哪个new的好</li>
</ol>
]]></content>
      <categories>
        <category>大前端</category>
      </categories>
      <tags>
        <tag>大前端</tag>
      </tags>
  </entry>
  <entry>
    <title>part2 模块一 开发脚手架及封装自动化构建</title>
    <url>/2021/02/24/%E5%A4%A7%E5%89%8D%E7%AB%AF/part2/%E6%A8%A1%E5%9D%97%E4%B8%80%20-%20%E5%BC%80%E5%8F%91%E8%84%9A%E6%89%8B%E6%9E%B6%E5%8F%8A%E5%B0%81%E8%A3%85%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BA/</url>
    <content><![CDATA[<p>暂未完成，敬请期待。。。</p>
<h3 id="一、工程化概述"><a href="#一、工程化概述" class="headerlink" title="一、工程化概述"></a>一、工程化概述</h3><h3 id="二、脚手架工具"><a href="#二、脚手架工具" class="headerlink" title="二、脚手架工具"></a>二、脚手架工具</h3><h4 id="Yeoman使用"><a href="#Yeoman使用" class="headerlink" title="Yeoman使用"></a>Yeoman使用</h4><blockquote>
<p>自定义generator步骤</p>
</blockquote>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.全局安装yeoman的命令行</span></span><br><span class="line">yarn <span class="keyword">global</span> <span class="keyword">add</span> yo </span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.确定好自己的文件模板，文件目录等</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.创建一个名字为gernerator-xxx的文件夹</span></span><br><span class="line">mkdir gernerator-hjj-vue</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.初始化一个package.json文件</span></span><br><span class="line">yarn init</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.安装yeoman的依赖yeoman-gernerator</span></span><br><span class="line">yarn <span class="keyword">add</span> yeoman-gernerator</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.打开项目gernerator-hjj-vue</span></span><br><span class="line">code .</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7.编辑完成后，把当前生成器链接到全局</span></span><br><span class="line">yarn link</span><br><span class="line"></span><br><span class="line"><span class="comment">// 8.重新打开一个文件，安装自定义生成器hjj-vue</span></span><br><span class="line">yo hjj-vue</span><br><span class="line"></span><br><span class="line"><span class="comment">// 9.发布阶段，</span></span><br><span class="line">touch .gitignore   <span class="comment">//忽略node_moduls</span></span><br><span class="line">git init <span class="comment">// 初始化</span></span><br><span class="line">git status</span><br><span class="line">git <span class="keyword">add</span> .</span><br><span class="line">git commit -m <span class="string">"xxx"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 10.去github上创建一个仓库，提交生成器代码</span></span><br><span class="line">git push</span><br><span class="line"></span><br><span class="line"><span class="comment">// 11.发布 generator本身就是一个npm包，所以发布是一样的命令</span></span><br><span class="line">yarn publish</span><br><span class="line"></span><br><span class="line"><span class="comment">// 12.完成后去npm官网查看</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>才坑记录：<br>  1.yarn link的时候报错：<br>    <code>This generator (apple:app) requires yeoman-environment at least 3.0.0, current version is 2.10.3, try reinstalling latest version of &#39;yo&#39; or use &#39;--ignore-version-check&#39; option</code><br>    解决防范：<br>      package.json中更改”yeoman-generator”: “4.1.0”，我当时的版本是5.2.0<br>  2.这一个自己想想都搞笑的错误，因为单词写错了，导致在其他文件使用自己写的脚手架的时候，一直报错找不到对应的generator，一定要细心啊。。。</p>
</blockquote>
<h3 id="plop的使用"><a href="#plop的使用" class="headerlink" title="plop的使用"></a>plop的使用</h3><blockquote>
<p>用于创建同类型的文件，即相同的模版</p>
<ul>
<li>使用步骤：<ul>
<li>把plop模块当作项目依赖安装, yarn add plop –dev</li>
<li>在项目根目录下粗昂见一个配置文件plopfile.js,此文件是plop的入口文件，导出一个函数。</li>
<li>在配置文件中定义脚手架的任务，例如添加一个任务名称为addComponent</li>
<li>编写特定的模版,模板文件名称 xxx.hbs</li>
<li>用plop提供的cli运行任务,yarn plop addComponent</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="三、自动化构建"><a href="#三、自动化构建" class="headerlink" title="三、自动化构建"></a>三、自动化构建</h3><h4 id="一、gulp的初始化"><a href="#一、gulp的初始化" class="headerlink" title="一、gulp的初始化"></a>一、gulp的初始化</h4><ul>
<li>yarn init –yes</li>
<li>yarn add gulp –dev</li>
</ul>
<h4 id="二、"><a href="#二、" class="headerlink" title="二、"></a>二、</h4>]]></content>
      <categories>
        <category>大前端</category>
      </categories>
      <tags>
        <tag>大前端</tag>
      </tags>
  </entry>
  <entry>
    <title>part2 模块二 模块化开发标准</title>
    <url>/2021/02/24/%E5%A4%A7%E5%89%8D%E7%AB%AF/part2/%E6%A8%A1%E5%9D%97%E4%BA%8C%20-%20%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E6%A0%87%E5%87%86/</url>
    <content><![CDATA[<h3 id="一、modules"><a href="#一、modules" class="headerlink" title="一、modules"></a>一、modules</h3><ul>
<li>ES modules特性，以下情况都是ES modules情况下<ul>
<li>默认是严格模式，严格模式下this为undefined，非严格模式下指的是全局对象（window\global）</li>
<li>私有作用域，不同的script中有独立的私有作用域</li>
<li>外部的js是通过cors的方式，所以外部服务其要支持cors，否则就跨域了</li>
<li>script的标签会延迟执行脚本。js执行会阻塞页面渲染，使用ES modules进行了优化</li>
</ul>
</li>
<li><p>ES modules导出<br>| 数据 | 导出 | 导入 |<br>| — | — | — |<br>|  | export var foo = “aa” | import {foo} from “xxx” |<br>| var name = “hjj” var age = “18” | export {name,age} | import {name,age} from “xxx” |<br>| var name = “hjj” var age = “18” | export {name as fooName,<br>age as fooAge} | import {fooName,fooAge} from “xxx” |<br>| var name = “hjj” | export default name | import name from “xxx” |<br>| var name = “hjj” var age = “18” | export default {name,age} | import * as obj from “xxx” , obj.xx |</p>
</li>
<li><p>注意事项</p>
<ul>
<li>export {}这个花括弧是固定写法，不是es6的解构，import导入的也不是一个对象</li>
<li>想导出一个对象的话，使用export default {name,age}这种格式。</li>
<li>ES modules导出的是引用，并且导出来的是只读的，不能修改的</li>
<li>import导入的时候，文件后缀不可省略</li>
<li>import导入的时候，文件路径可以使用相对路径./xxx、绝对路径/xx/xx、完整路径<a href="https://www.baidu.com" target="_blank" rel="noopener">https://www.baidu.com</a></li>
<li>import {} from “xx”等同于import “xx”,意思是直接执行，不提取任何变量</li>
<li>import(“模块路径”).then((modules)=&gt;{console.log(modules)}),此写法用于动态导入。</li>
<li>import title,{name,age} from “xx”,此写法用于导入默认成员title（title为默认成员的名称，名称随便起）,跟其他具名成员的，</li>
</ul>
</li>
<li>ie兼容问题<ul>
<li>Polyfill 是一块代码（通常是 Web 上的 JavaScript），用来为旧浏览器提供它没有原生支持的较新的功能。</li>
<li>插件 ES Modules Loader模块   nomodule这个属性，让js在不支持的浏览器运行</li>
</ul>
</li>
<li>ES Modules跟CommonJS<ul>
<li>ES Modules中可以导入CommonJS模块，单仅限于导入的是默认的模块的方式。module.exports = {}</li>
<li>CommonJS中不能导入ES Modules模块</li>
<li>CommonJS始终智慧导出一个默认成员</li>
<li>import 导入不是解构</li>
</ul>
</li>
</ul>
<p><br></p>
<h3 id="二、webpack"><a href="#二、webpack" class="headerlink" title="二、webpack"></a>二、webpack</h3><h3 id="三、Rollup"><a href="#三、Rollup" class="headerlink" title="三、Rollup"></a>三、Rollup</h3><h3 id="四、eslint、prettier"><a href="#四、eslint、prettier" class="headerlink" title="四、eslint、prettier"></a>四、eslint、prettier</h3>]]></content>
      <categories>
        <category>大前端</category>
      </categories>
      <tags>
        <tag>大前端</tag>
      </tags>
  </entry>
</search>
